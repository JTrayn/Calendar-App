<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Multi-Year Calendar (2020-2030) + Hevy Chart</title>

  <!-- Include Chart.js from a CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700;900&display=swap');

	/* =========================================
	   1) IMPORTS & FONT / BASE RESET
	   ========================================= */
	@import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700;900&display=swap');
	* {
	  margin: 0;
	  padding: 0;
	  box-sizing: border-box;
	}
	html, body {
	  height: 100%;
	  width: 100%;
	  background: #1E1E1E;
	  color: #EAEAEA;
	  font-family: 'Montserrat', sans-serif;
	  user-select: none;
	}

	/* =========================================
	   2) BODY LAYOUT & MAIN WRAPPER
	   ========================================= */
	body {
	  display: flex;
	  justify-content: center;
	  align-items: center;
	}
	.main-wrapper {
	  background: rgba(50, 50, 50, 0.5);
	  padding: 1rem;
	  border-radius: 8px;
	  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
	  max-width: 800px;
	  width: 1000px;
	  margin: 20px auto;
	  display: flex;
	  flex-direction: column;
	  align-items: center;
	  backdrop-filter: blur(2px);
	  -webkit-backdrop-filter: blur(2px);
	}

	/* =========================================
	   3) MONTH BAR & NAVIGATION BUTTONS
	   ========================================= */
	.month-bar {
	  display: flex;
	  flex-direction: row;
	  align-items: center;
	  margin-bottom: 1rem;
	  width: 100%;
	  justify-content: center;
	}
	.month-title {
	  font-size: 1.1rem;
	  font-weight: 700;
	  padding: 0.2rem 0.5rem;
	  width: 200px;
	  text-align: center;
	  white-space: nowrap;
	}
	.arrow-buttons {
	  display: inline-flex;
	  align-items: center;
	  gap: 0.5rem;
	  margin-left: 2rem;
	}
	.month-nav-buttons {
	  display: inline-flex;
	  gap: 0.5rem;
	}
	.data-buttons {
	  display: inline-flex;
	  gap: 0.5rem;
	  margin-left: 1.5rem;
	  align-items: center;
	}
	.arrow-button {
	  background-color: rgba(51, 51, 51, 0.3);
	  border: 0px solid #555;
	  color: #EAEAEA;
	  cursor: pointer;
	  font-size: 1rem;
	  min-width: 2rem;
	  height: 2rem;
	  border-radius: 4px;
	  text-align: center;
	  line-height: 2rem;
	  padding: 0 0.5rem;
	  transition: background-color 0.2s, border 0.2s;
	  display: flex;
	  align-items: center;
	  justify-content: center;
	}
	.arrow-button:hover {
	  background-color: #444;
	}
	.arrow-button:disabled {
	  background-color: #555;
	  cursor: not-allowed;
	  opacity: 0.5;
	}
	.arrow-button img {
	  vertical-align: middle;
	  display: inline-block;
	  position: relative;
	  top: -1px;
	}

	/* =========================================
	   4) CALENDAR LAYOUT
	   ========================================= */
	.calendar-container {
	  width: 100%;
	  max-width: 700px;
	}
	.calendar-header,
	.calendar-grid {
	  display: grid;
	  grid-template-columns: repeat(7, 1fr);
	  gap: 0.3rem;
	}
	.calendar-header div {
	  text-align: center;
	  font-weight: bold;
	  padding: 0.5rem 0;
	  border-bottom: 1px solid rgba(68, 68, 68, 0.5);
	  font-size: 0.85rem;
	}
	.calendar-grid {
	  margin-top: 0.5rem;
	}

	/* =========================================
	   5) DAY CELL STYLES
	   ========================================= */
	.day-cell {
	  aspect-ratio: 1 / 1;
	  border-radius: 2px;
	  position: relative;
	  overflow: hidden;
	  display: flex;
	  flex-direction: column;
	  justify-content: center;
	  align-items: center;
	  font-size: 0.8rem;
	  cursor: pointer;
	  transition: all 0.2s ease-in-out;
	  padding: 0.5rem;
	}
	.day-cell:hover {
	  outline: 2px solid #888;
	}
	.faded {
	  opacity: 0.15;
	  pointer-events: none;
	}

	.off-bg {
	  background-color: #3A3A3A;
	  opacity: 0.8;
	}
	.al-bg {
	  background-color: #616161;
	  opacity: 0.9;
	}
	.custom-shift {}
	.selected {
	  outline: 2px solid limegreen !important;
	}
	.today {
	  outline: 3px solid #FFD700;
	}

	/* =========================================
	   6) DAY CELL CONTENT (ICONS, TEXT, ETC.)
	   ========================================= */
	.date-num {
	  position: absolute;
	  top: 4px;
	  left: 6px;
	  font-weight: bold;
	  font-size: 0.75rem;
	  color: rgba(255,255,255,0.8);
	  white-space: nowrap;
	  pointer-events: none;
	}
	.refresh-emoji {
	  position: absolute;
	  top: 4px;
	  right: 6px;
	  font-size: 1rem;
	  z-index: 3;
	  cursor: pointer;
	  opacity: 0.15;
	  transition: opacity 0.2s;
	}
	.refresh-emoji:hover {
	  opacity: 1.0;
	}
	.weight-display {
	  position: absolute;
	  top: 42%;
	  left: 50%;
	  transform: translate(-50%, -50%);
	  font-size: 0.9rem;
	  text-align: center;
	  white-space: nowrap;
	  color: #FFF;
	  font-weight: bold;
	  pointer-events: none;
	}
	.shift-time-text {
	  position: absolute;
	  top: 60%;
	  left: 50%;
	  transform: translate(-50%, -50%);
	  font-size: 1rem;
	  font-weight: bold;
	  white-space: nowrap;
	  color: rgba(0, 0, 0, 0.3);
	  pointer-events: none;
	}
	.free-time-text {
	  position: absolute;
	  top: 10%;
	  left: 50%;
	  transform: translate(-50%, -50%);
	  font-size: 0.65rem;
	  font-weight: bold;
	  white-space: nowrap;
	  color: rgba(0, 0, 0, 0.3);
	  pointer-events: none;
	}
	.workout-info {
	  position: absolute;
	  bottom: 4px;
	  left: 0;
	  right: 0;
	  text-align: center;
	  font-size: 0.75rem;
	  line-height: 1.1;
	  color: #FFF;
	  opacity: 0.75;
	  pointer-events: none;
	}

	/* =========================================
	   7) COMPLETED BADGE
	   ========================================= */
	.completed-badge {
	  position: absolute;
	  bottom: 4px;
	  right: 4px;
	  width: 24px;
	  height: 24px;
	  border-radius: 50%;
	  background-color: #28a745;
	  color: #fff;
	  font-size: 1rem;
	  text-align: center;
	  line-height: 24px;
	  box-shadow: 0 0 5px rgba(0,0,0,0.5);
	  cursor: pointer;
	  user-select: none;
	  transition: opacity 0.2s ease-out, transform 0.2s ease-out;
	  opacity: 0;
	}
	.day-cell:hover .completed-badge:not(.enabled) {
	  opacity: 0.3;
	}
	.day-cell.completed .completed-badge.enabled {
	  opacity: 1.0;
	}
	.completed-badge:hover {
	  transform: scale(1.1);
	  opacity: 1.0;
	}

	/* =========================================
	   8) ALERT OVERLAY & TEXT
	   ========================================= */
	.alert-overlay {
	  position: absolute;
	  top: 0;
	  left: 0;
	  right: 0;
	  height: 50%;
	  z-index: 2;
	  pointer-events: none;
	}
	.alert-text {
	  position: absolute;
	  top: 1.2rem;
	  left: 0;
	  right: 0;
	  margin: 0 auto;
	  width: 80%;
	  text-align: center;
	  font-size: 0.65rem;
	  font-weight: bold;
	  color: #fff;
	  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.6);
	  white-space: nowrap;
	  overflow: hidden;
	  text-overflow: ellipsis;
	  z-index: 3;
	  pointer-events: none;
	}

	/* =========================================
	   9) MODAL OVERLAYS: BASE STYLES
	   ========================================= */
	.overlay {
	  display: none;
	  position: fixed;
	  top: 0;
	  left: 0;
	  width: 100%;
	  height: 100%;
	  background-color: rgba(0,0,0,0.6);
	  z-index: 999;
	  justify-content: center;
	  align-items: center;
	  opacity: 0;
	  transition: opacity 0.3s ease;
	}
	.overlay.active {
	  display: flex;
	  opacity: 1;
	}
	.modal {
	  position: relative;
	  background: #2D2D2D;
	  padding: 1.5rem;
	  border-radius: 6px;
	  width: 420px;
	  box-shadow: 0 2px 10px rgba(0,0,0,0.7);
	  display: flex;
	  flex-direction: column;
	  gap: 0.3rem;
	  transform: translateY(-20px);
	  animation: slideDownFade 0.3s forwards;
	}
	@keyframes slideDownFade {
	  0% {
		opacity: 0;
		transform: translateY(-20px);
	  }
	  100% {
		opacity: 1;
		transform: translateY(0);
	  }
	}
	.modal h2 {
	  font-size: 1.2rem;
	  margin-bottom: 0.5rem;
	  text-align: center;
	}
	.modal-buttons {
	  display: flex;
	  justify-content: space-between;
	  gap: 1rem;
	  margin-top: 0.5rem;
	}
	.modal-buttons button {
	  flex: 1;
	  cursor: pointer;
	  padding: 0.5rem;
	  font-size: 0.9rem;
	  border: 1px solid #555;
	  border-radius: 4px;
	  background: #444;
	  color: #EAEAEA;
	  transition: background-color 0.2s;
	}
	.modal-buttons button:hover {
	  background: #555;
	}

	/* =========================================
	   10) SINGLE-CELL EDIT MODAL (#singleModal)
	   ========================================= */
	#singleOverlay .modal#singleModal {
	  width: 420px;
	  padding: 1rem;
	  padding-bottom: 0rem;
	  max-height: 80vh; /* Increased to restore taller appearance */
	  overflow-y: auto;
	  display: flex;
	  flex-direction: column;
	}
	#singleModal h2 {
	  font-size: 1.1rem;
	  color: #EAEAEA;
	  margin-bottom: 0rem;
	  text-align: center;
	  padding-bottom: 0.4rem;
	  border-bottom: 1px solid #444;
	}
	#singleModal .modal-date {
	  position: static;
	  margin-top: 0.5rem;
	  margin-bottom: 0.5rem;
	  text-align: center;
	  font-size: 0.9rem;
	  color: #888;
	}
	#singleModal .modal-subtitle {
	  text-align: center;
	  color: #888;
	  font-size: 0.9rem;
	  margin: -1rem 0 0rem 0;
	}
	#singleModal .modal-row {
	  display: flex;
	  flex-direction: column;
	  gap: 0.25rem;
	  background: #393939;
	  padding: 0.5rem;
	  border-radius: 6px;
	  margin-bottom: 0.35rem;
	  transition: background-color 0.2s;
	}
	#singleModal .modal-row:hover {
	  background: #424242;
	}
	#singleModal .modal-row label {
	  font-size: 0.9rem;
	  display: flex;
	  align-items: center;
	  gap: 0.5rem;
	  justify-content: flex-start;
	}
	#singleModal .reset-emoji {
	  cursor: pointer;
	  opacity: 0.5;
	  transition: all 0.2s;
	  font-size: 1rem;
	  padding: 4px;
	  border-radius: 4px;
	  margin-left: auto;
	}
	#singleModal .reset-emoji:hover {
	  opacity: 1;
	  transform: rotate(180deg);
	}
	#singleModal select,
	#singleModal input[type="text"] {
	  width: 100%;
	  padding: 0.35rem;
	  background: #2D2D2D;
	  border: 1px solid #555;
	  border-radius: 4px;
	  color: #EAEAEA;
	  font-size: 0.8rem;
	  transition: all 0.2s;
	  height: 28px;
	}
	#singleModal select:hover,
	#singleModal input[type="text"]:hover {
	  border-color: #666;
	}
	#singleModal select:focus,
	#singleModal input[type="text"]:focus {
	  border-color: #4DAAFF;
	  outline: none;
	  box-shadow: 0 0 0 2px rgba(77, 170, 255, 0.2);
	}
	#singleModal .color-swatches {
	  display: grid;
	  grid-template-columns: repeat(auto-fit, minmax(32px, 1fr));
	  gap: 0.5rem;
	  margin-top: 0.5rem;
	}
	#singleModal .swatch {
	  aspect-ratio: 1;
	  border-radius: 4px;
	  cursor: pointer;
	  border: 2px solid transparent;
	  transition: all 0.2s;
	}
	#singleModal .swatch:hover {
	  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
	}
	#singleModal .swatch.active {
	  border-color: #4DAAFF;
	  box-shadow: 0 0 0 2px rgba(77, 170, 255, 0.3);
	}
	#singleModal .shift-label-text {
	  color: #4DAAFF;
	  font-weight: 500;
	  font-size: 0.85rem;
	  margin-left: 0.5rem;
	  flex-grow: 1;
	}
	#singleModal .modal-buttons {
	  display: grid;
	  grid-template-columns: 1fr auto 1fr;
	  gap: 0.5rem;
	  padding-top: 0.5rem;
	  padding-bottom: 0.5rem;
	  border-top: 1px solid #444;
	  margin-top: auto;
	  position: sticky;
	  bottom: 0;
	  background: #2D2D2D;
	}
	#singleModal #singleSaveBtn {
	  background: #4DAAFF;
	  color: white;
	}
	#singleModal #singleSaveBtn:hover {
	  background: #82c3ff;
	}
	#singleModal #singleRevertBtn {
	  background: #555;
	  color: #EEE;
	  font-size: 1.2rem;
	  padding: 0.4rem 1rem;
	}
	#singleModal #singleRevertBtn:hover {
	  background: #666;
	}
	#singleModal #singleCancelBtn {
	  background: #444;
	  color: #EEE;
	}
	#singleModal #singleCancelBtn:hover {
	  background: #555;
	}
	#singleModal select:disabled,
	#singleModal input[type="text"]:disabled {
	  background: #333;
	  border-color: #444;
	  color: #666;
	  cursor: not-allowed;
	}
	#singleModal #singleAlertTypeSelect option {
	  padding: 0.5rem;
	  background: #2D2D2D;
	}
	#singleColorSwatchesContainer .swatch.off-bg {
	  background-color: #2D2D2D;
	}
	#singleRevertBtn .rotate-emoji {
	  display: inline-block;
	  transition: transform 0.2s;
	}
	#singleRevertBtn:hover .rotate-emoji {
	  transform: rotate(180deg);
	}

	/* =========================================
	   11) MULTI-CELL EDIT MODAL (#multiModal)
	   ========================================= */
	#multiOverlay .modal#multiModal {
	  background: #2D2D2D;
	  border-radius: 8px;
	  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
	  width: 380px;
	  padding: 1rem;
	  max-height: 50vh;
	  overflow-y: auto;
	  display: flex;
	  flex-direction: column;
	}
	#multiModal h2 {
	  font-size: 1.1rem;
	  color: #EAEAEA;
	  margin-bottom: 0.5rem;
	  text-align: center;
	  padding-bottom: 0.4rem;
	  border-bottom: 1px solid #444;
	}
	#multiModal .modal-row {
	  display: flex;
	  flex-direction: column;
	  gap: 0.25rem;
	  background: #393939;
	  padding: 0.5rem;
	  border-radius: 6px;
	  margin-bottom: 0.35rem;
	  transition: background-color 0.2s;
	}
	#multiModal .modal-row:hover {
	  background: #424242;
	}
	#multiModal .modal-row label {
	  font-size: 0.9rem;
	  display: flex;
	  align-items: center;
	  gap: 0.5rem;
	}
	#multiModal select,
	#multiModal input[type="text"] {
	  width: 100%;
	  padding: 0.35rem;
	  background: #2D2D2D;
	  border: 1px solid #555;
	  border-radius: 4px;
	  color: #EAEAEA;
	  font-size: 0.8rem;
	  transition: all 0.2s;
	  height: 28px;
	}
	#multiModal select:hover,
	#multiModal input[type="text"]:hover {
	  border-color: #666;
	}
	#multiModal select:focus,
	#multiModal input[type="text"]:focus {
	  border-color: #4DAAFF;
	  outline: none;
	  box-shadow: 0 0 0 2px rgba(77, 170, 255, 0.2);
	}
	#multiModal .color-swatches {
	  display: grid;
	  grid-template-columns: repeat(auto-fit, minmax(32px, 1fr));
	  gap: 0.5rem;
	  margin-top: 0.5rem;
	}
	#multiModal .swatch {
	  aspect-ratio: 1;
	  border-radius: 4px;
	  cursor: pointer;
	  border: 2px solid transparent;
	  transition: all 0.2s;
	}
	#multiModal .swatch:hover {
	  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
	}
	#multiModal .swatch.active {
	  border-color: #4DAAFF;
	  box-shadow: 0 0 0 2px rgba(77, 170, 255, 0.3);
	}
	#multiColorSwatchesContainer .swatch.off-bg {
	  background-color: #2D2D2D;
	}
	#multiModal .shift-label-text {
	  color: #4DAAFF;
	  font-weight: 500;
	  font-size: 0.85rem;
	}
	#multiModal .modal-buttons {
	  display: grid;
	  grid-template-columns: 1fr auto 1fr;
	  gap: 0.5rem;
	  padding-top: 0.5rem;
	  border-top: 1px solid #444;
	  margin-top: auto;
	  position: sticky;
	  bottom: 0;
	  background: #2D2D2D;
	}
	#multiModal #multiSaveBtn {
	  background: #4DAAFF;
	  color: white;
	}
	#multiModal #multiSaveBtn:hover {
	  background: #82c3ff;
	}
	#multiModal #multiRevertBtn {
	  background: #555;
	  color: #EEE;
	  font-size: 1.2rem;
	  padding: 0.4rem 1rem;
	}
	#multiModal #multiRevertBtn:hover {
	  background: #666;
	}
	#multiModal #multiCancelBtn {
	  background: #444;
	  color: #EEE;
	}
	#multiModal #multiCancelBtn:hover {
	  background: #555;
	}
	#multiRevertBtn .rotate-emoji {
	  display: inline-block;
	  transition: transform 0.2s;
	}
	#multiRevertBtn:hover .rotate-emoji {
	  transform: rotate(180deg);
	}

	/* =========================================
	   12) STATS OVERLAY & WEIGHT CHART
	   ========================================= */
	#statsOverlay .modal#statsModal {
	  width: 420px;
	}
	#statsModal h2 {
	  font-size: 1.2rem;
	  text-align: center;
	  margin-bottom: 0.5rem;
	}
	.stats-summary {
	  display: flex;
	  flex-direction: column;
	  align-items: flex-start;
	  margin-bottom: 1rem;
	}
	.stat-item {
	  font-size: 1.1rem;
	  color: white;
	  margin-bottom: 0.5rem;
	}
	.counter-value {
	  color: white;
	  font-weight: bold;
	}
	#weightChart {
	  width: 100%;
	  height: 250px;
	}
	#statsCloseBtn {
	  cursor: pointer;
	}

	/* =========================================
	   13) PULSE ANIMATION (GENERIC)
	   ========================================= */
	@keyframes pulseEffect {
	  0% {
		transform: scale(1);
		box-shadow: 0 0 0 0 rgba(255, 255, 0, 0.5);
	  }
	  50% {
		transform: scale(1.03);
		box-shadow: 0 0 8px 4px rgba(255, 255, 0, 0.25);
	  }
	  100% {
		transform: scale(1);
		box-shadow: 0 0 0 0 rgba(255, 255, 0, 0);
	  }
	}
	.cell-pulse {
	  animation: pulseEffect 0.8s ease-out;
	}

	/* =========================================
	   14) UPDATED PR STYLING (SHIMMER & GLOW)
	   ========================================= */

	.pr-text {
	  position: relative;
	  display: inline-block;
	  background: linear-gradient(
		90deg,
		#FFD86F 0%,
		#FFE8A6 50%,
		#FFD86F 100%
	  );
	  background-size: 200% 200%;
	  background-position: 0% 50%;
	  -webkit-background-clip: text;
	  -webkit-text-fill-color: transparent;
	  background-clip: text;
	  color: transparent;
	  text-shadow:
		0 0 6px rgba(255, 216, 111, 0.6),
		0 0 2px rgba(255, 216, 111, 0.4);
	  animation: textShimmer 3s infinite ease-in-out;
	}

	@keyframes textShimmer {
	  0%   { background-position: 0%   50%; }
	  50%  { background-position: 100% 50%; }
	  100% { background-position: 0%   50%; }
	}

	.pr-border {
	  position: relative;
	  border: 2px solid #FFD86F;
	  overflow: visible;
	}

	.hevy-set.pr-border {
	  background: #000000; /* Your black background on PR sets */
	}

	/* Glimmering border animation */
	.pr-border::after {
	  content: "";
	  position: absolute;
	  top: -2px;
	  left: -2px;
	  right: -2px;
	  bottom: -2px;
	  background: linear-gradient(
		60deg,
		rgba(255, 216, 111, 0.1) 0%,
		rgba(255, 232, 166, 0.3) 50%,
		rgba(255, 216, 111, 0.1) 100%
	  );
	  background-size: 200% 200%;
	  background-position: 0% 50%;
	  border-radius: 4px;
	  pointer-events: none;
	  z-index: 0;
	  animation: borderShimmer 3s infinite ease-in-out;
	}

	@keyframes borderShimmer {
	  0%   { background-position: 0%   50%; }
	  50%  { background-position: 100% 50%; }
	  100% { background-position: 0%   50%; }
	}

	/* 14A) Twinkling PR Stars (always visible) */
	.pr-border .stars-container {
	  pointer-events: none; /* so stars don‚Äôt block clicks on the set */
	}

	/* 
	   Every star is visible by default (opacity:1) 
	   and uses the twinkle animation with different delays.
	*/
	.pr-border .stars-container [class^="star-"] {
	  position: absolute;
	  opacity: 1;
	  filter: drop-shadow(0 0 6px rgba(255, 215, 0, 0.8));
	  animation: twinkle 1.5s ease-in-out infinite;
	}

	.pr-border .stars-container .star-1 {
	  top: -10%;  left:  5%;  width: 9px;
	  animation-delay: 0.1s;
	}
	.pr-border .stars-container .star-2 {
	  top:  10%;  left: 90%;  width: 10px;
	  animation-delay: 0.3s;
	}
	.pr-border .stars-container .star-3 {
	  top:  40%;  left:  8%;  width: 9px;
	  animation-delay: 0.5s;
	}
	.pr-border .stars-container .star-4 {
	  top:  55%;  left: 95%;  width: 13px;
	  animation-delay: 0.7s;
	}
	.pr-border .stars-container .star-5 {
	  top:  70%;  left: 40%;  width: 9px;
	  animation-delay: 0.9s;
	}
	.pr-border .stars-container .star-6 {
	  top:  -15%;  left: 70%;  width: 11px;
	  animation-delay: 1.1s;
	}
	.pr-border .stars-container .star-7 {
	  top:  55%;  left:  -5%;  width: 9px;
	  animation-delay: 1.3s;
	}
	.pr-border .stars-container .star-8 {
	  top:  85%;  left: 78%;  width: 7px;
	  animation-delay: 1.5s;
	}
	.pr-border .stars-container .star-9 {
	  top:  5%;  left: 50%;  width: 11px;
	  animation-delay: 1.7s;
	}
	.pr-border .stars-container .star-10 {
	  top: 85%;   left: 25%;  width: 12px;
	  animation-delay: 1.9s;
	}
	/* Twinkle keyframes (flicker) */
	@keyframes twinkle {
	  0%, 100% {
		opacity: 1;
		transform: scale(1);
	  }
	  50% {
		opacity: 0.4;
		transform: scale(0.9);
	  }
	}
	/* Example star path fill color (white-ish gold) */
	.fil0 {
	  fill: #FFF9E6;
	}
	.pr-labels .pr-text.smaller-pr {
	  font-size: 0.6rem;  /* or 0.8rem, whichever you prefer */
	  display: block;      /* ensure each label is on its own line */
	  margin: 2px 0 0 0;   /* small spacing */
	}

	/* =========================================
	   15) HEVY WORKOUT STYLING
	   ========================================= */
	.hevy-workout {
	  margin-bottom: 2rem;
	  border-bottom: 1px solid #444;
	  padding-bottom: 1.5rem;
	}
	.hevy-workout:last-child {
	  margin-bottom: 0;
	  border-bottom: none;
	}
	.hevy-workout-title {
	  color: #FFDD77;
	  font-size: 1.2rem;
	  margin-bottom: 1.5rem;
	  font-weight: 700;
	}
	.hevy-exercise {
	  background: #393939;
	  border-radius: 8px;
	  padding: 1.2rem;
	  margin-bottom: 1rem;
	  box-shadow: 0 2px 8px rgba(0,0,0,0.2);
	  transition: all 0.2s;
	}
	.hevy-exercise:last-child {
	  margin-bottom: 0;
	}
	.hevy-exercise:hover {
	  transform: translateY(-2px);
	  background: #333;
	  box-shadow: 0 4px 8px rgba(0,0,0,0.4);
	}
	.hevy-exercise-title {
	  font-weight: bold;
	  color: #4DAAFF;
	  display: flex;
	  align-items: center;
	  font-size: 1.1rem;
	  margin-bottom: 1rem;
	  padding-bottom: 0.5rem;
	  border-bottom: 1px solid #444;
	  transition: color 0.2s;
	  cursor: pointer;
	}
	.hevy-exercise-title:hover {
	  color: #FFDD77;
	}
	.hevy-sets {
	  display: grid;
	  grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
	  gap: 0.75rem;
	  margin-bottom: 1rem;
	}
	.hevy-set {
	  background: #2D2D2D;
	  padding: 0.75rem;
	  border-radius: 6px;
	  text-align: center;
	  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
	  transition: all 0.2s;
	}
	.hevy-set:hover {
	  background: #333;
	  transform: translateY(-2px);
	  box-shadow: 0 4px 8px rgba(0,0,0,0.4);
	}
	.hevy-set-weight,
	.hevy-set-reps {
	  cursor: pointer;
	  transition: color 0.2s;
	}
	.hevy-total {
	  text-align: center;
	  color: #EAEAEA;
	  font-weight: bold;
	  font-size: 1.1rem;
	  margin-top: 1rem;
	  padding: 1rem;
	  background: #393939;
	  border-radius: 8px;
	  cursor: pointer;
	  transition: transform 0.2s;
	}
	.hevy-total:hover {
	  color: #FFDD77;
	  transform: translateY(-2px);
	}
	.hevy-orm {
	  margin-top: 0.25rem;
	  color: #FFFFFF;
	  font-weight: 400;
	  cursor: pointer;
	  transition: color 0.2s;
	  text-align: center;
	  font-size: 0.9rem;
	}
	.hevy-orm:hover {
	  color: #FFDD77;
	}
	.hevy-exercise-volume {
	  margin-top: 1.5rem;
	  color: #FFFFFF;
	  cursor: pointer;
	  transition: color 0.2s;
	  text-align: center;
	  font-size: 0.9rem;
	}
	.hevy-exercise-volume:hover {
	  color: #FFDD77;
	}

	/* =========================================
	   16) HEVY WORKOUT MODAL (#hevyModal)
	   ========================================= */
	#hevyOverlay .modal#hevyModal {
	  width: 500px;
	}
	#hevyModal.no-workout {
	  width: 350px;
	  text-align: center;
	  padding: 1rem;
	}
	.hevy-modal-content {
	  display: flex;
	  flex-direction: row;
	  gap: 1rem;
	  width: 100%;
	  align-items: flex-start;
	  justify-content: flex-start;
	  max-height: 450px;
	  overflow-y: hidden;
	}
	#hevyModalWorkoutDetails {
	  flex: 1;
	  overflow-y: auto;
	  padding-right: 4px;
	  max-height: 450px;
	}
	#hevyProgressChartContainer {
	  flex: 1;
	  max-width: 320px;
	  display: none;
	  overflow: hidden;
	}
	#hevyProgressChart {
	  width: 100%;
	  height: 300px;
	}
	#hevyModalWorkoutDetails p {
	  text-align: center;
	  color: #888;
	  font-style: italic;
	  padding: 2rem;
	}
	/* Centered date with line above it (like before) */
	#hevyModal .modal-subtitle {
	  text-align: center;
	  color: #888;
	  font-size: 0.9rem;
	  margin-top: 0.5rem;
	  margin-bottom: 0.5rem;
	  border-top: 1px solid #444;
	  padding-top: 0.5rem;
	}

	/* =========================================
	   17) EXERCISE VOLUME OVER TIME MODAL
		   (#exerciseVolumeOverlay)
	   ========================================= */
	#exerciseVolumeOverlay {
	  z-index: 1000;
	}
	#exerciseVolumeModal {
	  width: 500px;
	}
	#exerciseVolumeChart {
	  width: 100%;
	  height: 300px;
	}
	#exerciseVolumeModal .modal-date {
	  display: none;
	}
	.date-range-btn {
	  background: #444;
	  border: 1px solid #555;
	  color: #EAEAEA;
	  padding: 0.4rem 0.8rem;
	  border-radius: 4px;
	  cursor: pointer;
	  transition: all 0.2s;
	}
	.date-range-btn:hover {
	  background: #555;
	}
	.date-range-btn.active {
	  background: #4DAAFF;
	  border-color: #4DAAFF;
	  color: #FFF;
	}

	/* =========================================
	   18) WEIGHT & REP PROGRESSION MODAL
		   (#exerciseProgressOverlay)
	   ========================================= */
	#exerciseProgressOverlay {
	  z-index: 1001;
	}
	#exerciseProgressionModal {
	  width: 500px;
	}
	#exerciseWeightProgressionChart,
	#exerciseRepProgressionChart {
	  width: 100%;
	  height: 250px;
	}

	/* =========================================
	   19) VOLUME OVER TIME (DAY-LEVEL) MODAL
		   (#volumeOverlay)
	   ========================================= */
	#volumeOverlay {
	  z-index: 1003;
	}
	#volumeModal {
	  width: 600px;
	}
	#volumeChart {
	  width: 100%;
	  height: 400px;
	}
	#volumeModalDate {}

	/* =========================================
	   20) ORM PROGRESSION MODAL
		   (#ormProgressOverlay)
	   ========================================= */
	#ormProgressOverlay {
	  z-index: 1004;
	}
	#exerciseOrmProgressModal {
	  width: 500px;
	}
	#exerciseOrmProgressChart {
	  width: 100%;
	  height: 300px;
	}

	/* =========================================
	   21) CUSTOM ALERT OVERLAY & MODAL
	   ========================================= */
	#customAlertOverlay {
	  z-index: 10000 !important;
	}
	.custom-alert-modal {
	  background: #2D2D2D;
	  padding: 1.5rem;
	  border-radius: 6px;
	  width: 300px;
	  box-shadow: 0 2px 10px rgba(0,0,0,0.7);
	  display: flex;
	  flex-direction: column;
	  gap: 1rem;
	  text-align: center;
	  justify-content: center;
	  align-items: center;
	  transform: translateY(-20px);
	  animation: slideDownFade 0.3s forwards;
	}
	.custom-alert-modal p {
	  font-size: 1rem;
	  color: #EAEAEA;
	}
	#customAlertInput {
	  padding: 0.5rem;
	  border: 1px solid #555;
	  border-radius: 4px;
	  background: #444;
	  color: #EAEAEA;
	  font-size: 1rem;
	}
	.custom-alert-modal button {
	  padding: 0.5rem;
	  font-size: 0.9rem;
	  border: 1px solid #555;
	  border-radius: 4px;
	  background: #444;
	  color: #EAEAEA;
	  cursor: pointer;
	  transition: background-color 0.2s;
	  flex: 1;
	}
	.custom-alert-modal button:hover {
	  background: #555;
	}
	.custom-alert-modal .confirm-buttons {
	  display: flex;
	  gap: 1rem;
	}
	.default-button {
	  display: block;
	}
	#customDefaultButton button {
	  width: 100%;
	  margin-top: 0.5rem;
	}

	/* =========================================
	   22) LOADING OVERLAY & SPINNER
	   ========================================= */
	.loading-overlay {
	  display: none;
	  position: fixed;
	  top: 0;
	  left: 0;
	  width: 100%;
	  height: 100%;
	  background-color: rgba(0,0,0,0.6);
	  z-index: 1002;
	  justify-content: center;
	  align-items: center;
	}
	.loading-overlay.active {
	  display: flex;
	}
	.spinner {
	  border: 6px solid rgba(255, 255, 255, 0.3);
	  border-top: 6px solid #fff;
	  border-radius: 50%;
	  width: 50px;
	  height: 50px;
	  animation: spin 1s linear infinite;
	}
	@keyframes spin {
	  0% { transform: rotate(0deg);}
	  100% { transform: rotate(360deg);}
	}

	/* =========================================
	   23) EXERCISE SUMMARY MODAL
	   ========================================= */
	#exerciseSummaryOverlay .modal#exerciseSummaryModal {
	  width: 500px;
	}
	.exercise-summary-header {
	  margin-bottom: 1.5rem;
	  padding-bottom: 0.5rem;
	  border-bottom: 1px solid #555;
	  color: #4DAAFF;
	  font-size: 1.2rem;
	  display: flex;
	  align-items: center;
	  gap: 1rem;
	  padding: 0.5rem 0;
	  font-weight: bold;
	}
	.key-stats-grid {
	  display: grid;
	  grid-template-columns: 1fr 1fr;
	  gap: 1rem;
	  margin-bottom: 1.5rem;
	}
	.key-stat {
	  background: #393939;
	  padding: 1rem;
	  border-radius: 6px;
	  text-align: center;
	  transition: all 0.2s;
	  cursor: pointer;
	}
	.key-stat:hover {
	  transform: translateY(-2px);
	  background: #505050;
	}
	.key-stat-label {
	  font-size: 0.9rem;
	  color: #aaa;
	  margin-bottom: 0.5rem;
	}
	.key-stat-value {
	  font-size: 1.3rem;
	  font-weight: bold;
	  color: #FFDD77;
	}
	.exercise-stat-block {
	  background: #2D2D2D;
	  border-radius: 6px;
	  padding: 1rem;
	  margin-bottom: 1rem;
	}
	.exercise-stat-title {
	  font-size: 1.1rem;
	  font-weight: bold;
	  color: #fff;
	  margin-bottom: 0.5rem;
	}
	.rep-range-list {
	  background: #393939;
	  border-radius: 6px;
	  padding: 1rem;
	}
	.rep-range-row {
	  display: flex;
	  justify-content: space-between;
	  align-items: center;
	  padding: 0.5rem;
	  border-bottom: 1px solid #444;
	}
	.rep-range-row:last-child {
	  border-bottom: none;
	}
	.rep-range-row:hover {
	  background: #505050;
	}
	.rep-range {
	  font-size: 1.1rem;
	  font-weight: bold;
	  color: #FFD700;
	  margin-bottom: 0.25rem;
	}
	.rep-range-count {
	  color: #4DAAFF;
	  font-weight: bold;
	}
	.rep-range-weight {
	  color: #FFDD77;
	}
	#exerciseSummaryContent {
	  max-height: 70vh;
	  overflow-y: auto;
	  padding-right: 10px;
	}
	.exercise-frequency-container {
	  display: flex;
	  align-items: center;
	  gap: 1rem;
	}
	.compare-button {
	  background: #444;
	  border: 1px solid #555;
	  color: #EAEAEA;
	  padding: 0.4rem 0.8rem;
	  border-radius: 4px;
	  cursor: pointer;
	  transition: all 0.2s;
	  font-size: 0.9rem; /* Slightly smaller font */
	  order: 2; /* Ensures it stays on the right in flex container */
	}
	.compare-button:hover {
	  background: #555;
	  transform: translateY(-1px);
	  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
	}
	@keyframes glowPulse {
	  0% { text-shadow: 0 0 5px rgba(255, 215, 0, 0.3);}
	  50% { text-shadow: 0 0 15px rgba(255, 215, 0, 0.6);}
	  100% { text-shadow: 0 0 5px rgba(255, 215, 0, 0.3);}
	}
	.glowing-orm {
	  animation: glowPulse 2s infinite;
	}

	/* =========================================
	   24) EXERCISE FREQUENCY MODAL
	   ========================================= */
	#exerciseFrequencyModal {
	  width: 800px;
	}
	#exerciseFrequencyChart {
	  width: 100%;
	  height: 400px;
	}

	/* =========================================
	   25) TOTAL VOLUME DISTRIBUTION MODAL
	   ========================================= */
	#totalVolumeDistributionModal {
	  width: 800px;
	}
	#totalVolumeDistributionChart {
	  width: 100%;
	  height: 400px;
	}
	#totalVolumeDistributionModal {
	  background: linear-gradient(140deg, #2D2D2D, #333333 70%);
	  border: 1px solid #444;
	  border-radius: 10px;
	  position: relative;
	  padding: 1.5rem;
	  box-shadow: 0 4px 20px rgba(0,0,0,0.5);
	  color: #EAEAEA;
	}
	#totalVolumeDistributionModal .modal-row {
	  background: rgba(0, 0, 0, 0.2);
	  border-radius: 8px;
	  margin-bottom: 1rem;
	  padding: 1rem;
	}
	#grandTotalWeight {
	  font-size: 1rem;
	  text-align: center;
	  color: #FFDD77;
	  margin-bottom: 0.75rem;
	  font-weight: 600;
	}

	/* =========================================
	   26) CUSTOM SCROLLBARS FOR MODALS
	   ========================================= */
	#hevyModalWorkoutDetails::-webkit-scrollbar,
	#exerciseSummaryContent::-webkit-scrollbar {
	  width: 8px;
	}
	#hevyModalWorkoutDetails::-webkit-scrollbar-track,
	#exerciseSummaryContent::-webkit-scrollbar-track {
	  background: #2D2D2D;
	  border-radius: 4px;
	}
	#hevyModalWorkoutDetails::-webkit-scrollbar-thumb,
	#exerciseSummaryContent::-webkit-scrollbar-thumb {
	  background: #555;
	  border-radius: 4px;
	}
	#hevyModalWorkoutDetails::-webkit-scrollbar-thumb:hover,
	#exerciseSummaryContent::-webkit-scrollbar-thumb:hover {
	  background: #666;
	}
	#singleModal,
	#multiModal {
	  max-height: 90vh;
	  overflow-y: auto;
	}
	#singleModal::-webkit-scrollbar,
	#multiModal::-webkit-scrollbar {
	  width: 10px;
	  height: 10px;
	}
	#singleModal::-webkit-scrollbar-track,
	#multiModal::-webkit-scrollbar-track {
	  background: #2D2D2D;
	  border-radius: 4px;
	}
	#singleModal::-webkit-scrollbar-thumb,
	#multiModal::-webkit-scrollbar-thumb {
	  background: #555;
	  border-radius: 4px;
	  border: 2px solid #2D2D2D;
	}
	#singleModal::-webkit-scrollbar-thumb:hover,
	#multiModal::-webkit-scrollbar-thumb:hover {
	  background: #666;
	}
	
	/* =========================================
	   27) EXERCISE HISTORY MODAL
	   ========================================= */	
	#exerciseHistoryOverlay {
	  z-index: 1005;
	}
	#exerciseHistoryModal {
	  width: 500px; /* Match exercise summary width */
	  max-height: 80vh;
	}
	#exerciseHistoryContent {
	  max-height: 70vh;
	  overflow-y: auto;
	  padding-right: 10px;
	}
	/* Add scrollbar styling to match exercise summary */
	#exerciseHistoryContent::-webkit-scrollbar {
	  width: 8px;
	}
	#exerciseHistoryContent::-webkit-scrollbar-track {
	  background: #2D2D2D;
	  border-radius: 4px;
	}
	#exerciseHistoryContent::-webkit-scrollbar-thumb {
	  background: #555;
	  border-radius: 4px;
	}
	#exerciseHistoryContent::-webkit-scrollbar-thumb:hover {
	  background: #666;
	}
	.exercise-history-entry {
	  background: #393939;
	  border-radius: 8px;
	  padding: 1.2rem;
	  margin-bottom: 1rem;
	  box-shadow: 0 2px 8px rgba(0,0,0,0.2);
	}
	.exercise-history-date {
	  font-size: 0.95rem;
	  color: #4DAAFF;
	  margin-bottom: 1rem;
	  padding-bottom: 0.5rem;
	  border-bottom: 1px solid #444;
	}
	.exercise-history-sets {
	  display: grid;
	  grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
	  gap: 0.75rem;
	}
	#exerciseProgressOverlay {
		z-index: 1006; /* Was 1001 */
	}
	#volumeOverlay {
	  z-index: 1006; /* Was 1003 */
	}
	#ormProgressOverlay {
	  z-index: 1006; /* Was 1004 */
	}
	#exerciseHistoryOverlay {
	  z-index: 1005; /* Keep this lower than progress modals */
	}
	.exercise-history-header {
	  margin-bottom: 1rem;
	}
	.exercise-history-subheader {
	  color: #4DAAFF;
	  font-size: 1.2rem;
	  font-weight: 700;
	  margin-top: 0.5rem;
	  text-align: left;
	}
	
	/* =========================================
	  28) PRESET CREATION RELATED
	  ========================================= */	
	.preset-separator {
	 width: 100%;
	 height: 1px;
	 background: #444;
	 margin: 0.5rem 0;
	 grid-column: 1 / -1;
	}

	#singleColorSwatchesContainer,
	#multiColorSwatchesContainer {
	 display: grid;
	 grid-template-columns: repeat(auto-fit, minmax(32px, 1fr));
	 gap: 0.5rem;
	 margin-top: 0.5rem;
	}

	#singleColorSwatchesContainer .add-preset-emoji {
	 grid-column: 1 / -1;
	 text-align: center;
	 margin-top: 0rem;
	 padding: 0.3rem;
	 border: 1px solid #444;
	 border-radius: 4px;
	}

	#singleColorSwatchesContainer .add-preset-emoji:hover {
	 background-color: rgba(255, 255, 255, 0.4);
	}

	#presetCreationModal {
	 width: 420px;
	 max-height: 80vh;
	 overflow-y: auto;
	 display: flex;
	 flex-direction: column;
	 padding: 1rem;
	}

	#presetCreationModal h2 {
	 font-size: 1.1rem;
	 color: #EAEAEA;
	 margin-bottom: 0rem;
	 text-align: center;
	 padding-bottom: 0.4rem;
	 border-bottom: 1px solid #444;
	}

	#presetCreationModal .modal-row {
	 display: flex;
	 flex-direction: column;
	 gap: 0.25rem;
	 background: #393939;
	 padding: 0.5rem;
	 border-radius: 6px;
	 margin-bottom: 0.35rem;
	 transition: background-color 0.2s;
	}

	#presetCreationModal .modal-row:hover {
	 background: #424242;
	}

	#presetCreationModal .modal-row label {
	 font-size: 0.9rem;
	 display: flex;
	 align-items: center;
	 gap: 0.5rem;
	 justify-content: space-between;
	}

	#presetCreationModal input[type="text"],
	#presetCreationModal input[type="color"],
	#presetCreationModal select {
	 width: 100%;
	 padding: 0.35rem;
	 background: #2D2D2D;
	 border: 1px solid #555;
	 border-radius: 4px;
	 color: #EAEAEA;
	 font-size: 0.8rem;
	 transition: all 0.2s;
	 height: 28px;
	}

	#presetCreationModal input[type="color"] {
	 height: 40px;
	 padding: 0;
	 cursor: pointer;
	}

	#presetCreationModal input:hover,
	#presetCreationModal select:hover {
	 border-color: #666;
	}

	#presetCreationModal input:focus,
	#presetCreationModal select:focus {
	 border-color: #4DAAFF;
	 outline: none;
	 box-shadow: 0 0 0 2px rgba(77, 170, 255, 0.2);
	}

	#presetCreationModal .modal-buttons {
	 display: grid;
	 grid-template-columns: 1fr 1fr;
	 gap: 0.5rem;
	 padding-top: 0.5rem;
	 border-top: 1px solid #444;
	 margin-top: auto;
	}

	#presetCreationModal button {
	 padding: 0.5rem;
	 border: 1px solid #555;
	 border-radius: 4px;
	 cursor: pointer;
	 transition: all 0.2s;
	}

	#presetCreationModal #savePresetBtn {
	 background: #4DAAFF;
	 color: white;
	}

	#presetCreationModal #savePresetBtn:hover {
	 background: #82c3ff;
	}

	#presetCreationModal #cancelPresetBtn {
	 background: #444;
	 color: #EEE;
	}

	#presetCreationModal #cancelPresetBtn:hover {
	 background: #555;
	}

	.delete-preset-emoji:hover {
	 background: rgba(255, 0, 0, 0.2);
	 border-color: #ff4444;
	}

	.delete-preset-emoji[disabled] {
	 opacity: 0.5;
	 cursor: not-allowed;
	 pointer-events: none;
	}

  </style>
</head>

<body>
  <div class="main-wrapper">
    <!-- Month/Navigation/Buttons Bar -->
    <div class="month-bar">
      <div id="monthLabel" class="month-title">Month / Year</div>
      <div class="arrow-buttons">
        <div class="month-nav-buttons">
          <button class="arrow-button" onclick="prevMonth()" title="Previous Month">‚ñ≤</button>
          <button class="arrow-button" onclick="nextMonth()" title="Next Month">‚ñº</button>
        </div>
        <div class="data-buttons">
          <!-- Save Button -->
          <button class="arrow-button" id="saveDataBtn" title="Save Data">üíæ</button>
          <!-- Load Button -->
          <button class="arrow-button" id="loadDataBtn" title="Load Data">üìÅ</button>
          <!-- Import Hevy Button -->
          <button class="arrow-button" id="hevyImportBtn" title="Import Hevy">
            <img src="https://play-lh.googleusercontent.com/_HgX2ELOeBOIS6H-99ymHkNcEOlqoEncbt0x-D1MSgXx0ao8sTd7GRe16u-v70EgaAI"
                 alt="Hevy" style="width:18px;height:18px;">
          </button>
          <!-- Populate Calendar Button -->
          <button class="arrow-button" id="populateCalendarBtn" title="Populate Calendar" disabled style="opacity: 0.5; border: 2px solid #555;">
            üìÖ
          </button>
          <!-- Stats Button -->
          <button class="arrow-button" id="statsBtn" title="View Statistics">üìâ</button>
          <!-- Clear Calendar Button -->
          <button class="arrow-button" id="clearCalendarBtn" title="Clear Calendar">üóã</button>
          <!-- Help Button -->
          <button class="arrow-button" id="helpBtn" title="Help">‚ùî</button>
        </div>
      </div>
      <input type="file" id="importFileInput" accept=".json" style="display: none;">
    </div>
    <!-- Calendar -->
    <div class="calendar-container" id="calendar"></div>
  </div>

  <!-- Single-Cell Edit Overlay -->
  <div class="overlay" id="singleOverlay">
    <div class="modal" id="singleModal">
        <h2>Edit Cell</h2>
		<div class="modal-date" id="singleModalDate">2 January</div>
      <!-- SHIFT Presets -->
      <div class="modal-row">
        <label>
          <span id="singleShiftMainLabel">Shift Presets:</span>
          <span class="shift-label-text" id="singleShiftLabelText">(none)</span>
          <span class="reset-emoji" data-field="shiftClass" title="Reset Shift">‚ü≥</span>
		  
        </label>
        <div class="color-swatches" id="singleColorSwatchesContainer"></div>
      </div>
      <!-- GYM -->
      <div class="modal-row">
        <label>Workout Type
          <span class="reset-emoji" data-field="gym" title="Reset Workout Type">‚ü≥</span>
        </label>
        <select id="singleWorkoutTypeSelect">
          <option value="Push">Push</option>
          <option value="Pull">Pull</option>
          <option value="Rest">Rest</option>
          <option value="Upper">Upper</option>
          <option value="Lower">Lower</option>
          <option value="Chest">Chest</option>
          <option value="Arms">Arms</option>
          <option value="Shoulders">Shoulders</option>
          <option value="Back">Back</option>
          <option value="Legs">Legs</option>
          <option value="Cardio">Cardio</option>
          <option value="None">None</option>
        </select>
      </div>
      <!-- Gym Time -->
      <div class="modal-row">
        <label>Gym Time (HHMM)
          <span class="reset-emoji" data-field="gymTime" title="Reset Gym Time">‚ü≥</span>
        </label>
        <input type="text" id="singleGymTimeInput" placeholder="e.g. 2100">
      </div>
      <!-- Work Time ‚Äì Dropdown -->
      <div class="modal-row">
		  <label>Work Time (HHMM)
			<span class="reset-emoji" data-field="workTime" title="Reset Work Time">‚ü≥</span>
		  </label>
		  <input type="text" id="singleWorkTimeSelect" placeholder="e.g. 2100">
		</div>
      <!-- Weight -->
      <div class="modal-row">
        <label>Weight (kg)
          <span class="reset-emoji" data-field="weight" title="Reset Weight">‚ü≥</span>
        </label>
        <input type="text" id="singleWeightInput" placeholder="e.g. 88.0">
      </div>
      <!-- Alert Type -->
      <div class="modal-row">
        <label>Alert Type
          <span class="reset-emoji" data-field="alertType" title="Reset Alert Type">‚ü≥</span>
        </label>
        <select id="singleAlertTypeSelect">
          <option value="None">‚ö™ None</option>
          <option value="Generic">üü¢ Generic</option>
          <option value="Birthday">üü£ Birthday</option>
          <option value="Work">üîµ Work</option>
          <option value="PublicHoliday">üü° Public Holiday</option>
		  <option value="Deadline">üî¥ Deadline</option>
		  <option value="School">üü† School</option>
        </select>
      </div>
      <!-- Alert Text -->
      <div class="modal-row">
        <label>Alert Text
          <span class="reset-emoji" data-field="alertText" title="Reset Alert Text">‚ü≥</span>
        </label>
        <input type="text" id="singleAlertTextInput" placeholder="e.g. My birthday!">
      </div>

      <div class="modal-buttons">
        <button id="singleSaveBtn" title="Save Changes">Save</button>
        <button id="singleRevertBtn" style="font-size:1.5rem;" title="Revert Changes">
			<span class="rotate-emoji">‚ü≥</span>
		</button>
        <button id="singleCancelBtn" title="Cancel">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Multi-Cell Edit Overlay -->
  <div class="overlay" id="multiOverlay">
    <div class="modal" id="multiModal">
      <h2>Edit Cells</h2>
      <!-- Key to Change -->
      <div class="modal-row">
        <label>Select Key to Change</label>
        <select id="multiKeySelect">
          <option value="">(select key)</option>
          <option value="shiftClass">Shift Presets</option>
          <option value="gym">Workout Type</option>
          <option value="gymTime">Gym Time</option>
          <option value="workTime">Work Time</option>
          <option value="weight">Weight</option>
          <option value="alertType">Alert Type</option>
          <option value="alertText">Alert Text</option>
        </select>
      </div>
      <!-- SHIFT Presets Swatches Row -->
      <div class="modal-row" id="multiShiftSwatchesRow" style="display:none;">
        <label>
          Choose Shift Preset:
          <span class="shift-label-text" id="multiShiftLabelText">(none)</span>
        </label>
        <div class="color-swatches" id="multiColorSwatchesContainer"></div>
      </div>
      <!-- Alert Type Row -->
      <div class="modal-row" id="multiAlertTypeRow" style="display:none;">
        <label>Alert Type</label>
        <select id="multiAlertTypeSelect">
          <option value="None">‚ö™ None</option>
          <option value="Generic">üü¢ Generic</option>
          <option value="Birthday">üü£ Birthday</option>
          <option value="Work">üîµ Work</option>
          <option value="PublicHoliday">üü° Public Holiday</option>
		  <option value="Deadline">üî¥ Deadline</option>
		  <option value="School">üü† School</option>
        </select>
      </div>
      <!-- Work Time Row -->
      <div class="modal-row" id="multiWorkTimeRow" style="display: none;">
        <label>Work Time (HHMM)</label>
        <input type="text" id="multiWorkTimeInput" placeholder="e.g. 0900">
      </div>
      <!-- Value Row for other keys -->
      <div class="modal-row" id="multiValueRow" style="display:none;">
        <label>New Value</label>
        <input type="text" id="multiValueInput" placeholder="">
      </div>
      <!-- Value Row for Workout Type -->
      <div class="modal-row" id="multiWorkoutTypeRow" style="display:none;">
        <label>New Workout Type</label>
        <select id="multiWorkoutTypeSelect">
          <option value="Push">Push</option>
          <option value="Pull">Pull</option>
          <option value="Rest">Rest</option>
          <option value="Upper">Upper</option>
          <option value="Lower">Lower</option>
          <option value="Chest">Chest</option>
          <option value="Arms">Arms</option>
          <option value="Shoulders">Shoulders</option>
          <option value="Back">Back</option>
          <option value="Legs">Legs</option>
          <option value="Cardio">Cardio</option>
          <option value="None">None</option>
        </select>
      </div>
      <div class="modal-buttons">
        <button id="multiSaveBtn" title="Save Changes">Save</button>
        <button id="multiRevertBtn" style="font-size:1.5rem;" title="Revert Changes">
			<span class="rotate-emoji">‚ü≥</span>
		</button>
        <button id="multiCancelBtn" title="Cancel">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Stats Overlay -->
  <div class="overlay" id="statsOverlay">
    <div class="modal" id="statsModal">
      <h2>Statistics</h2>
      <div class="stats-summary">
        <div class="stat-item">
          Sessions Completed: <span class="counter-value" id="sessionCounter">0</span>
        </div>
        <div class="stat-item">
          Days Trained: <span class="counter-value" id="daysTrainedCounter">0</span>
        </div>
        <div class="stat-item">
          Percentage Trained: <span class="counter-value" id="percentageCounter">0.00%</span>
        </div>
      </div>
      <div class="modal-row" style="height:300px;">
        <canvas id="weightChart"></canvas>
      </div>
      <div class="modal-buttons">
        <button id="statsCloseBtn" title="Close Statistics">Close</button>
      </div>
    </div>
  </div>

  <!-- Hevy Workout Summary Overlay -->
  <div class="overlay" id="hevyOverlay">
    <div class="modal" id="hevyModal">
      <h2>Hevy Workout Summary</h2>
      <div class="hevy-modal-content">
        <div id="hevyModalWorkoutDetails"></div>
        <!-- Optional chart container if you want to show a set-based progression in the same modal -->
        <div id="hevyProgressChartContainer">
          <canvas id="hevyProgressChart"></canvas>
        </div>
      </div>
      <div class="modal-buttons">
        <button id="hevyCloseBtn" title="Close Hevy Summary">Close</button>
      </div>
    </div>
  </div>

  <!-- Volume Over Time Overlay -->
  <div class="overlay" id="volumeOverlay">
    <div class="modal" id="volumeModal">
      <div class="modal-date" id="volumeModalDate"></div>
      <h2>Volume Over Time</h2>
	  <div class="modal-row" style="margin-bottom: 1rem;">
      <div style="display: flex; gap: 0.5rem; justify-content: center;">
        <button class="date-range-btn active" data-range="year">Year</button>
        <button class="date-range-btn" data-range="month">Month</button>
        <button class="date-range-btn" data-range="week">Week</button>
        <button class="date-range-btn" data-range="all">All Time</button>
      </div>
    </div>
      <div class="modal-row" style="height:300px;">
        <canvas id="volumeChart"></canvas>
      </div>
      <div class="modal-buttons">
        <button id="volumeCloseBtn" title="Close Volume Chart">Close</button>
      </div>
    </div>
  </div>

  <!-- Exercise Volume Over Time Overlay -->
  <div class="overlay" id="exerciseVolumeOverlay">
    <div class="modal" id="exerciseVolumeModal">
      <h2>Exercise Volume Over Time</h2>
	  <div class="modal-row" style="margin-bottom: 1rem;">
	      <div style="display: flex; gap: 0.5rem; justify-content: center;">
			  <button class="date-range-btn active" data-range="year">Year</button>
			  <button class="date-range-btn" data-range="month">Month</button>
			  <button class="date-range-btn" data-range="week">Week</button>
			  <button class="date-range-btn" data-range="all">All Time</button>
		  </div>
	  </div>
      <div class="modal-row" style="height:300px;">
        <canvas id="exerciseVolumeChart"></canvas>
      </div>
      <div class="modal-buttons">
        <button id="exerciseVolumeCloseBtn" title="Close Exercise Volume Chart">Close</button>
      </div>
    </div>
  </div>

  <!-- Combined Weight & Rep Progression Modal -->
  <div class="overlay" id="exerciseProgressOverlay">
    <div class="modal" id="exerciseProgressionModal">
      <div class="modal-date" id="exerciseProgressionModalDate"></div>
      <h2>Exercise: Weight & Rep Progression</h2>
	  
	  <!-- Date Range Controls -->
      <div class="modal-row" style="margin-bottom: 1rem;">
        <div style="display: flex; gap: 0.5rem; justify-content: center;">
          <button class="date-range-btn active" data-range="year">Year</button>
          <button class="date-range-btn" data-range="month">Month</button>
          <button class="date-range-btn" data-range="week">Week</button>
          <button class="date-range-btn" data-range="all">All Time</button>
        </div>
      </div>

      <!-- First row: Weight Progression Chart -->
      <div class="modal-row" style="height:320px;">
        <canvas id="exerciseWeightProgressionChart"></canvas>
      </div>

      <!-- Second row: Rep Progression Chart -->
      <div class="modal-row" style="height:320px;">
        <canvas id="exerciseRepProgressionChart"></canvas>
      </div>

      <div class="modal-buttons">
        <button id="exerciseProgressCloseBtn" title="Close Progression">Close</button>
      </div>
    </div>
  </div>

  <!-- ORM Progress Modal -->
  <div class="overlay" id="ormProgressOverlay">
    <div class="modal" id="exerciseOrmProgressModal">
      <h2>Exercise: ORM Progression</h2>
	  <!-- Date Range Controls -->
      <div class="modal-row" style="margin-bottom: 1rem;">
        <div style="display: flex; gap: 0.5rem; justify-content: center;">
          <button class="date-range-btn active" data-range="year">Year</button>
          <button class="date-range-btn" data-range="month">Month</button>
          <button class="date-range-btn" data-range="week">Week</button>
          <button class="date-range-btn" data-range="all">All Time</button>
        </div>
      </div>
      <div class="modal-row" style="height:300px;">
        <canvas id="exerciseOrmProgressChart"></canvas>
      </div>
      <div class="modal-buttons">
        <button id="ormProgressCloseBtn" title="Close ORM Progression">Close</button>
      </div>
    </div>
  </div>

  <!-- Custom Alert Overlay -->
  <div class="overlay" id="customAlertOverlay">
    <div class="custom-alert-modal" id="customAlertModal">
      <p id="customAlertMessage"></p>
      <input type="text" id="customAlertInput" style="display: none;" placeholder="">
      <div class="confirm-buttons" id="customConfirmButtons" style="display: none;"></div>
      <div class="default-button" id="customDefaultButton" style="display: block;">
        <button onclick="closeCustomAlert()" title="OK">OK</button>
      </div>
    </div>
  </div>
  
  <div class="overlay" id="exerciseSummaryOverlay">
  <div class="modal" id="exerciseSummaryModal">
    <h2>Exercise Summary</h2>
    <div id="exerciseSummaryContent">
      <!-- Content will be populated dynamically -->
    </div>
    <div class="modal-buttons">
      <button id="exerciseSummaryCloseBtn" title="Close Exercise Summary">Close</button>
    </div>
  </div>
</div>

  <!-- Loading Overlay -->
  <div class="overlay loading-overlay" id="loadingOverlay">
    <div class="custom-alert-modal">
      <p>Loading...</p>
      <div class="spinner"></div>
    </div>
  </div>
  
  <!-- Exercise Frequency Comparison Modal -->
	<div class="overlay" id="exerciseFrequencyOverlay">
	  <div class="modal" id="exerciseFrequencyModal">
		<h2>Exercise Frequency Comparison</h2>
		<div class="modal-row" style="height:400px;">
		  <canvas id="exerciseFrequencyChart"></canvas>
		</div>
		<div class="modal-buttons">
		  <button id="exerciseFrequencyCloseBtn" title="Close Frequency Comparison">Close</button>
		</div>
	  </div>
	</div>

	<!-- Total Volume Distribution Modal -->
	<div class="overlay" id="totalVolumeDistributionOverlay">
	  <div class="modal" id="totalVolumeDistributionModal">
		<h2>Total Volume Distribution</h2>
		<div class="modal-row" style="height:400px;">
		  <canvas id="totalVolumeDistributionChart"></canvas>
		</div>
		<div class="modal-buttons">
		  <button id="totalVolumeDistributionCloseBtn" title="Close Volume Distribution">Close</button>
		</div>
	  </div>
	</div>
	
	<div class="overlay" id="exerciseHistoryOverlay">
	  <div class="modal" id="exerciseHistoryModal">
		<h2>Exercise History</h2>
		<div class="exercise-history-subheader" id="exerciseHistorySubheader"></div>
		<div id="exerciseHistoryContent" class="exercise-summary-scroll">
		  <!-- Content will be populated dynamically -->
		</div>
		<div class="modal-buttons">
		  <button id="exerciseHistoryCloseBtn" title="Close Exercise History">Close</button>
		</div>
	  </div>
	</div>
		
	<!-- Custom Preset Creation Modal -->
	<div class="overlay" id="presetCreationOverlay">
	  <div class="modal" id="presetCreationModal">
		<h2>Create Custom Preset</h2>
		
		<div class="modal-row">
		  <label>Preset Name</label>
		  <input type="text" id="presetNameInput" placeholder="Morning Routine" required>
		</div>
		
		<div class="modal-row">
		  <label>Preset Color</label>
		  <input type="color" id="presetColorInput" value="#4daaff">
		</div>

		<div class="modal-row">
		  <label>Workout Type</label>
		  <select id="presetWorkoutSelect">
			<option value="Push">Push</option>
			<option value="Pull">Pull</option>
			<option value="Rest">Rest</option>
			<option value="Upper">Upper</option>
			<option value="Lower">Lower</option>
			<option value="Chest">Chest</option>
			<option value="Arms">Arms</option>
			<option value="Shoulders">Shoulders</option>
			<option value="Back">Back</option>
			<option value="Legs">Legs</option>
			<option value="Cardio">Cardio</option>
			<option value="None">None</option>
		  </select>
		</div>

		<div class="modal-row">
		  <label>Gym Time (HHMM)</label>
		  <input type="text" id="presetGymTime" placeholder="0900">
		</div>

		<div class="modal-row">
		  <label>Work Time (HHMM)</label>
		  <input type="text" id="presetWorkTime" placeholder="0900">
		</div>

		<div class="modal-row">
		  <label>Alert Type</label>
		  <select id="presetAlertType">
			<option value="None">None</option>
			<option value="Generic">Generic</option>
			<option value="Birthday">Birthday</option>
			<option value="Work">Work</option>
			<option value="PublicHoliday">PublicHoliday</option>
			<option value="Deadline">Deadline</option>
			<option value="School">School</option>
		  </select>
		</div>

		<div class="modal-row">
		  <label>Alert Text</label>
		  <input type="text" id="presetAlertText" placeholder="Special event">
		</div>

		<div class="modal-buttons">
		  <button id="savePresetBtn">Save Preset</button>
		  <button id="cancelPresetBtn">Cancel</button>
		</div>
	  </div>
	</div>
  <script>
    /*
      =======================================
      =      1) Data, Constants, Config     =
      =======================================
    */

    const START_YEAR = 2020;
    const END_YEAR = 2030;
	const LS_PRESETS_KEY = "customPresets";
	
	let customPresets = JSON.parse(localStorage.getItem(LS_PRESETS_KEY)) || [];
	
	const baseColorOptions = [
	  { className: "off-bg", label: "Off (Weekly Leave)" },
	  { className: "al-bg", label: "Annual Leave" },
	  { 
		className: "shift-0000",
		label: "00:00",
		data: {
		  workTime: "0000",
		  color: "#926E8E"
		}
	  },
	  { 
		className: "shift-0100",
		label: "01:00",
		data: {
		  workTime: "0100",
		  color: "#A47887"
		}
	  },
	  { 
		className: "shift-0200",
		label: "02:00",
		data: {
		  workTime: "0200",
		  color: "#B78381"
		}
	  },
	  { 
		className: "shift-0300",
		label: "03:00",
		data: {
		  workTime: "0300",
		  color: "#C8917A"
		}
	  },
	  { 
		className: "shift-0400",
		label: "04:00",
		data: {
		  workTime: "0400",
		  color: "#DB9C73"
		}
	  },
	  { 
		className: "shift-0500",
		label: "05:00",
		data: {
		  workTime: "0500",
		  color: "#EDA76D"
		}
	  },
	  { 
		className: "shift-0600",
		label: "06:00",
		data: {
		  workTime: "0600",
		  color: "#FFAD66"
		}
	  },
	  { 
		className: "shift-0700",
		label: "07:00",
		data: {
		  workTime: "0700",
		  color: "#EEAE74"
		}
	  },
	  { 
		className: "shift-0800",
		label: "08:00",
		data: {
		  workTime: "0800",
		  color: "#DEAF83"
		}
	  },
	  { 
		className: "shift-0900",
		label: "09:00",
		data: {
		  workTime: "0900",
		  color: "#D0A77D"
		}
	  },
	  { 
		className: "shift-1000",
		label: "10:00",
		data: {
		  workTime: "1000",
		  color: "#BDB2A0"
		}
	  },
	  { 
		className: "shift-1100",
		label: "11:00",
		data: {
		  workTime: "1100",
		  color: "#ACB3AE"
		}
	  },
	  { 
		className: "shift-1200",
		label: "12:00",
		data: {
		  workTime: "1200",
		  color: "#9CB4BC"
		}
	  },
	  { 
		className: "shift-1300",
		label: "13:00",
		data: {
		  workTime: "1300",
		  color: "#8CB4CA"
		}
	  },
	  { 
		className: "shift-1400",
		label: "14:00",
		data: {
		  workTime: "1400",
		  color: "#7AB6D9"
		}
	  },
	  { 
		className: "shift-1500",
		label: "15:00",
		data: {
		  workTime: "1500",
		  color: "#76A7D1"
		}
	  },
	  { 
		className: "shift-1600",
		label: "16:00",
		data: {
		  workTime: "1600",
		  color: "#7198C9"
		}
	  },
	  { 
		className: "shift-1700",
		label: "17:00",
		data: {
		  workTime: "1700",
		  color: "#6D8BC2"
		}
	  },
	  { 
		className: "shift-1800",
		label: "18:00",
		data: {
		  workTime: "1800",
		  color: "#697DBA"
		}
	  },
	  { 
		className: "shift-1900",
		label: "19:00",
		data: {
		  workTime: "1900",
		  color: "#627AA3"
		}
	  },
	  { 
		className: "shift-2000",
		label: "20:00",
		data: {
		  workTime: "2000",
		  color: "#6060AA"
		}
	  },
	  { 
		className: "shift-2100",
		label: "21:00",
		data: {
		  workTime: "2100",
		  color: "#5C4EA2"
		}
	  },
	  { 
		className: "shift-2200",
		label: "22:00",
		data: {
		  workTime: "2200",
		  color: "#6E599B"
		}
	  },
	  { 
		className: "shift-2300",
		label: "23:00",
		data: {
		  workTime: "2300",
		  color: "#806395"
		}
	  }
	];
	
	let colorOptions = [
      { className: "off-bg",       label: "Off (Weekly Leave)" },
      { className: "al-bg",        label: "Annual Leave" }
    ];
	colorOptions = [...baseColorOptions, ...customPresets];

    const monthNames = [
      "January","February","March","April","May","June",
      "July","August","September","October","November","December"
    ];
    const dayNames = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];

    const LS_CALENDAR_DATA_KEY = "multiYearCalendarData";
    const LS_DEFAULT_CYCLE_KEY = "defaultCycleMultiYear";

    const MS_IN_DAY = 86400000;

    // Load or initialize global calendar data
    let calendarData = JSON.parse(localStorage.getItem(LS_CALENDAR_DATA_KEY)) || {};

    // If no default cycle stored yet
    let defaultCycleData = JSON.parse(localStorage.getItem(LS_DEFAULT_CYCLE_KEY)) || {
      pattern: [],
      startDate: null
    };

    // We default to the current month/year (clamped to 2020‚Äì2030)
    const now = new Date();
    let currentYear = now.getFullYear();
    if (currentYear < START_YEAR) currentYear = START_YEAR;
    if (currentYear > END_YEAR)   currentYear = END_YEAR;
    let currentMonth = now.getMonth(); // 0-11

    const selectedDates = new Set();
    let isDragging = false;

    // For charts
    let weightChart = null;
    let hevyProgressChart = null;
    let exerciseWeightProgressionChart = null;
    let exerciseRepProgressionChart = null;
    let volumeChart = null;
	let exerciseFrequencyChart = null;
    let exerciseVolumeChart = null;
    let exerciseOrmProgressChart = null;
	let currentVolumeDateKey = null;
	let totalVolumeDistributionChart = null;
	
	// Preset creation related
	let presetCreationModal;
	let savePresetBtn;
	let cancelPresetBtn;

    /*
      =======================================
      =       2) Helper Functions           =
      =======================================
    */
	
	function initializePresetCreation() {
	    presetCreationModal = document.getElementById('presetCreationOverlay');
	    savePresetBtn = document.getElementById('savePresetBtn');
	    cancelPresetBtn = document.getElementById('cancelPresetBtn');

	    // Save preset handler
		savePresetBtn.addEventListener("click", function() {
		  const presetName = document.getElementById("presetNameInput").value.trim();
		  const presetColor = document.getElementById("presetColorInput").value;
		  const gymTime = document.getElementById("presetGymTime").value.trim();
		  const workTime = document.getElementById("presetWorkTime").value.trim();

		  // Validation
		  if (!presetName) {
			showCustomAlert("Preset name is required!");
			document.getElementById("presetNameInput").focus();
			return;
		  }
		  
		  if (gymTime && !validateTimeHHMM(gymTime)) {
			showCustomAlert("Invalid Gym Time format! Use HHMM (e.g. 0900)");
			return;
		  }

		  if (workTime && !validateTimeHHMM(workTime)) {
			showCustomAlert("Invalid Work Time format! Use HHMM (e.g. 0900)");
			return;
		  }

		  // Create new preset object
		  const newPreset = {
			className: `custom-${presetName.toLowerCase().replace(/[^a-z0-9]/gi, '-')}`,
			label: presetName,
			custom: true,
			data: {
			  color: presetColor,
			  gym: document.getElementById('presetWorkoutSelect').value,
			  gymTime: gymTime,
			  workTime: workTime,
			  alert: {
				type: document.getElementById('presetAlertType').value,
				text: document.getElementById('presetAlertText').value.trim()
			  }
			}
		  };

		  // Add to storage
		  customPresets.push(newPreset);
		  localStorage.setItem(LS_PRESETS_KEY, JSON.stringify(customPresets));

		  // Update UI
		  colorOptions = [...baseColorOptions, ...customPresets];
		  buildColorSwatches();

		  // Add dynamic CSS
		  const style = document.createElement('style');
		  style.textContent = `.${newPreset.className} { background-color: ${newPreset.data.color}; }`;
		  document.head.appendChild(style);

		  // Close modal
		  presetCreationModal.classList.remove('active');
		  showCustomAlert(`"${presetName}" preset created successfully!`);
		});

		  // Cancel handler
		  cancelPresetBtn.addEventListener('click', function() {
			presetCreationModal.classList.remove('active');
		  });
	}

	// Initialize when DOM loads
	document.addEventListener('DOMContentLoaded', initializePresetCreation);
	
	function addNewPreset() {
	  // Reset form
	  document.getElementById('presetNameInput').value = '';
	  document.getElementById('presetColorInput').value = '#4daaff';
	  document.getElementById('presetWorkoutSelect').value = 'None';
	  document.getElementById('presetGymTime').value = '';
	  document.getElementById('presetWorkTime').value = '';
	  document.getElementById('presetAlertType').value = 'None';
	  document.getElementById('presetAlertText').value = '';

	  
	  // Show modal
	  presetCreationModal.classList.add('active');
	}
	
	// Useful for Exercise History Modal
	function getAllSessionsForExercise(exerciseName) {
	  const sessions = [];
	  
	  Object.keys(calendarData).forEach(dateKey => {
		const dayObj = calendarData[dateKey];
		if (dayObj.hevyWorkouts) {
		  dayObj.hevyWorkouts.forEach(workout => {
			workout.exercises.forEach(exercise => {
			  if (exercise.title === exerciseName) {
				sessions.push({
				  date: parseDateKey(dateKey),
				  dateKey,
				  workout,
				  exercise: exercise
				});
			  }
			});
		  });
		}
	  });
	  
	  // Sort by date descending (newest first)
	  return sessions.sort((a, b) => b.date - a.date);
	}
	
	// Assists with fixing 'null' weight values for bodyweight exercises like pull ups
	const bodyweightExercises = new Set();
	function findNearestWeight(dateKey) {
	  const targetDate = parseDateKey(dateKey);
	  
	  const datesWithWeights = Object.keys(calendarData)
		.filter(key => calendarData[key].weight)
		.map(key => ({
		  key,
		  date: parseDateKey(key),
		  weight: calendarData[key].weight
		}))
		.sort((a, b) => a.date - b.date);

	  if (datesWithWeights.length === 0) return 0;

	  let nearestDate = datesWithWeights[0];
	  let minDiff = Math.abs(targetDate - nearestDate.date);

	  for (const dateObj of datesWithWeights) {
		const diff = Math.abs(targetDate - dateObj.date);
		if (diff < minDiff) {
		  minDiff = diff;
		  nearestDate = dateObj;
		}
	  }
	  return nearestDate.weight;
	}

	function fixNullWeights() {
	  bodyweightExercises.clear();
	  Object.keys(calendarData).forEach(dateKey => {
		const dayData = calendarData[dateKey];
		if (!dayData.hevyWorkouts) return;

		dayData.hevyWorkouts.forEach(workout => {
		  workout.exercises.forEach(exercise => {
			exercise.sets.forEach((set, setIndex) => {
			  if (set.weight_kg === null || set.weight_kg === undefined) {
				// Store reference to this bodyweight exercise
				bodyweightExercises.add({
				  dateKey,
				  workoutId: workout.id,
				  exerciseIndex: workout.exercises.indexOf(exercise),
				  setIndex
				});
				
				// Set initial weight
				set.weight_kg = findNearestWeight(dateKey);
			  }
			});
		  });
		});
		calendarData[dateKey] = dayData;
	  });
	  localStorage.setItem(LS_CALENDAR_DATA_KEY, JSON.stringify(calendarData));
	}

	// Hook into weight updates
	const originalSetDayData = window.setDayData;
	window.setDayData = function(dateKey, newData) {
	  // Call original function
	  originalSetDayData(dateKey, newData);
	  
	  // If weight was updated, update bodyweight exercises
	  if (newData.weight !== undefined) {
		updateBodyweightExercises();
	  }
	};

	function updateBodyweightExercises() {
	  bodyweightExercises.forEach(ref => {
		const dayData = calendarData[ref.dateKey];
		if (!dayData?.hevyWorkouts) return;
		
		const workout = dayData.hevyWorkouts.find(w => w.id === ref.workoutId);
		if (!workout) return;
		
		const exercise = workout.exercises[ref.exerciseIndex];
		if (!exercise) return;
		
		const set = exercise.sets[ref.setIndex];
		if (!set) return;
		
		// Update to nearest weight
		set.weight_kg = findNearestWeight(ref.dateKey);
	  });
	  
	  localStorage.setItem(LS_CALENDAR_DATA_KEY, JSON.stringify(calendarData));
	  renderCalendar(currentYear, currentMonth);
	}
	
	// 1) Preload images
	const monthImagesToPreload = monthNames.map((month) => {
		return month.toLowerCase() + '.jpg';
	});
	monthImagesToPreload.forEach((imgSrc) => {
		const img = new Image();
		img.src = imgSrc;
	});
	
	function updateBackgroundForMonth(month) {
	  // monthNames is already defined in your code.
	  // Convert the month name to lowercase and append the extension.
	  const imageFile = monthNames[month].toLowerCase() + '.jpg';
	  document.body.style.backgroundImage = `url('${imageFile}')`;
	  document.body.style.backgroundSize = 'cover';
	  document.body.style.backgroundPosition = 'center center';
	}
	
	function hasAnyPR(dateKey) {
	  // Grab the day data
	  const dayObj = getDayData(dateKey);
	  if (!dayObj.hevyWorkouts || dayObj.hevyWorkouts.length === 0) return false;

	  // For each workout‚Äôs exercises, check for:
	  //  - Set-based PR (exceeding previous best weight/reps)
	  //  - Volume PR
	  //  - 1RM PR
	  for (const workout of dayObj.hevyWorkouts) {
		for (const ex of workout.exercises) {
		  // 1) Compare with prior best (weight + reps)
		  const { bestWeight, bestRepsForWeight } = getBestWeightAndRepsBeforeDate(ex.title, dateKey);

		  // 2) Calculate this day‚Äôs total volume + highest 1RM for this exercise
		  let dayVolume = 0;
		  let highestOrmForThisEx = 0;
		  ex.sets.forEach(set => {
			const vol = set.weight_kg * set.reps;
			dayVolume += vol;
			const oneRepMax = computeOrm(set.weight_kg, set.reps);
			if (oneRepMax > highestOrmForThisEx) highestOrmForThisEx = oneRepMax;
		  });

		  // 3) Compare volume / 1RM with prior best
		  const prevMaxVolume = getMaxVolumeForExerciseBeforeDate(ex.title, dateKey);
		  const prevMaxOrm    = getMaxOrmForExerciseBeforeDate(ex.title, dateKey);
		  if (dayVolume > prevMaxVolume) return true; // Volume PR
		  if (highestOrmForThisEx > prevMaxOrm) return true; // 1RM PR

		  // 4) Check if any set is a ‚Äúweight PR‚Äù or ‚Äúweight+reps PR‚Äù
		  for (const set of ex.sets) {
			// If this set's weight is above the old best weight,
			// or same weight but more reps, it's a new PR
			if (
			  set.weight_kg > bestWeight ||
			  (set.weight_kg === bestWeight && set.reps > bestRepsForWeight)
			) {
			  return true;
			}
		  }
		}
	  }
	  // If no PR found in all workouts, return false
	  return false;
	}

	function hasAnyPR(dateKey) {
	  // Grab the day data
	  const dayObj = getDayData(dateKey);
	  if (!dayObj.hevyWorkouts || dayObj.hevyWorkouts.length === 0) return false;

	  // For each workout‚Äôs exercises, check for:
	  //  - Set-based PR (exceeding previous best weight/reps)
	  //  - Volume PR
	  //  - ORM PR
	  for (const workout of dayObj.hevyWorkouts) {
		for (const ex of workout.exercises) {
		  // 1) Compare with prior best (weight)
		  const { bestWeight, bestRepsForWeight } = getBestWeightAndRepsBeforeDate(ex.title, dateKey);

		  // 2) Calculate day‚Äôs total volume + highest ORM for this exercise
		  let dayVolume = 0;
		  let highestOrmThisEx = 0;
		  ex.sets.forEach(set => {
			const vol = set.weight_kg * set.reps;
			dayVolume += vol;
			const oneRepMax = computeOrm(set.weight_kg, set.reps);
			if (oneRepMax > highestOrmThisEx) {
			  highestOrmThisEx = oneRepMax;
			}
		  });

		  // 3) Compare volume, ORM with prior best
		  const prevMaxVolume = getMaxVolumeForExerciseBeforeDate(ex.title, dateKey);
		  const prevMaxOrm    = getMaxOrmForExerciseBeforeDate(ex.title, dateKey);
		  if (dayVolume > prevMaxVolume) return true;          // Volume PR
		  if (highestOrmThisEx > prevMaxOrm) return true;      // ORM PR

		  // 4) Check if any set is a ‚Äúweight PR‚Äù or ‚Äúweight+reps PR‚Äù
		  for (const set of ex.sets) {
			if (
			  set.weight_kg > bestWeight ||
			  (set.weight_kg === bestWeight && set.reps > bestRepsForWeight)
			) {
			  return true;
			}
		  }
		}
	  }
	  // If we never returned true, no PR found
	  return false;
	}
	
	function getDateRangeBounds(rangeType, referenceDate) {
	  const refDate = new Date(referenceDate);
	  let start, end;

	  switch(rangeType) {
		case 'year':
		  start = new Date(refDate.getFullYear(), 0, 1);
		  end = new Date(refDate.getFullYear(), 11, 31);
		  break;
		case 'month':
		  start = new Date(refDate.getFullYear(), refDate.getMonth(), 1);
		  end = new Date(refDate.getFullYear(), refDate.getMonth() + 1, 0);
		  break;
		case 'week':
		  // Get Monday of current week
		  const day = refDate.getDay();
		  const diff = refDate.getDate() - day + (day === 0 ? -6 : 1);
		  start = new Date(refDate.setDate(diff));
		  end = new Date(start);
		  end.setDate(end.getDate() + 6);
		  break;
		case 'all':
		default:
		  start = new Date(START_YEAR, 0, 1);
		  end = new Date(END_YEAR, 11, 31);
	  }
	  return { start, end };
	}
	
    function getDateKey(dateObj) {
      const y = dateObj.getFullYear();
      const m = String(dateObj.getMonth() + 1).padStart(2,"0");
      const d = String(dateObj.getDate()).padStart(2,"0");
      return `${y}-${m}-${d}`;
    }
    function parseDateKey(dateKey) {
      const [y,m,d] = dateKey.split("-").map(Number);
      return new Date(y, m - 1, d);
    }
    function isToday(dateObj) {
      const nowLocal = new Date();
      return (
        dateObj.getFullYear() === nowLocal.getFullYear() &&
        dateObj.getMonth() === nowLocal.getMonth() &&
        dateObj.getDate() === nowLocal.getDate()
      );
    }
    function isOffDayShift(shiftClass) {
      return (shiftClass === "off-bg" || shiftClass === "al-bg");
    }
    function isTrainingDay(dayObj) {
      return (dayObj.gym !== "Rest" && dayObj.gym !== "None");
    }
    function validateTimeHHMM(value) {
      if (!value) return true;
      return !!value.match(/^([01]\d|2[0-3])[0-5]\d$/);
    }
    function formatTimeForDisplay(time24) {
      if(!time24) return "";
      const hour = parseInt(time24.substring(0,2),10);
      const minute = time24.substring(2,4);
      let period = "am";
      let displayHour = hour;
      if(hour >= 12){
        period = "pm";
        if(hour > 12) displayHour = hour - 12;
      }
      if(hour === 0){
        displayHour = 12;
        period = "am";
      }
      return `${displayHour}:${minute}${period}`;
    }
	function getDayData(dateKey) {
	  if(!calendarData[dateKey]) {
		calendarData[dateKey] = {
		  shiftClass: "off-bg",
		  gym: "None",
		  gymTime: "",
		  workTime: "",
		  completed: false,
		  weight: null,
		  alert: null,
		  hevyWorkouts: [],
		  customColor: null // Add this new field
		};
	  }
	  return calendarData[dateKey];
	}
	
    function setDayData(dateKey, newData) {
      if(!calendarData[dateKey]) {
        calendarData[dateKey] = {};
      }
      Object.assign(calendarData[dateKey], newData);
      localStorage.setItem(LS_CALENDAR_DATA_KEY, JSON.stringify(calendarData));
    }
    function getLastRecordedWeightBefore(dateKey) {
      const dateObj = parseDateKey(dateKey);
      const d = new Date(dateObj.getTime());
      d.setDate(d.getDate() - 1);

      // We'll stop if we go before START_YEAR
      const earliestBoundary = new Date(START_YEAR, 0, 1);

      while(d >= earliestBoundary) {
        const prevKey = getDateKey(d);
        if (calendarData[prevKey] && calendarData[prevKey].weight > 0) {
          return calendarData[prevKey].weight;
        }
        d.setDate(d.getDate() - 1);
      }
      return null;
    }
    function getWeightArrow(dateKey) {
      const dayObj = getDayData(dateKey);
      if(!dayObj.weight || parseFloat(dayObj.weight) <= 0) return "";
      const lastWeight = getLastRecordedWeightBefore(dateKey);
      if(!lastWeight) return "";
      if(dayObj.weight > lastWeight)  return "‚Üë";
      if(dayObj.weight < lastWeight)  return "‚Üì";
      return "";
    }
    function computeFreeTime(dateKey) {
      const dayObj = getDayData(dateKey);
      if(!dayObj.workTime || isOffDayShift(dayObj.shiftClass)){
        return null;
      }
      const curStartHour = parseInt(dayObj.workTime.substring(0,2),10);
      const curStartMin = parseInt(dayObj.workTime.substring(2,4),10);
      let currentShiftDate = parseDateKey(dateKey);
      currentShiftDate.setHours(curStartHour, curStartMin, 0, 0);

      let currentShiftEnd = new Date(currentShiftDate.getTime() + 10 * 3600000);

      // Next day that has a valid workTime (within 2020-2030)
      let nextDate = new Date(parseDateKey(dateKey).getTime());
      nextDate.setDate(nextDate.getDate() + 1);
      let nextWorkShiftDate = null;

      while(nextDate.getFullYear() >= START_YEAR && nextDate.getFullYear() <= END_YEAR) {
        const nextKey = getDateKey(nextDate);
        const nextDay = getDayData(nextKey);
        if(nextDay.workTime && !isOffDayShift(nextDay.shiftClass)) {
          nextWorkShiftDate = new Date(nextDate.getTime());
          const nxHr = parseInt(nextDay.workTime.substring(0,2),10);
          const nxMin = parseInt(nextDay.workTime.substring(2,4),10);
          nextWorkShiftDate.setHours(nxHr, nxMin, 0, 0);
          break;
        }
        nextDate.setDate(nextDate.getDate() + 1);
      }
      if(!nextWorkShiftDate) return null;

      let nextPrepTime = new Date(nextWorkShiftDate.getTime() - 3600000); 
      let gapHours = (nextPrepTime - currentShiftEnd) / 3600000;

      // Subtract 8 hours sleep
      gapHours -= 8;

      return Math.max(0, Math.floor(gapHours));
    }
    function computeCurrentDayFreeTimeFull() {
      const nowLocal = new Date();
      let nextDate = new Date(nowLocal.getFullYear(), nowLocal.getMonth(), nowLocal.getDate() + 1);
      let nextWorkShiftDate = null;

      while(nextDate.getFullYear() >= START_YEAR && nextDate.getFullYear() <= END_YEAR) {
        const nextKey = getDateKey(nextDate);
        const nextDay = getDayData(nextKey);
        if(nextDay.workTime && !isOffDayShift(nextDay.shiftClass)) {
          nextWorkShiftDate = new Date(nextDate.getTime());
          const nxHr = parseInt(nextDay.workTime.substring(0,2),10);
          const nxMin = parseInt(nextDay.workTime.substring(2,4),10);
          nextWorkShiftDate.setHours(nxHr, nxMin, 0, 0);
          break;
        }
        nextDate.setDate(nextDate.getDate() + 1);
      }
      if(!nextWorkShiftDate) return "N/A";

      const diffMs = nextWorkShiftDate - nowLocal - 8 * 3600000; // Subtract 8 hours sleep
      if (diffMs < 0) return "N/A";
      const totalMinutes = Math.floor(diffMs / 60000);
      const hours = Math.floor(totalMinutes / 60);
      const minutes = totalMinutes % 60;
      return `${hours.toString().padStart(2,"0")}:${minutes.toString().padStart(2,"0")}`;
    }
    function getDefaultDataForDate(dateKey){
      if(!defaultCycleData.pattern.length || !defaultCycleData.startDate){
        return {
          shiftClass: "off-bg",
          gym: "None",
          gymTime: "",
          workTime: "",
          completed: false,
          weight: null,
          alert: null,
          hevyWorkouts: []
        };
      }
      const startDate = parseDateKey(defaultCycleData.startDate);
      const currentDate = parseDateKey(dateKey);
      const diffDays = Math.floor((currentDate - startDate) / MS_IN_DAY);
      const patternLength = defaultCycleData.pattern.length;
      const patternIndex = ((diffDays % patternLength) + patternLength) % patternLength;
      return defaultCycleData.pattern[patternIndex];
    }
    function escapeHtml(str) {
      return str.replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }

    // Compute approximate 1RM (Brzycki/Epley)
    function computeOrm(weightKg, reps) {
      if(reps <= 0 || weightKg <= 0) return 0;
      if(reps <= 10) {
        // Brzycki
        return weightKg / (1.0278 - 0.0278 * reps);
      } else {
        // Epley
        return weightKg * (1 + (reps / 30));
      }
    }

    // Return best historical (weight, reps) for an exercise (before a date)
    function getBestWeightAndRepsBeforeDate(exerciseName, dateKey) {
      let bestWeight = 0;
      let bestRepsForWeight = 0;

      const targetDate = parseDateKey(dateKey);

      for (const k of Object.keys(calendarData)) {
        const d = parseDateKey(k);
        if (d < targetDate) {
          const dayObj = calendarData[k];
          if (dayObj.hevyWorkouts) {
            dayObj.hevyWorkouts.forEach(workout => {
              workout.exercises.forEach(ex => {
                if (ex.title === exerciseName) {
                  ex.sets.forEach(s => {
                    if (s.weight_kg > bestWeight) {
                      bestWeight = s.weight_kg;
                      bestRepsForWeight = s.reps;
                    }
                    else if (s.weight_kg === bestWeight && s.reps > bestRepsForWeight) {
                      bestRepsForWeight = s.reps;
                    }
                  });
                }
              });
            });
          }
        }
      }
      return { bestWeight, bestRepsForWeight };
    }
    function getMaxVolumeForExerciseBeforeDate(exerciseName, dateKey) {
      const targetDate = parseDateKey(dateKey);
      let maxVolume = 0;
      for(const k of Object.keys(calendarData)) {
        const d = parseDateKey(k);
        if(d < targetDate) {
          let dayVolume = 0;
          const dayObj = calendarData[k];
          if(dayObj.hevyWorkouts) {
            dayObj.hevyWorkouts.forEach(workout => {
              workout.exercises.forEach(ex => {
                if(ex.title === exerciseName) {
                  ex.sets.forEach(s => {
                    dayVolume += (s.weight_kg * s.reps);
                  });
                }
              });
            });
          }
          if(dayVolume > maxVolume) {
            maxVolume = dayVolume;
          }
        }
      }
      return maxVolume;
    }
    function getMaxOrmForExerciseBeforeDate(exerciseName, dateKey) {
      const targetDate = parseDateKey(dateKey);
      let maxOrm = 0;
      for(const k of Object.keys(calendarData)) {
        const d = parseDateKey(k);
        if(d < targetDate) {
          const dayObj = calendarData[k];
          if(dayObj.hevyWorkouts) {
            dayObj.hevyWorkouts.forEach(workout => {
              workout.exercises.forEach(ex => {
                if(ex.title === exerciseName) {
                  ex.sets.forEach(s => {
                    const thisOrm = computeOrm(s.weight_kg, s.reps);
                    if(thisOrm > maxOrm) {
                      maxOrm = thisOrm;
                    }
                  });
                }
              });
            });
          }
        }
      }
      return maxOrm;
    }

    /*
      =======================================
      =       3) Calendar Rendering         =
      =======================================
    */
    function renderCalendar(year, month) {
      document.getElementById("monthLabel").textContent = `${monthNames[month]} ${year}`;
	  updateBackgroundForMonth(month);
      const calendar = document.getElementById("calendar");
      calendar.innerHTML = "";

      const headerEl = renderCalendarHeader();
      const gridEl = renderCalendarGrid(year, month);

      calendar.appendChild(headerEl);
      calendar.appendChild(gridEl);

      updateCounters();
      updatePopulateCalendarButtonState();
    }
    function renderCalendarHeader() {
      const headerGrid = document.createElement("div");
      headerGrid.classList.add("calendar-header");
      dayNames.forEach(d => {
        const hd = document.createElement("div");
        hd.textContent = d;
        headerGrid.appendChild(hd);
      });
      return headerGrid;
    }
    function renderCalendarGrid(year, month) {
      const grid = document.createElement("div");
      grid.classList.add("calendar-grid");

      const daysInMonth = new Date(year, month + 1, 0).getDate();
      const firstDay = new Date(year, month, 1);
      const startWeekday = firstDay.getDay();
      let rowIndex = 0, colIndex = 0;

      // Blank cells before the first day
      for(let i = 0; i < startWeekday; i++){
        grid.appendChild(blankCell(rowIndex, colIndex++));
      }

      // Days of the current month
      for(let dayNum = 1; dayNum <= daysInMonth; dayNum++){
        const dateObj = new Date(year, month, dayNum);
        const cell = renderDayCell(dateObj, dayNum);
        cell.setAttribute("data-row", rowIndex);
        cell.setAttribute("data-col", colIndex);
        grid.appendChild(cell);

        colIndex++;
        if(colIndex > 6){
          colIndex = 0;
          rowIndex++;
        }
      }

      // Fill remaining cells to make up to 6 rows (42 cells total)
      const totalCellsUsed = startWeekday + daysInMonth;
      const remainingCells = 42 - totalCellsUsed;
      for(let i = 0; i < remainingCells; i++){
        grid.appendChild(blankCell(rowIndex, colIndex++));
        if(colIndex > 6){
          colIndex = 0;
          rowIndex++;
        }
      }
      return grid;
    }
	
    function blankCell(row, col) {
      const blank = document.createElement("div");
      blank.classList.add("day-cell", "faded");
      blank.setAttribute("data-row", row);
      blank.setAttribute("data-col", col);
      return blank;
    }
	
	function renderDayCell(dateObj, dayNum) {
	  const dateKey = getDateKey(dateObj);
	  const dayData = getDayData(dateKey);

	  const cell = document.createElement("div");
	  cell.classList.add("day-cell");

	  // Modified color handling
	  if (dayData.shiftClass === "custom-color" && dayData.customColor) {
		cell.style.backgroundColor = dayData.customColor;
	  } else {
		cell.classList.add(dayData.shiftClass);
	  }

	  cell.setAttribute("data-date-key", dateKey);

	  if (isToday(dateObj)) cell.classList.add("today");
	  if (dayData.completed) cell.classList.add("completed");
	  if (selectedDates.has(dateKey)) cell.classList.add("selected");

	  // Date number
	  const dateDiv = document.createElement("div");
	  dateDiv.classList.add("date-num");
	  dateDiv.textContent = dayNum;
	  cell.appendChild(dateDiv);

	  // Free time
	  if (isToday(dateObj)) {
		if (isOffDayShift(dayData.shiftClass)) {
		  const currentFreeTime = computeCurrentDayFreeTimeFull();
		  appendFreeTime(cell, currentFreeTime, true);
		} else {
		  const freeTime = computeFreeTime(dateKey);
		  if (freeTime) appendFreeTime(cell, freeTime);
		}
	  } else {
		const freeTime = computeFreeTime(dateKey);
		if (freeTime) appendFreeTime(cell, freeTime);
	  }

	  // Refresh icon
	  const refreshDiv = document.createElement("div");
	  refreshDiv.classList.add("refresh-emoji");
	  refreshDiv.textContent = "‚ü≥";
	  refreshDiv.addEventListener("mousedown", e => e.stopPropagation());
	  refreshDiv.addEventListener("click", e => {
		e.stopPropagation();
		if (!selectedDates.has(dateKey)) {
		  selectedDates.clear();
		  selectedDates.add(dateKey);
		}
		openCustomizationPopup();
	  });
	  cell.appendChild(refreshDiv);

	  // Alerts
	  if (dayData.alert && dayData.alert.type && dayData.alert.type !== "None") {
		const color = alertColors[dayData.alert.type] || "#32CD32";
		const overlay = document.createElement("div");
		overlay.classList.add("alert-overlay");
		overlay.style.background = `linear-gradient(to bottom, ${color}CC, transparent 100%)`;
		cell.appendChild(overlay);

		const alertSpan = document.createElement("div");
		alertSpan.classList.add("alert-text");
		alertSpan.textContent = dayData.alert.text || "";
		cell.appendChild(alertSpan);
	  }

	  // Weight display
	  const weightDiv = document.createElement("div");
	  weightDiv.classList.add("weight-display");
	  if (dayData.weight && parseFloat(dayData.weight) > 0) {
		const arrow = getWeightArrow(dateKey);
		let arrowColor = "#FFF";
		if (arrow === "‚Üë") arrowColor = "#FF4444";
		if (arrow === "‚Üì") arrowColor = "#66CC66";

		const textSpan = `${dayData.weight}kg`;
		if (arrow) {
		  if (arrow === "‚Üë") {
			weightDiv.innerHTML = `<span style="font-size:120%; color:${arrowColor}; margin-right:0.3em;">${arrow}</span> ${textSpan}`;
			weightDiv.style.color = arrowColor;
		  } else {
			weightDiv.innerHTML = `${textSpan} <span style="font-size:120%; color:${arrowColor}; margin-left:0.3em;">${arrow}</span>`;
			weightDiv.style.color = arrowColor;
		  }
		} else {
		  weightDiv.textContent = textSpan;
		}
	  }
	  cell.appendChild(weightDiv);

	  // Shift time
	  const shiftTimeDiv = document.createElement("div");
	  shiftTimeDiv.classList.add("shift-time-text");
	  if (dayData.shiftClass === "al-bg") {
		shiftTimeDiv.textContent = "AL";
	  } else if (dayData.workTime && !isOffDayShift(dayData.shiftClass)) {
		shiftTimeDiv.textContent = dayData.workTime;
	  }
	  cell.appendChild(shiftTimeDiv);

	  // Workout info
	  const wDiv = document.createElement("div");
	  wDiv.classList.add("workout-info");
	  if (dayData.gym === "Rest") {
		wDiv.textContent = "üò¥";
		wDiv.style.opacity = "1.0";
	  } else if (dayData.gym === "None") {
		wDiv.textContent = "";
	  } else {
		wDiv.innerHTML = `${dayData.gym}: ${formatTimeForDisplay(dayData.gymTime || "")}`;
	  }
	  cell.appendChild(wDiv);

	  // Completed badge
	  const badgeDiv = document.createElement("div");
	  badgeDiv.classList.add("completed-badge");
	  if (dayData.completed) badgeDiv.classList.add("enabled");
	  badgeDiv.addEventListener("mousedown", e => e.stopPropagation());
	  badgeDiv.addEventListener("click", (e) => {
		e.stopPropagation();
		setDayData(dateKey, { completed: !dayData.completed });
		renderCalendar(currentYear, currentMonth);
	  });
	  badgeDiv.innerHTML = `
		<svg width="16" height="16" fill="none" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor">
		  <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" />
		</svg>
	  `;
	  cell.appendChild(badgeDiv);

	  return cell;
	}
    function appendFreeTime(cell, freeTimeValue, isTodayOffShift) {
      const freeTimeDiv = document.createElement("div");
      freeTimeDiv.classList.add("free-time-text");
      freeTimeDiv.textContent = freeTimeValue;
      if(isTodayOffShift) {
        freeTimeDiv.style.color = "gold";
        freeTimeDiv.style.opacity = "0.7";
      }
      cell.appendChild(freeTimeDiv);
    }

    /*
      =======================================
      =    4) Single vs Multi Popup Flow    =
      =======================================
    */
    function openCustomizationPopup() {
      if(selectedDates.size === 0){
        showCustomAlert("No days selected. Please select a cell first.");
        return;
      }
      if(selectedDates.size === 1){
        openSingleModal();
      } else {
        openMultiModal();
      }
    }

    // 4a) Single-Cell Modal
    let currentSingleDayKey = null;

    function populateWorkTimeSelect(selectId, selectedValue){
      const selectElem = document.getElementById(selectId);
      selectElem.innerHTML = "";
      Object.keys(workTimeColors).sort().forEach(time => {
        const option = document.createElement("option");
        option.value = time;
        option.textContent = time;
        option.style.backgroundColor = workTimeColors[time] || "#444";
        option.style.color = "#fff";
        if(time === selectedValue) { option.selected = true; }
        selectElem.appendChild(option);
      });
    }
    function updateSingleWorkTimeState(){
      const active = document.querySelector("#singleColorSwatchesContainer .swatch.active");
      if(active){
        const preset = active.id.replace("swatch-single-", "");
        document.getElementById("singleWorkTimeSelect").disabled =
          (preset === "off-bg" || preset === "al-bg");
      }
    }
	function openSingleModal() {
	  document.getElementById("singleOverlay").classList.add("active");
	  document.querySelectorAll("#singleColorSwatchesContainer .swatch").forEach(s => s.classList.remove("active"));

	  const [dKey] = [...selectedDates];
	  currentSingleDayKey = dKey;
	  const dayData = getDayData(dKey);

	  // Date
	  const dateObj = parseDateKey(currentSingleDayKey);
	  const formattedDate = `${dateObj.getDate()} ${monthNames[dateObj.getMonth()]}, ${dateObj.getFullYear()}`;
	  document.getElementById("singleModalDate").textContent = formattedDate;

	  // Shift Preset
	  document.querySelectorAll("#singleColorSwatchesContainer .swatch").forEach(swatch => {
		if(swatch.id === `swatch-single-${dayData.shiftClass}`){
		  swatch.classList.add("active");
		} else {
		  swatch.classList.remove("active");
		}
	  });
	  const preset = colorOptions.find(opt => opt.className === dayData.shiftClass);
	  document.getElementById("singleShiftLabelText").textContent = preset ? preset.label : "Custom Shift";

	  // Form values
	  document.getElementById("singleWorkoutTypeSelect").value = dayData.gym || "None";
	  document.getElementById("singleGymTimeInput").value = dayData.gymTime || "";
	  document.getElementById("singleWorkTimeSelect").value = dayData.workTime || ""; // Fixed
	  document.getElementById("singleWeightInput").value = dayData.weight || "";

	  if(isOffDayShift(dayData.shiftClass)) {
		document.getElementById("singleWorkTimeSelect").disabled = true;
	  } else {
		document.getElementById("singleWorkTimeSelect").disabled = false;
	  }

	  // Alerts
	  let alertVal = "None";
	  if(dayData.alert && dayData.alert.type && dayData.alert.type !== "None") {
		alertVal = dayData.alert.type;
	  }
	  document.getElementById("singleAlertTypeSelect").value = alertVal;
	  document.getElementById("singleAlertTextInput").value =
		(dayData.alert && dayData.alert.text) ? dayData.alert.text : "";

	  // Scroll to top
	  document.getElementById("singleModal").scrollTop = 0;
	}
	
    function closeSingleModal() {
      document.getElementById("singleOverlay").classList.remove("active");
    }
	function resetSingleField(fieldName) {
	  if(!currentSingleDayKey) return;
	  const defaultData = getDefaultDataForDate(currentSingleDayKey);
	  if(!defaultData) return;

	  if(fieldName === "shiftClass"){
		document.querySelectorAll("#singleColorSwatchesContainer .swatch").forEach(s => s.classList.remove("active"));
		const sw = document.getElementById("swatch-single-" + defaultData.shiftClass);
		if(sw) sw.classList.add("active");
		const preset = colorOptions.find(o => o.className === defaultData.shiftClass);
		document.getElementById("singleShiftLabelText").textContent = preset ? preset.label : "(none)";

		if(isOffDayShift(defaultData.shiftClass)) {
		  document.getElementById("singleWorkTimeSelect").disabled = true;
		} else {
		  document.getElementById("singleWorkTimeSelect").disabled = false;
		}
	  } else if(fieldName === "gym"){
		document.getElementById("singleWorkoutTypeSelect").value = defaultData.gym;
	  } else if(fieldName === "gymTime"){
		document.getElementById("singleGymTimeInput").value = defaultData.gymTime || "";
	  } else if(fieldName === "workTime"){
		document.getElementById("singleWorkTimeSelect").value = defaultData.workTime || "";
	  } else if(fieldName === "weight"){
		document.getElementById("singleWeightInput").value = defaultData.weight || "";
	  } else if(fieldName === "alertType"){
		if(defaultData.alert && defaultData.alert.type){
		  document.getElementById("singleAlertTypeSelect").value = defaultData.alert.type;
		} else {
		  document.getElementById("singleAlertTypeSelect").value = "None";
		}
	  } else if(fieldName === "alertText"){
		if(defaultData.alert && defaultData.alert.text){
		  document.getElementById("singleAlertTextInput").value = defaultData.alert.text;
		} else {
		  document.getElementById("singleAlertTextInput").value = "";
		}
	  }
	}
	function saveSingleModal() {
	  if(!currentSingleDayKey) return;
	  const updates = {};
	  const activeSwatch = document.querySelector("#singleColorSwatchesContainer .swatch.active");
	  
	  if(activeSwatch) {
		updates.shiftClass = activeSwatch.id.replace("swatch-single-", "");
	  }
	  
	  updates.gym = document.getElementById("singleWorkoutTypeSelect").value.trim();
	  
	  // Work time
	  updates.workTime = document.getElementById("singleWorkTimeSelect").value.trim();
	  if(updates.workTime) {
		if(!validateTimeHHMM(updates.workTime)) {
		  showCustomAlert("Invalid Work Time. Use HHMM format (e.g. 2100).");
		  return;
		}
	  }
	  
	  // Gym time
	  const newGymTime = document.getElementById("singleGymTimeInput").value.trim();
	  if(newGymTime) {
		if(!validateTimeHHMM(newGymTime)) {
		  showCustomAlert("Invalid Gym Time. Use HHMM format (e.g. 2100).");
		  return;
		}
		updates.gymTime = newGymTime;
	  } else {
		updates.gymTime = "";
	  }

	  // Preset color
	  if(activeSwatch && activeSwatch.id.includes('custom-')) {
		const preset = colorOptions.find(p => p.className === activeSwatch.id.replace("swatch-single-", ""));
		if(preset && preset.data) {
		  updates.presetColor = preset.data.color;
		}
	  }

	  // Weight
	  const weightVal = document.getElementById("singleWeightInput").value.trim();
	  if(weightVal) {
		let wf = parseFloat(weightVal);
		if(isNaN(wf) || wf <= 0) {
		  showCustomAlert("Invalid weight.");
		  return;
		}
		updates.weight = wf.toFixed(1);
	  } else {
		updates.weight = null;
	  }

	  // Alert
	  const alertType = document.getElementById("singleAlertTypeSelect").value;
	  const alertText = document.getElementById("singleAlertTextInput").value.trim();
	  if(alertType && alertType !== "None") {
		updates.alert = { type: alertType, text: alertText || "" };
	  } else {
		updates.alert = null;
	  }

	  setDayData(currentSingleDayKey, updates);
	  closeSingleModal();
	  renderCalendar(currentYear, currentMonth);

	  // Pulse highlight
	  setTimeout(() => {
		const cellElement = document.querySelector(`[data-date-key="${currentSingleDayKey}"]`);
		if(cellElement) {
		  cellElement.classList.add("cell-pulse");
		  cellElement.addEventListener("animationend", function handler() {
			cellElement.classList.remove("cell-pulse");
			cellElement.removeEventListener("animationend", handler);
		  });
		}
	  }, 100);
	}
    function revertSingleModal() {
      if(!currentSingleDayKey) return;
      const defaultData = getDefaultDataForDate(currentSingleDayKey);
      if(defaultData){
        setDayData(currentSingleDayKey, {
          shiftClass: defaultData.shiftClass,
          gym: defaultData.gym,
          gymTime: defaultData.gymTime || "",
          workTime: defaultData.workTime || "",
          completed: defaultData.completed || false,
          weight: defaultData.weight || null,
          alert: defaultData.alert || null,
          hevyWorkouts: defaultData.hevyWorkouts ? [...defaultData.hevyWorkouts] : []
        });
      }
      closeSingleModal();
      renderCalendar(currentYear, currentMonth);
    }

    // 4b) Multi-Cell Modal
    function openMultiModal() {
      document.getElementById("multiOverlay").classList.add("active");
      document.getElementById("multiKeySelect").value = "";
      document.getElementById("multiValueInput").value = "";
      document.getElementById("multiValueInput").placeholder = "";
      document.getElementById("multiShiftSwatchesRow").style.display = "none";
      document.getElementById("multiAlertTypeRow").style.display = "none";
      document.getElementById("multiWorkTimeRow").style.display = "none";
      document.getElementById("multiWorkoutTypeRow").style.display = "none";
      document.getElementById("multiAlertTypeSelect").value = "None";
      document.querySelectorAll("#multiColorSwatchesContainer .swatch").forEach(s => s.classList.remove("active"));
      document.getElementById("multiShiftLabelText").textContent = "(none)";
    }
    function closeMultiModal() {
      document.getElementById("multiOverlay").classList.remove("active");
    }
    function handleMultiKeyChange() {
      const key = document.getElementById("multiKeySelect").value;
      const valRow = document.getElementById("multiValueRow");
      const shiftRow = document.getElementById("multiShiftSwatchesRow");
      const alertRow = document.getElementById("multiAlertTypeRow");
      const workTimeRow = document.getElementById("multiWorkTimeRow");
      const workoutTypeRow = document.getElementById("multiWorkoutTypeRow");

      shiftRow.style.display = "none";
      valRow.style.display = "none";
      alertRow.style.display = "none";
      workTimeRow.style.display = "none";
      workoutTypeRow.style.display = "none";

      if(key === "shiftClass"){
        shiftRow.style.display = "flex";
      } else if(key === "alertType"){
        alertRow.style.display = "flex";
      } else if(key === "workTime"){
        workTimeRow.style.display = "flex";
        populateWorkTimeSelect("multiWorkTimeSelect", "");
      } else if(key === "gym"){
        workoutTypeRow.style.display = "flex";
      } else if(key){
        valRow.style.display = "flex";
        document.getElementById("multiValueInput").placeholder = multiPlaceholderMap[key] || "";
      }
    }
	function saveMultiModal() {
	  const key = document.getElementById("multiKeySelect").value;
	  if (!key) {
		showCustomAlert("Please select a key to change.");
		return;
	  }

	  let newValue;
	  if (key === "shiftClass") {
		const swatch = document.querySelector("#multiColorSwatchesContainer .swatch.active");
		if (!swatch) {
		  showCustomAlert("Please choose a shift preset.");
		  return;
		}
		newValue = swatch.id.replace("swatch-multi-", "");
		
		// Find preset data
		const preset = colorOptions.find(opt => opt.className === newValue);
		
		selectedDates.forEach(dKey => {
		  const updated = {
			shiftClass: newValue
		  };
		  
		  // Apply all preset data if available
		  if (preset && preset.data) {
			updated.workTime = preset.data.workTime || "";
			updated.gymTime = preset.data.gymTime || "";
			updated.gym = preset.data.gym || "None";
			updated.alert = preset.data.alert || null;
		  } else if (newValue === "off-bg" || newValue === "al-bg") {
			updated.workTime = "";
		  }
		  
		  setDayData(dKey, updated);
		});
	  } else {
		if (key === "alertType") {
		  newValue = document.getElementById("multiAlertTypeSelect").value;
		} else if (key === "workTime") {
		  newValue = document.getElementById("multiWorkTimeInput").value.trim();
		  if (newValue && !validateTimeHHMM(newValue)) {
			showCustomAlert("Invalid time. Use HHMM format (e.g. 0900).");
			return;
		  }
		} else if (key === "gym") {
		  newValue = document.getElementById("multiWorkoutTypeSelect").value;
		} else {
		  newValue = document.getElementById("multiValueInput").value.trim();
		}

		if (key === "gymTime" && newValue) {
		  if (!validateTimeHHMM(newValue)) {
			showCustomAlert("Invalid time. Use HHMM format (e.g. 0600).");
			return;
		  }
		}
		if (key === "weight") {
		  if (newValue) {
			let wf = parseFloat(newValue);
			if (isNaN(wf) || wf <= 0) {
			  showCustomAlert("Invalid weight.");
			  return;
			}
			newValue = wf.toFixed(1);
		  } else {
			newValue = null;
		  }
		}

		selectedDates.forEach(dKey => {
		  const updated = {};

		  if (key === "gym") {
			updated.gym = newValue || "";
		  } else if (key === "gymTime") {
			updated.gymTime = newValue || "";
		  } else if (key === "workTime") {
			updated.workTime = newValue || "";
		  } else if (key === "weight") {
			updated.weight = newValue ? newValue : null;
		  } else if (key === "alertType") {
			if (newValue === "None") {
			  updated.alert = null;
			} else {
			  updated.alert = { type: newValue, text: "" };
			}
		  } else if (key === "alertText") {
			if (newValue) {
			  if (calendarData[dKey].alert && calendarData[dKey].alert.type && calendarData[dKey].alert.type !== "None") {
				updated.alert = { type: calendarData[dKey].alert.type, text: newValue };
			  } else {
				updated.alert = { type: "Generic", text: newValue };
			  }
			} else {
			  updated.alert = null;
			}
		  }

		  setDayData(dKey, updated);
		});
	  }

	  closeMultiModal();
	  renderCalendar(currentYear, currentMonth);

	  setTimeout(() => {
		selectedDates.forEach(dKey => {
		  const cellElement = document.querySelector(`[data-date-key="${dKey}"]`);
		  if (cellElement) {
			cellElement.classList.add("cell-pulse");
			cellElement.addEventListener("animationend", function handler() {
			  cellElement.classList.remove("cell-pulse");
			  cellElement.removeEventListener("animationend", handler);
			});
		  }
		});
	  }, 100);
	}
    function revertMultiModal() {
      selectedDates.forEach(dKey => {
        const defaultData = getDefaultDataForDate(dKey);
        if(defaultData){
          setDayData(dKey, {
            shiftClass: defaultData.shiftClass,
            gym: defaultData.gym,
            gymTime: defaultData.gymTime || "",
            workTime: defaultData.workTime || "",
            completed: defaultData.completed || false,
            weight: defaultData.weight || null,
            alert: defaultData.alert || null,
            hevyWorkouts: defaultData.hevyWorkouts ? [...defaultData.hevyWorkouts] : []
          });
        }
      });
      closeMultiModal();
      renderCalendar(currentYear, currentMonth);
    }

    /*
      =======================================
      =          5) Counters (Stats)        =
      =======================================
    */
    function updateCounters() {
      let completedCount = 0;
      let earliestDateKey = null;

      Object.keys(calendarData).forEach(key => {
        const dayObj = calendarData[key];
        if(dayObj.completed && isTrainingDay(dayObj)){
          completedCount++;
          if(!earliestDateKey || key < earliestDateKey){
            earliestDateKey = key;
          }
        }
      });

      let daysTrained = 0;
      if(earliestDateKey){
        const earliestDate = parseDateKey(earliestDateKey);
        const nowLocal = new Date();
        // We'll only do day difference if earliest is <= now
        if(earliestDate <= nowLocal){
          let diff = nowLocal - earliestDate;
          let rawDays = Math.floor(diff / MS_IN_DAY);
          if(rawDays < 0) rawDays = 0;
          daysTrained = rawDays + 1;
        }
      }
      let percentage = 0;
      if(daysTrained > 0){
        percentage = (completedCount / daysTrained) * 100;
      }

      document.getElementById("sessionCounter").textContent = completedCount;
      document.getElementById("daysTrainedCounter").textContent = daysTrained;
      document.getElementById("percentageCounter").textContent = percentage.toFixed(2) + '%';
    }

    /*
      =======================================
      =         6) Navigation               =
      =======================================
    */
    function prevMonth() {
      currentMonth--;
      if(currentMonth < 0){
        currentMonth = 11;
        currentYear--;
      }
      if(currentYear < START_YEAR){
        currentYear = START_YEAR;
        currentMonth = 0;
      }
      selectedDates.clear();
      renderCalendar(currentYear, currentMonth);
    }
    function nextMonth() {
      currentMonth++;
      if(currentMonth > 11){
        currentMonth = 0;
        currentYear++;
      }
      if(currentYear > END_YEAR){
        currentYear = END_YEAR;
        currentMonth = 11;
      }
      selectedDates.clear();
      renderCalendar(currentYear, currentMonth);
    }

    /*
      =======================================
      =   7) Shift Preset & Color Swatches  =
      =======================================
    */
    const workTimeColors = {
      "0000": "#926E8E","0100": "#A47887","0200": "#B78381","0300": "#C8917A",
      "0400": "#DB9C73","0500": "#EDA76D","0600": "#FFAD66","0700": "#EEAE74",
      "0800": "#DEAF83","0900": "#D0A77D","1000": "#BDB2A0","1100": "#ACB3AE",
      "1200": "#9CB4BC","1300": "#8CB4CA","1400": "#7AB6D9","1500": "#76A7D1",
      "1600": "#7198C9","1700": "#6D8BC2","1800": "#697DBA","1900": "#627AA3",
      "2000": "#6060AA","2100": "#5C4EA2","2200": "#6E599B","2300": "#806395"
    };
    const alertColors = {
      "Generic": "#32CD32",
      "Birthday": "#FF69B4",
      "Work": "#1E90FF",
      "PublicHoliday": "#FFD700",
	  "Deadline": "#C41E3A",
	  "School": "#FF6600"
    };
    const presetWorkTimeMapping = {
      "morning-bg": "0600",
      "late-day-bg": "0900",
      "afternoon-bg": "1400",
      "evening-bg": "1900",
      "night-bg": "2100"
    };
    const multiPlaceholderMap = {
      shiftClass: "Use swatches below",
      gym: "Select Workout Type",
      gymTime: "HHMM e.g. 2100",
      workTime: "Choose work time",
      weight: "e.g. 88.0",
      alertType: "",
      alertText: "e.g. My special event"
    };

	function buildColorSwatches() {
	  function buildSet(containerId, prefix, labelTextId) {
		const container = document.getElementById(containerId);
		container.innerHTML = '';

		// Add base color options
		baseColorOptions.forEach(opt => {
		  const div = document.createElement("div");
		  div.id = `swatch-${prefix}-${opt.className}`;
		  div.className = `swatch ${opt.className}`;
		  div.title = opt.label;

		  div.addEventListener("mouseover", () => {
			document.getElementById(labelTextId).textContent = opt.label;
		  });

		  div.addEventListener("mouseout", () => {
			const activeSw = container.querySelector(".swatch.active");
			if (activeSw) {
			  const className = activeSw.id.replace(`swatch-${prefix}-`, "");
			  const found = colorOptions.find(o => o.className === className);
			  document.getElementById(labelTextId).textContent = found ? found.label : "(none)";
			} else {
			  document.getElementById(labelTextId).textContent = "(none)";
			}
		  });

		  div.addEventListener("click", () => {
			container.querySelectorAll(".swatch").forEach(s => s.classList.remove("active"));
			div.classList.add("active");

			// Handle delete button state
			if (prefix === "single") {
			  const deleteBtn = container.parentNode.querySelector(".delete-preset-emoji");
			  const className = div.id.replace("swatch-single-", "");
			  const preset = colorOptions.find(o => o.className === className);
			  
			  if (preset?.custom) {
				deleteBtn.style.opacity = "1";
				deleteBtn.style.pointerEvents = "auto";
			  } else {
				deleteBtn.style.opacity = "0.5";
				deleteBtn.style.pointerEvents = "none";
			  }
			}

			// Existing preset application logic
			if (prefix === "single") {
			  updateSingleWorkTimeState();
			  const className = div.id.replace("swatch-single-", "");
			  const preset = colorOptions.find(o => o.className === className);
			  
			  if (preset && preset.data) {
				document.getElementById("singleWorkTimeSelect").value = preset.data.workTime || "";
				document.getElementById("singleGymTimeInput").value = preset.data.gymTime || "";
				document.getElementById("singleWorkoutTypeSelect").value = preset.data.gym || "None";
				document.getElementById("singleAlertTypeSelect").value = preset.data.alert?.type || "None";
				document.getElementById("singleAlertTextInput").value = preset.data.alert?.text || "";
			  }
			}
		  });

		  container.appendChild(div);
		});

		// Add separator if custom presets exist
		if (customPresets.length > 0) {
		  const separator = document.createElement("div");
		  separator.className = "preset-separator";
		  container.appendChild(separator);
		}

		// Add custom presets
		customPresets.forEach(opt => {
		  const div = document.createElement("div");
		  div.id = `swatch-${prefix}-${opt.className}`;
		  div.className = `swatch ${opt.className}`;
		  div.title = opt.label;

		  div.addEventListener("mouseover", () => {
			document.getElementById(labelTextId).textContent = opt.label;
		  });

		  div.addEventListener("mouseout", () => {
			const activeSw = container.querySelector(".swatch.active");
			if (activeSw) {
			  const className = activeSw.id.replace(`swatch-${prefix}-`, "");
			  const found = colorOptions.find(o => o.className === className);
			  document.getElementById(labelTextId).textContent = found ? found.label : "(none)";
			} else {
			  document.getElementById(labelTextId).textContent = "(none)";
			}
		  });

		  div.addEventListener("click", () => {
			container.querySelectorAll(".swatch").forEach(s => s.classList.remove("active"));
			div.classList.add("active");

			// Handle delete button state
			if (prefix === "single") {
			  const deleteBtn = container.parentNode.querySelector(".delete-preset-emoji");
			  deleteBtn.style.opacity = "1";
			  deleteBtn.style.pointerEvents = "auto";
			}

			// Existing preset application logic
			if (prefix === "single") {
			  updateSingleWorkTimeState();
			  const className = div.id.replace("swatch-single-", "");
			  const preset = colorOptions.find(o => o.className === className);
			  
			  if (preset && preset.data) {
				document.getElementById("singleWorkTimeSelect").value = preset.data.workTime || "";
				document.getElementById("singleGymTimeInput").value = preset.data.gymTime || "";
				document.getElementById("singleWorkoutTypeSelect").value = preset.data.gym || "None";
				document.getElementById("singleAlertTypeSelect").value = preset.data.alert?.type || "None";
				document.getElementById("singleAlertTextInput").value = preset.data.alert?.text || "";
			  }
			}
		  });

		  container.appendChild(div);
		});

		// Add buttons only to single modal
		if (prefix === "single") {
		  const buttonContainer = document.createElement("div");
		  buttonContainer.style.cssText = `
			grid-column: 1 / -1;
			display: flex;
			gap: 0.5rem;
			justify-content: center;
			margin-top: 0.5rem;
		  `;

		  // Add Preset Button
		  const addBtn = document.createElement("div");
		  addBtn.className = "add-preset-emoji";
		  addBtn.innerHTML = `<span>‚ûï</span><span>Add Preset</span>`;
		  addBtn.style.cssText = `
			display: flex;
			align-items: center;
			gap: 0.5rem;
			padding: 0.75rem;
			border: 1px solid #444;
			border-radius: 6px;
			cursor: pointer;
			transition: all 0.2s;
			background: rgba(255, 255, 255, 0.05);
		  `;
		  addBtn.addEventListener("mouseenter", () => {
			addBtn.style.background = "rgba(255, 255, 255, 0.1)";
			addBtn.style.borderColor = "#666";
		  });
		  addBtn.addEventListener("mouseleave", () => {
			addBtn.style.background = "rgba(255, 255, 255, 0.05)";
			addBtn.style.borderColor = "#444";
		  });
		  addBtn.addEventListener("click", addNewPreset);

		  // Delete Preset Button
		  const deleteBtn = document.createElement("div");
		  deleteBtn.className = "delete-preset-emoji";
		  deleteBtn.innerHTML = `<span>üóëÔ∏è</span><span>Delete Preset</span>`;
		  deleteBtn.style.cssText = `
			display: flex;
			align-items: center;
			gap: 0.5rem;
			padding: 0.75rem;
			border: 1px solid #444;
			border-radius: 6px;
			cursor: pointer;
			transition: all 0.2s;
			background: rgba(255, 255, 255, 0.05);
			opacity: 0.5;
			pointer-events: none;
		  `;
		  deleteBtn.addEventListener("mouseenter", () => {
			if (deleteBtn.style.pointerEvents !== "none") {
			  deleteBtn.style.background = "rgba(255, 255, 255, 0.1)";
			  deleteBtn.style.borderColor = "#666";
			}
		  });
		  deleteBtn.addEventListener("mouseleave", () => {
			deleteBtn.style.background = "rgba(255, 255, 255, 0.05)";
			deleteBtn.style.borderColor = "#444";
		  });
		  deleteBtn.addEventListener("click", handleDeletePreset);

		  buttonContainer.appendChild(addBtn);
		  buttonContainer.appendChild(deleteBtn);
		  container.appendChild(buttonContainer);
		}
	  }

	  buildSet("singleColorSwatchesContainer", "single", "singleShiftLabelText");
	  buildSet("multiColorSwatchesContainer", "multi", "multiShiftLabelText");
	}
	
	function handleDeletePreset() {
	  const activeSwatch = document.querySelector("#singleColorSwatchesContainer .swatch.active");
	  if (!activeSwatch) return;

	  const className = activeSwatch.id.replace("swatch-single-", "");
	  const preset = customPresets.find(p => p.className === className);
	  
	  if (preset) {
		showCustomConfirm(`Delete preset "${preset.label}"?`, () => {
		  // Store color before deletion
		  const deletedColor = preset.data.color;
		  
		  // Update all cells using this preset
		  Object.keys(calendarData).forEach(dateKey => {
			if (calendarData[dateKey].shiftClass === className) {
			  calendarData[dateKey].shiftClass = "custom-color";
			  calendarData[dateKey].customColor = deletedColor; // Add new field
			}
		  });

		  // Remove from presets
		  customPresets = customPresets.filter(p => p.className !== className);
		  localStorage.setItem(LS_PRESETS_KEY, JSON.stringify(customPresets));
		  
		  // Remove associated CSS
		  document.querySelector(`style[data-preset="${className}"]`)?.remove();
		  
		  // Update UI
		  colorOptions = [...baseColorOptions, ...customPresets];
		  buildColorSwatches();
		  renderCalendar(currentYear, currentMonth); // Refresh calendar
		  showCustomAlert("Preset deleted successfully");
		});
	  }
	}

    /*
      =======================================
      =   8) Data Backup (Load/Save JSON)   =
      =======================================
    */
	function saveData() {
	  const dataToSave = {
		calendarData: calendarData,
		defaultCycle: defaultCycleData,
		customPresets: customPresets
	  };
	  const dataStr = JSON.stringify(dataToSave, null, 2);
	  const blob = new Blob([dataStr], { type: "application/json" });
	  const url = URL.createObjectURL(blob);
	  const a = document.createElement("a");
	  a.href = url;
	  a.download = 'calendar-data-backup.json';
	  a.click();
	  URL.revokeObjectURL(url);
	}
	function loadData(file) {
	  const reader = new FileReader();
	  reader.onload = (e) => {
		try {
		  const importedData = JSON.parse(e.target.result);
		  if(!importedData || typeof importedData !== 'object') {
			showCustomAlert("Invalid JSON data.");
			return;
		  }
		  if(!importedData.calendarData || typeof importedData.calendarData !== 'object') {
			showCustomAlert("Invalid or missing calendarData in JSON.");
			return;
		  }
		  
		  calendarData = importedData.calendarData;
		  localStorage.setItem(LS_CALENDAR_DATA_KEY, JSON.stringify(calendarData));

		  if(importedData.defaultCycle && typeof importedData.defaultCycle === 'object') {
			defaultCycleData = importedData.defaultCycle;
			localStorage.setItem(LS_DEFAULT_CYCLE_KEY, JSON.stringify(defaultCycleData));
		  } else {
			defaultCycleData = {
			  pattern: [],
			  startDate: null
			};
			localStorage.setItem(LS_DEFAULT_CYCLE_KEY, JSON.stringify(defaultCycleData));
		  }

		  if(importedData.customPresets) {
			customPresets = importedData.customPresets;
			localStorage.setItem(LS_PRESETS_KEY, JSON.stringify(customPresets));
			colorOptions = [...baseColorOptions, ...customPresets];
			
			// Add CSS for custom preset colors
			customPresets.forEach(preset => {
			  if(preset.data && preset.data.color) {
				const style = document.createElement('style');
				style.textContent = `.${preset.className} { background-color: ${preset.data.color}; }`;
				document.head.appendChild(style);
			  }
			});
			
			buildColorSwatches();
		  }

		  selectedDates.clear();
		  renderCalendar(currentYear, currentMonth);
		  updateCounters();
		  showCustomAlert("Data loaded successfully!");
		} catch(err) {
		  showCustomAlert("Failed to parse JSON file. Please ensure it's valid.");
		}
	  };
	  reader.readAsText(file);
	}

    /*
      =======================================
      =    9) Import Hevy Data from API     =
      =======================================
    */
    async function importHevyData(userApiKey) {
      try {
        document.getElementById("loadingOverlay").classList.add("active");

        // Get total workout count
        const countResponse = await fetch("https://api.hevyapp.com/v1/workouts/count", {
          method: "GET",
          headers: {
            "accept": "application/json",
            "api-key": userApiKey
          }
        });
        if (!countResponse.ok) throw new Error("Failed to fetch workout count.");
        const countData = await countResponse.json();
        const totalWorkouts = countData.workout_count;

        const pageSize = 10;
        const totalPages = Math.ceil(totalWorkouts / pageSize);
        let allWorkouts = [];

        // Fetch all workouts page by page
        for (let page = 1; page <= totalPages; page++) {
          const response = await fetch(`https://api.hevyapp.com/v1/workouts?page=${page}&pageSize=${pageSize}`, {
            method: "GET",
            headers: {
              "accept": "application/json",
              "api-key": userApiKey
            }
          });
          if (!response.ok) throw new Error("Failed to fetch workouts page " + page);
          const data = await response.json();
          if (data.workouts && Array.isArray(data.workouts)) {
            allWorkouts = allWorkouts.concat(data.workouts);
          }
        }

        let importedCount = 0;
        allWorkouts.forEach(workout => {
          let dateKey = null;

          // If workout title is in dd/mm/yyyy format, try to parse
          if (workout.title && /^(\d{1,2})\/(\d{1,2})\/(\d{4})$/.test(workout.title)) {
            const parts = workout.title.split("/");
            const dayNum = parseInt(parts[0], 10);
            const monthNum = parseInt(parts[1], 10);
            const yearNum = parseInt(parts[2], 10);
            if(yearNum >= START_YEAR && yearNum <= END_YEAR){
              dateKey = `${yearNum}-${String(monthNum).padStart(2, "0")}-${String(dayNum).padStart(2,"0")}`;
            }
          }

          // If title format was off, fall back to the actual start_time
          if(!dateKey && workout.start_time){
            const startTime = new Date(workout.start_time);
            const y = startTime.getFullYear();
            if(y >= START_YEAR && y <= END_YEAR){
              dateKey = getDateKey(startTime);
            }
          }

          if(dateKey) {
            const dayData = getDayData(dateKey);
            if (!dayData.hevyWorkouts) {
              dayData.hevyWorkouts = [];
            }
            // Avoid duplicates
            const duplicate = dayData.hevyWorkouts.some(existing => existing.id === workout.id);
            if (!duplicate) {
              dayData.hevyWorkouts.push(workout);
              dayData.completed = true; 
              setDayData(dateKey, dayData);
              importedCount++;
            }
          }
        });
		fixNullWeights();
        showCustomAlert(`Imported ${importedCount} new Hevy workouts into calendar.`);
        renderCalendar(currentYear, currentMonth);
      } catch(err) {
        console.error(err);
        showCustomAlert("An error occurred while importing Hevy data: " + err.message);
      } finally {
        document.getElementById("loadingOverlay").classList.remove("active");
      }
    }

    /*
      =======================================
      = 10) Stats Modal & 'WeightChart'      =
      =======================================
    */
    function openStatsModal() {
      document.getElementById("statsOverlay").classList.add("active");
      buildWeightChart();
    }
    function closeStatsModal() {
      document.getElementById("statsOverlay").classList.remove("active");
      if(weightChart){
        weightChart.destroy();
        weightChart = null;
      }
    }
    function buildWeightChart(){
      // Gather all date keys that have a valid weight
      const weightKeys = Object.keys(calendarData)
        .filter(k => calendarData[k].weight && parseFloat(calendarData[k].weight) > 0)
        .sort();
      if(weightKeys.length < 1){
        if(weightChart){
          weightChart.destroy();
          weightChart = null;
        }
        return;
      }
      const dataPoints = weightKeys.map(k => ({ x: k, y: parseFloat(calendarData[k].weight) }));
      const labels = weightKeys.map(k => {
        const d = parseDateKey(k);
        return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
      });
      const weights = dataPoints.map(dp => dp.y);
      const minWeight = Math.min(...weights);
      const maxWeight = Math.max(...weights);
      const suggestedMin = Math.max(0, minWeight - 1);
      const suggestedMax = maxWeight + 1;

      if(weightChart){
        weightChart.destroy();
        weightChart = null;
      }
      const ctx = document.getElementById('weightChart').getContext('2d');

      // We highlight "today" if it's in data
      const todayKey = getDateKey(new Date());
      const { bgColors, borderColors, pointRadii } = buildHighlightArrays(
        dataPoints, todayKey, '#4DAAFF', '#FFDD77', 2.5, 5
      );

      weightChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Weight (kg)',
            data: dataPoints.map(dp => dp.y),
            borderColor: '#4DAAFF',
            backgroundColor: 'rgba(77, 169, 255,0.2)',
            fill: true,
            tension: 0.1,
            pointRadius: pointRadii,
            pointBackgroundColor: bgColors,
            pointBorderColor: borderColors,
            pointHoverRadius: 6
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: { 
              title: { display: true, text: 'Date' }, 
              ticks: { color: '#ccc' }, 
              grid: { color: '#555' }
            },
            y: { 
              suggestedMin, 
              suggestedMax, 
              title: { display: true, text: 'Weight (kg)' }, 
              ticks: { color: '#ccc' }, 
              grid: { color: '#555' } 
            }
          },
          plugins: {
            legend: { labels: { color: '#eee' } }
          }
        }
      });
    }
    function buildHighlightArrays(dataPoints, highlightDateKey, normalColor, highlightColor, normalRadius=4, highlightRadius=6) {
      const bgColors = [];
      const borderColors = [];
      const pointRadii = [];

      dataPoints.forEach(dp => {
        if(dp.x === highlightDateKey) {
          bgColors.push(highlightColor);
          borderColors.push("#fff");
          pointRadii.push(highlightRadius);
        } else {
          bgColors.push(normalColor);
          borderColors.push(normalColor);
          pointRadii.push(normalRadius);
        }
      });

      return { bgColors, borderColors, pointRadii };
    }

    /*
      =======================================
      = 11) Hevy Workout Summary Modal       =
      =======================================
    */
	function openHevyModal(dateKey, returnToExerciseSummary = false) {
	  // 1) Activate the overlay
	  document.getElementById("hevyOverlay").classList.add("active");

	  // 2) Get date for display
	  const dateObj = parseDateKey(dateKey);
	  const formattedDate = `${dateObj.getDate()} ${monthNames[dateObj.getMonth()]}, ${dateObj.getFullYear()}`;

	  // 3) Grab your data and the container
	  const dayData = getDayData(dateKey);
	  const container = document.getElementById("hevyModalWorkoutDetails");
	  
	  // 4) Grab the modal element
	  const modalEl = document.getElementById("hevyModal");

	  // 5) First, remove .no-workout in case it was set previously
	  modalEl.classList.remove("no-workout");

	  // 6) Update title and add subtitle
	  document.querySelector("#hevyModal h2").textContent = "Hevy Workout Summary";
	  
	  // Check if subtitle div exists, if not create it
	  let subtitleDiv = document.querySelector("#hevyModal .modal-subtitle");
	  if (!subtitleDiv) {
		subtitleDiv = document.createElement('div');
		subtitleDiv.className = 'modal-subtitle';
		const h2 = document.querySelector("#hevyModal h2");
		h2.parentNode.insertBefore(subtitleDiv, h2.nextSibling);
	  }
	  subtitleDiv.textContent = formattedDate;

	  // 7) Check if there are no workouts
	  if (!dayData.hevyWorkouts || dayData.hevyWorkouts.length === 0) {
		modalEl.classList.add("no-workout");
		container.innerHTML = "<p>No Hevy workout data for this day.</p>";
		return;
	  }

	  // 8) Otherwise, render the normal workout summary
	  renderHevyWorkoutsToContainer(dayData.hevyWorkouts, "hevyModalWorkoutDetails", dateKey);
	  
	  // 9) Scroll the modal's content to the top
	  document.getElementById("hevyModal").scrollTop = 0;
	  // Optionally also scroll the "details" area:
	  document.getElementById("hevyModalWorkoutDetails").scrollTop = 0;
	}
    function closeHevyModal() {
      document.getElementById("hevyOverlay").classList.remove("active");
      destroyHevyProgressChart();
    }
    function destroyHevyProgressChart() {
      if(hevyProgressChart) {
        hevyProgressChart.destroy();
        hevyProgressChart = null;
      }
    }

    /*
      ================================================
      = 12) Rendering Hevy Workouts + PR Logic       =
      ================================================
    */
	function renderHevyWorkoutsToContainer(workouts, containerId, dateKey) {
	  const container = document.getElementById(containerId);
	  if (!workouts || workouts.length === 0) {
		container.innerHTML = "<p>No Hevy workout data for this day.</p>";
		return;
	  }

	  let html = "";

	  workouts.forEach(workout => {
		html += `<div class="hevy-workout">`;
		html += `<div class="hevy-workout-title">${escapeHtml(workout.title)}</div>`;

		workout.exercises.forEach(exercise => {
		  const prInfo = getGlobalPRsForExercise(exercise.title);
		  const prTypesMap = {};

		  function markPRSet(record, prLabel) {
			if (!record) return;
			const key = `${record.dateKey}_${record.workoutId}_${record.setIndex}`;
			if (!prTypesMap[key]) prTypesMap[key] = [];
			prTypesMap[key].push(prLabel);
		  }
		  markPRSet(prInfo.weightPR, "Weight PR");
		  markPRSet(prInfo.volumePR, "Volume PR");
		  markPRSet(prInfo.ormPR,    "1RM PR");

		  html += `<div class="hevy-exercise">`;
		  html += `
			<div class="hevy-exercise-title"
				 style="cursor:pointer;"
				 data-exercise="${escapeHtml(exercise.title)}">
			  ${escapeHtml(exercise.title)}
			</div>
		  `;

		  // Build the .hevy-sets
		  html += `<div class="hevy-sets">`;
		  exercise.sets.forEach((set, i) => {
			const setId = `${dateKey}_${workout.id}_${i}`;
			let setClasses = "hevy-set";
			let prLabelHtml = "";

			if (prTypesMap[setId]) {
			  setClasses += " pr-border"; // highlight border
			  // CHANGED: Build shimmering gold lines in smaller text
			  const lines = prTypesMap[setId];
			  prLabelHtml += `<div class="pr-labels">`;
			  lines.forEach(line => {
				// "pr-text" => old gold shimmer, "smaller-pr" => smaller size
				prLabelHtml += `<div class="pr-text smaller-pr">${line}</div>`;
			  });
			  prLabelHtml += `</div>`;
			}

			html += `
			  <div class="${setClasses}"
				   data-exercise="${escapeHtml(exercise.title)}"
				   data-reps="${set.reps}"
				   data-weight="${set.weight_kg}"
				   data-date-key="${dateKey}">
				
				<span class="hevy-set-weight">${set.weight_kg}kg</span>
				x
				<span class="hevy-set-reps">${set.reps}</span>

				${setClasses.includes('pr-border') ? buildStarsContainer() : ''}

				${prLabelHtml}
			  </div>
			`;
		  });
		  html += `</div>`; // .hevy-sets

		  // (unchanged: volume and 1RM lines)
		  let exerciseVolume = 0;
		  exercise.sets.forEach(s => { exerciseVolume += s.weight_kg * s.reps; });
		  html += `
			<div class="hevy-exercise-volume"
				 data-exercise="${escapeHtml(exercise.title)}"
				 data-date-key="${dateKey}">
			  Volume: ${exerciseVolume.toLocaleString()}kg
			</div>
		  `;

		  let highestOrm = 0;
		  exercise.sets.forEach(s => {
			const thisOrm = computeOrm(s.weight_kg, s.reps);
			if (thisOrm > highestOrm) highestOrm = thisOrm;
		  });
		  if (highestOrm > 0) {
			html += `
			  <div class="hevy-orm"
				   data-exercise="${escapeHtml(exercise.title)}"
				   data-date-key="${dateKey}">
				One Rep Max: ${highestOrm.toFixed(1)}kg
			  </div>
			`;
		  } else {
			html += `
			  <div class="hevy-orm"
				   data-exercise="${escapeHtml(exercise.title)}"
				   data-date-key="${dateKey}">
				One Rep Max: N/A
			  </div>
			`;
		  }

		  html += `</div>`; // .hevy-exercise
		});

		// Summaries (unchanged)
		let totalWeight = 0;
		workout.exercises.forEach(ex => {
		  ex.sets.forEach(s => { totalWeight += (s.weight_kg * s.reps); });
		});
		html += `
		  <div class="hevy-total" data-date-key="${dateKey}">
			Total Volume: ${totalWeight.toLocaleString()}kg
		  </div>
		`;

		html += `</div>`; // .hevy-workout
	  });

	  container.innerHTML = html;

	  // 7) Attach click handlers to container for sets, volumes, etc.
	  container.onclick = (e) => {
		// a) If user clicked a .hevy-set => open the combined weight+rep progression
		const setEl = e.target.closest(".hevy-set");
		if (setEl) {
		  e.stopPropagation();
		  const exerciseName = setEl.getAttribute("data-exercise");
		  const weight = Number(setEl.getAttribute("data-weight"));
		  const reps   = parseInt(setEl.getAttribute("data-reps"), 10);
		  const dKey   = setEl.getAttribute("data-date-key");
		  openExerciseProgressionModal(exerciseName, weight, reps, dKey);
		  return;
		}

		// b) If user clicked the exercise volume line => open the exercise volume chart
		const volumeEl = e.target.closest(".hevy-exercise-volume");
		if (volumeEl) {
		  e.stopPropagation();
		  const exerciseName = volumeEl.getAttribute("data-exercise");
		  const dKey = volumeEl.getAttribute("data-date-key");
		  openExerciseVolumeModal(exerciseName, dKey);
		  return;
		}

		// c) If user clicked the workout total => open daily volume chart
		const totalEl = e.target.closest(".hevy-total");
		if (totalEl) {
		  e.stopPropagation();
		  const associatedDateKey = totalEl.getAttribute("data-date-key");
		  openVolumeModal(associatedDateKey);
		  return;
		}

		// d) If user clicked the 1RM line => open 1RM progression chart
		const ormEl = e.target.closest(".hevy-orm");
		if (ormEl) {
		  e.stopPropagation();
		  const exerciseName = ormEl.getAttribute("data-exercise");
		  const dKey = ormEl.getAttribute("data-date-key");
		  openOrmProgressModal(exerciseName, dKey);
		  return;
		}

		// e) If user clicked the exercise title => open the exercise summary modal
		const exerciseTitleEl = e.target.closest(".hevy-exercise-title");
		if (exerciseTitleEl) {
		  e.stopPropagation();
		  const exerciseName = exerciseTitleEl.getAttribute("data-exercise");
		  openExerciseSummaryModal(exerciseName);
		  return;
		}
	  };
	}
	
	function buildStarsContainer() {
		  // Single star path
		  const starSVG = `
			<svg viewBox="0 0 784.11 815.53">
			  <path 
				d="M392.05 0c-20.9,210.08 -184.06,378.41 
						  -392.05,407.78 207.96,29.37 371.12,197.68 392.05,407.74
						  20.93,-210.06 184.09,-378.37 392.05,-407.74
						  -207.98,-29.38 -371.16,-197.69 -392.06,-407.78z"
				class="fil0"/>
			</svg>
		  `;
		  
		  let html = `<div class="stars-container">`;
		  for (let i = 1; i <= 10; i++) {
			html += `
			  <div class="star-${i}">
				${starSVG}
			  </div>
			`;
		  }
		  html += `</div>`;
		  return html;
	}
	
	function getGlobalPRsForExercise(exerciseName) {
	  let weightPR = null;  // will store a record { dateKey, workoutId, setIndex, weight, reps, volume, orm }
	  let volumePR = null;
	  let ormPR    = null;
	  // Loop over all days in calendarData
	  for (const dateKey of Object.keys(calendarData)) {
		const dayObj = calendarData[dateKey];
		if (!dayObj.hevyWorkouts) continue;

		// Loop each workout
		dayObj.hevyWorkouts.forEach(workout => {
		  // Loop each exercise
		  workout.exercises.forEach((ex) => {
			if (ex.title !== exerciseName) return;
			// We found the exercise, now check each set
			ex.sets.forEach((set, idx) => {
			  const setVolume = set.weight_kg * set.reps;
			  const setOrm    = computeOrm(set.weight_kg, set.reps);

			  // We'll build a "record" with enough info to identify and compare
			  const record = {
				dateKey,
				workoutId: workout.id,
				setIndex: idx,
				weight: set.weight_kg,
				reps: set.reps,
				volume: setVolume,
				orm: setOrm
			  };
			  // 1) Check if it‚Äôs the new Weight PR
			  if (!weightPR) {
				weightPR = record;
			  } else {
				if (record.weight > weightPR.weight) {
				  weightPR = record;
				} else if (record.weight === weightPR.weight) {
				  // Tiebreaker: compare weight*reps
				  const currentWR = record.weight * record.reps;
				  const bestWR    = weightPR.weight * weightPR.reps;
				  if (currentWR > bestWR) {
					weightPR = record;
				  }
				  // If still tied, keep the older (no change)
				}
			  }
			  // 2) Check if it‚Äôs the new Volume PR
			  if (!volumePR) {
				volumePR = record;
			  } else {
				if (record.volume > volumePR.volume) {
				  volumePR = record;
				}
				// If tied, keep the first encountered => do nothing
			  }
			  // 3) Check if it‚Äôs the new 1RM PR
			  if (!ormPR) {
				ormPR = record;
			  } else {
				if (record.orm > ormPR.orm) {
				  ormPR = record;
				}
				// If tied, keep the first encountered => do nothing
			  }
			});
		  });
		});
	  }
	  return {
		weightPR,
		volumePR,
		ormPR
	  };
	}

    /*
      ================================================
      = 13) Unified Weight & Rep Progress Modal      =
      ================================================
    */
	let currentProgressionExercise = null;
	let currentProgressionWeight = null;
	let currentProgressionReps = null;
	let currentProgressionDateKey = null;
	let currentExerciseVolumeName = null;
	let currentExerciseVolumeDateKey = null;
	
    function destroyExerciseWeightProgressChart() {
      if(exerciseWeightProgressionChart) {
        exerciseWeightProgressionChart.destroy();
        exerciseWeightProgressionChart = null;
      }
    }
    function destroyExerciseRepProgressChart() {
      if(exerciseRepProgressionChart) {
        exerciseRepProgressionChart.destroy();
        exerciseRepProgressionChart = null;
      }
    }

    function openExerciseProgressionModal(exerciseName, weight, reps, dateKey) {
	  document.querySelectorAll('#exerciseProgressionModal .date-range-btn').forEach(btn => {
		btn.classList.toggle('active', btn.getAttribute('data-range') === 'year');
	  });
	  currentProgressionExercise = exerciseName;
      currentProgressionWeight = weight;
      currentProgressionReps = reps;
      currentProgressionDateKey = dateKey;
      const dateObj = parseDateKey(dateKey);
      const dateLabel = `${dateObj.getDate()} ${monthNames[dateObj.getMonth()]}, ${dateObj.getFullYear()}`;
      document.getElementById("exerciseProgressionModalDate").textContent = dateLabel;

      document.getElementById("exerciseProgressOverlay").classList.add("active");

      buildExerciseWeightProgressChart(exerciseName, reps, dateKey);
      buildExerciseRepProgressChart(exerciseName, weight, dateKey);
    }
    function closeExerciseProgressModal() {
      document.getElementById("exerciseProgressOverlay").classList.remove("active");
      destroyExerciseWeightProgressChart();
      destroyExerciseRepProgressChart();
    }

    // Weight progression at a fixed rep count
    function buildExerciseWeightProgressChart(exerciseName, repCount, highlightDateKey) {
      const selectedRange = document.querySelector('#exerciseProgressionModal .date-range-btn.active').getAttribute('data-range');
      const refDate = parseDateKey(highlightDateKey);
      const { start, end } = getDateRangeBounds(selectedRange, refDate);
      
      const dateKeys = Object.keys(calendarData)
        .filter(key => {
          const date = parseDateKey(key);
          return date >= start && date <= end;
        })
        .sort();
      const dataMap = {};

      // Collect max weight (for the given repCount) on each date
      dateKeys.forEach(k => {
        const dayObj = calendarData[k];
        if (dayObj.hevyWorkouts && dayObj.hevyWorkouts.length > 0) {
          let maxWeightForThatDay = 0;
          dayObj.hevyWorkouts.forEach(workout => {
            workout.exercises.forEach(ex => {
              if (ex.title === exerciseName) {
                ex.sets.forEach(s => {
                  if (s.reps === repCount && s.weight_kg > maxWeightForThatDay) {
                    maxWeightForThatDay = s.weight_kg;
                  }
                });
              }
            });
          });
          if (maxWeightForThatDay > 0) {
            dataMap[k] = maxWeightForThatDay;
          }
        }
      });

      const chartKeys = Object.keys(dataMap).sort();
      if (chartKeys.length < 1) {
        destroyExerciseWeightProgressChart();
        showCustomAlert("No weight progression data found for that set.");
        return;
      }

      const dataPoints = chartKeys.map(k => ({ x: k, y: dataMap[k] }));
      const labels = chartKeys.map(k => {
        const d = parseDateKey(k);
        return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
      });
      const weights = dataPoints.map(dp => dp.y);
      const minWeight = Math.min(...weights);
      const maxWeight = Math.max(...weights);
      const suggestedMin = Math.max(0, minWeight - 1);
      const suggestedMax = maxWeight + 1;

      destroyExerciseWeightProgressChart();
      const ctx = document.getElementById('exerciseWeightProgressionChart').getContext('2d');

      const { bgColors, borderColors, pointRadii } = buildHighlightArrays(
        dataPoints, highlightDateKey, '#4DAAFF', '#FFDD77', 2.5, 5
      );

      exerciseWeightProgressionChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: `${exerciseName} (${repCount} reps)`,
            data: dataPoints.map(dp => dp.y),
            borderColor: '#4DAAFF',
            backgroundColor: 'rgba(77, 169, 255,0.2)',
            fill: true,
            tension: 0.1,
            pointRadius: pointRadii,
            pointBackgroundColor: bgColors,
            pointBorderColor: borderColors,
            pointHoverRadius: 6
          }]
        },
        options: {
			layout: {
		  padding: {
			top: 0,
			bottom: 0,
			left: 0,
			right: 0,
		  }
		},
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              title: { display: true, text: 'Date' },
              ticks: { color: '#ccc' },
              grid: { color: '#555' }
            },
            y: {
              suggestedMin,
              suggestedMax,
              title: { display: true, text: 'Weight (kg)' },
              ticks: { color: '#ccc' },
              grid: { color: '#555' }
            }
          },
          plugins: {
            legend: { 
				labels: { color: '#eee' },
				padding: {
				top: 1,
				bottom: 1
			  }
			},
            title: {
              display: true,
              text: `Weight progression at ${repCount} reps`,
              color: '#fff',
              font: { size: 16 },
			  padding: {
			  top: 1,
			  bottom: 1
			  }
            }
          }
        }
      });
    }

    // Rep progression at a fixed weight
    function buildExerciseRepProgressChart(exerciseName, weight, highlightDateKey) {
      const selectedRange = document.querySelector('#exerciseProgressionModal .date-range-btn.active').getAttribute('data-range');
      const refDate = parseDateKey(highlightDateKey);
      const { start, end } = getDateRangeBounds(selectedRange, refDate);
      
      const dateKeys = Object.keys(calendarData)
        .filter(key => {
          const date = parseDateKey(key);
          return date >= start && date <= end;
        })
        .sort();
      const dataMap = {};

      // Collect max reps (for the given weight) on each date
      dateKeys.forEach(k => {
        const dayObj = calendarData[k];
        if (dayObj.hevyWorkouts && dayObj.hevyWorkouts.length > 0) {
          let maxRepForThatDay = 0;
          dayObj.hevyWorkouts.forEach(workout => {
            workout.exercises.forEach(ex => {
              if (ex.title === exerciseName) {
                ex.sets.forEach(s => {
                  if (Number(s.weight_kg) === Number(weight) && s.reps > maxRepForThatDay) {
                    maxRepForThatDay = s.reps;
                  }
                });
              }
            });
          });
          if (maxRepForThatDay > 0) {
            dataMap[k] = maxRepForThatDay;
          }
        }
      });

      const chartKeys = Object.keys(dataMap).sort();
      if (chartKeys.length < 1) {
        destroyExerciseRepProgressChart();
        showCustomAlert("No rep progression data found for that set.");
        return;
      }

      const dataPoints = chartKeys.map(k => ({ x: k, y: dataMap[k] }));
      const labels = chartKeys.map(k => {
        const d = parseDateKey(k);
        return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
      });
      const reps = dataPoints.map(dp => dp.y);
      const minRep = Math.min(...reps);
      const maxRep = Math.max(...reps);
      const suggestedMin = Math.max(0, minRep - 1);
      const suggestedMax = maxRep + 1;

      destroyExerciseRepProgressChart();
      const ctx = document.getElementById('exerciseRepProgressionChart').getContext('2d');

      const { bgColors, borderColors, pointRadii } = buildHighlightArrays(
        dataPoints, highlightDateKey, '#FFDD77', '#4DAAFF', 2.5, 5
      );

      exerciseRepProgressionChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: `Repetitions: ${exerciseName} (${weight}kg)`,
            data: dataPoints.map(dp => dp.y),
            borderColor: '#FFDD77',
            backgroundColor: 'rgba(255, 221, 119,0.2)',
            fill: true,
            tension: 0.1,
            pointRadius: pointRadii,
            pointBackgroundColor: bgColors,
            pointBorderColor: borderColors,
            pointHoverRadius: 6
          }]
        },
        options: {
			layout: {
		  padding: {
			top: 0,
			bottom: 0,
			left: 0,
			right: 0,
		  }
		},
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              title: { display: true, text: 'Date' },
              ticks: { color: '#ccc' },
              grid: { color: '#555' }
            },
            y: {
              suggestedMin,
              suggestedMax,
              title: { display: true, text: 'Repetitions' },
              ticks: { color: '#ccc' },
              grid: { color: '#555' }
            }
          },
          plugins: {
            legend: { 
				labels: { color: '#eee' } ,
				padding: {
				top: 1,
				bottom: 1
			  }
			},
            title: {
              display: true,
              text: `Rep progression at ${weight} KG`,
              color: '#fff',
              font: { size: 16 },
			  padding: {
				top: 1,
				bottom: 1
			  }
            }
          }
        }
      });
    }

    /*
      =======================================
      = 14) Volume Over Time (Day-Level)    =
      =======================================
    */
	function openVolumeModal(dateKey) {
	  // Default range = year
	  const modalRangeBtns = document.querySelectorAll('#volumeModal .date-range-btn');
	  modalRangeBtns.forEach(btn => {
		btn.classList.toggle('active', btn.getAttribute('data-range') === 'year');
	  });

	  currentVolumeDateKey = dateKey;
	  document.getElementById("volumeOverlay").classList.add("active");
	  buildVolumeChart(dateKey);
	}
    function closeVolumeModal() {
      document.getElementById("volumeOverlay").classList.remove("active");
      if(volumeChart){
        volumeChart.destroy();
        volumeChart = null;
      }
    }
	function buildVolumeChart(highlightDateKey) {
	  // 1) Figure out which date-range button is active in the Volume modal
	  const selectedRangeBtn = document.querySelector('#volumeModal .date-range-btn.active');
	  const selectedRange = selectedRangeBtn ? selectedRangeBtn.getAttribute('data-range') : 'year';

	  // 2) Convert highlightDateKey ‚Üí Date ‚Üí get date bounds
	  const refDate = parseDateKey(highlightDateKey);
	  const { start, end } = getDateRangeBounds(selectedRange, refDate);

	  // 3) Filter calendarData to find only days in-range
	  //    that also have at least 1 Hevy workout.
	  const dateKeys = Object.keys(calendarData)
		.filter(k => {
		  const d = parseDateKey(k);
		  const inRange = (d >= start && d <= end);
		  const hasHevy = calendarData[k].hevyWorkouts && calendarData[k].hevyWorkouts.length > 0;
		  return inRange && hasHevy;
		})
		.sort();

	  // 4) Build data points (date ‚Üí total volume)
	  const dataPoints = dateKeys.map(k => {
		let volume = 0;
		const day = calendarData[k];
		day.hevyWorkouts.forEach(w => {
		  w.exercises.forEach(ex => {
			ex.sets.forEach(set => {
			  volume += set.weight_kg * set.reps;
			});
		  });
		});
		return { x: k, y: volume };
	  });

	  // If no data points at all
	  if (dataPoints.length < 1) {
		showCustomAlert("No volume data found.");
		return;
	  }

	  // 5) Build arrays for Chart.js
	  const labels = dataPoints.map(dp => {
		const d = parseDateKey(dp.x);
		return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
	  });
	  const volumes = dataPoints.map(dp => dp.y);
	  const minVolume = Math.min(...volumes);
	  const maxVolume = Math.max(...volumes);
	  const suggestedMin = Math.max(0, minVolume - 10);
	  const suggestedMax = maxVolume + 10;

	  // Destroy old chart if exists
	  if (volumeChart) {
		volumeChart.destroy();
		volumeChart = null;
	  }

	  // 6) Create a new Chart.js line chart
	  const ctx = document.getElementById('volumeChart').getContext('2d');
	  const { bgColors, borderColors, pointRadii } = buildHighlightArrays(
		dataPoints, // array of { x, y }
		highlightDateKey, 
		'#4DAAFF', // normal color
		'#FFDD77',           // highlight color
		2.5,                 // normal radius
		5                    // highlight radius
	  );

	  volumeChart = new Chart(ctx, {
		type: 'line',
		data: {
		  labels: labels,
		  datasets: [{
			label: 'Volume (kg)',
			data: volumes, // or dataPoints.map(dp => dp.y)
			borderColor: '#4DAAFF',
			backgroundColor: 'rgba(77, 170, 255,0.2)',
			fill: true,
			tension: 0.1,
			pointRadius: pointRadii,
			pointBackgroundColor: bgColors,
			pointBorderColor: borderColors,
			pointHoverRadius: 4
		  }]
		},
		options: {
		  responsive: true,
		  maintainAspectRatio: false,
		  scales: {
			x: {
			  title: { display: true, text: 'Date' },
			  ticks: { color: '#ccc' },
			  grid: { color: '#555' }
			},
			y: {
			  suggestedMin,
			  suggestedMax,
			  title: { display: true, text: 'Volume (kg)' },
			  ticks: { color: '#ccc' },
			  grid: { color: '#555' }
			}
		  },
		  plugins: {
			legend: { labels: { color: '#eee' } }
		  }
		}
	  });
	}


    /*
      =======================================
      = 15) Per-Exercise Volume Chart       =
      =======================================
    */
	function openExerciseVolumeModal(exerciseName, dateKey) {
	  // 1) Set default date range button to "Year"
	  const modalRangeBtns = document.querySelectorAll('#exerciseVolumeModal .date-range-btn');
	  modalRangeBtns.forEach(btn => {
		btn.classList.toggle('active', btn.getAttribute('data-range') === 'year');
	  });

	  // 2) Store these in our new global variables
	  currentExerciseVolumeName = exerciseName;
	  currentExerciseVolumeDateKey = dateKey;

	  // 3) Show the overlay
	  document.getElementById("exerciseVolumeOverlay").classList.add("active");

	  // 4) Build (or rebuild) the chart with default range
	  buildExerciseVolumeProgressionChart(exerciseName, dateKey);
	}
    function closeExerciseVolumeModal() {
      document.getElementById("exerciseVolumeOverlay").classList.remove("active");
      destroyExerciseVolumeChart();
    }
    function destroyExerciseVolumeChart() {
      if(exerciseVolumeChart) {
        exerciseVolumeChart.destroy();
        exerciseVolumeChart = null;
      }
    }
	function buildExerciseVolumeProgressionChart(exerciseName, highlightDateKey) {
	  // 1) Which date-range button is active in the Exercise Volume modal?
	  const selectedRangeBtn = document.querySelector('#exerciseVolumeModal .date-range-btn.active');
	  const selectedRange = selectedRangeBtn ? selectedRangeBtn.getAttribute('data-range') : 'year';

	  // 2) Convert highlightDateKey ‚Üí Date ‚Üí get date bounds
	  const refDate = parseDateKey(highlightDateKey);
	  const { start, end } = getDateRangeBounds(selectedRange, refDate);

	  // 3) Filter dateKeys by date range
	  const dateKeys = Object.keys(calendarData)
		.filter(k => {
		  const d = parseDateKey(k);
		  return d >= start && d <= end;
		})
		.sort();

	  // 4) Build a map of date => total volume for this exercise
	  const dataMap = {};
	  dateKeys.forEach(k => {
		const dayObj = calendarData[k];
		if (dayObj.hevyWorkouts && dayObj.hevyWorkouts.length > 0) {
		  let exerciseVolume = 0;
		  dayObj.hevyWorkouts.forEach(workout => {
			workout.exercises.forEach(ex => {
			  if (ex.title === exerciseName) {
				ex.sets.forEach(s => {
				  exerciseVolume += (s.weight_kg * s.reps);
				});
			  }
			});
		  });
		  if (exerciseVolume > 0) {
			dataMap[k] = exerciseVolume;
		  }
		}
	  });

	  // 5) If no data points found, exit
	  const chartKeys = Object.keys(dataMap).sort();
	  if (chartKeys.length < 1) {
		destroyExerciseVolumeChart();
		document.getElementById("exerciseVolumeOverlay").classList.remove("active");
		showCustomAlert(`No volume data found for '${exerciseName}'.`);
		return;
	  }

	  // 6) Build final arrays for Chart.js
	  const dataPoints = chartKeys.map(k => ({ x: k, y: dataMap[k] }));
	  const labels = chartKeys.map(k => {
		const d = parseDateKey(k);
		return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
	  });

	  const volumes = dataPoints.map(dp => dp.y);
	  const minV = Math.min(...volumes);
	  const maxV = Math.max(...volumes);
	  const range = maxV - minV;
	  const pad = range * 0.1;
	  const suggestedMin = (minV - pad < 0) ? 0 : (minV - pad);
	  const suggestedMax = maxV + pad;

	  // Destroy old chart if it exists
	  destroyExerciseVolumeChart();

	  // 7) Build the new Chart.js line chart
	  const ctx = document.getElementById('exerciseVolumeChart').getContext('2d');
	  const { bgColors, borderColors, pointRadii } = buildHighlightArrays(
		dataPoints, 
		highlightDateKey,
		'#4DAAFF', // normal color
		'#FFDD77',           // highlight color
		2.5,
		5
	  );

	  exerciseVolumeChart = new Chart(ctx, {
		type: 'line',
		data: {
		  labels: labels,
		  datasets: [{
			label: `Volume: ${exerciseName}`,
			data: volumes,
			borderColor: '#4DAAFF',
			backgroundColor: 'rgba(77, 170, 255,0.2)',
			fill: true,
			tension: 0.1,
			pointRadius: pointRadii,
			pointBackgroundColor: bgColors,
			pointBorderColor: borderColors,
			pointHoverRadius: 6
		  }]
		},
		options: {
		  responsive: true,
		  maintainAspectRatio: false,
		  scales: {
			x: {
			  title: { display: true, text: 'Date' },
			  ticks: { color: '#ccc' },
			  grid: { color: '#555' }
			},
			y: {
			  suggestedMin,
			  suggestedMax,
			  title: { display: true, text: 'Exercise Volume (kg)' },
			  ticks: { color: '#ccc' },
			  grid: { color: '#555' }
			}
		  },
		  plugins: {
			legend: { labels: { color: '#eee' } }
		  }
		}
	  });
	}


    /*
      =======================================
      = 16) ORM Progress Over Time Chart    =
      =======================================
    */
    function openOrmProgressModal(exerciseName, dateKey) {
	// Reset date range to "Year"
	document.querySelectorAll('#exerciseOrmProgressModal .date-range-btn').forEach(btn => {
		btn.classList.toggle('active', btn.getAttribute('data-range') === 'year');
    });
      currentOrmExercise = exerciseName;
      currentOrmDateKey = dateKey;
      document.getElementById("ormProgressOverlay").classList.add("active");
      buildExerciseOrmProgressChart(exerciseName, dateKey);
    }
    function closeOrmProgressModal() {
      document.getElementById("ormProgressOverlay").classList.remove("active");
      destroyOrmProgressChart();
    }
    function destroyOrmProgressChart() {
      if(exerciseOrmProgressChart) {
        exerciseOrmProgressChart.destroy();
        exerciseOrmProgressChart = null;
      }
    }
    // Variables to store current ORM exercise info
	let currentOrmExercise = null;
	let currentOrmDateKey = null;

	function buildExerciseOrmProgressChart(exerciseName, highlightDateKey) {
	  // Figure out which date range to display
	  const selectedRange = document.querySelector('#exerciseOrmProgressModal .date-range-btn.active').getAttribute('data-range');
	  const refDate = parseDateKey(highlightDateKey);
	  const { start, end } = getDateRangeBounds(selectedRange, refDate);

	  // Collect only the date keys that fall within (start..end)
	  const dateKeys = Object.keys(calendarData)
		.filter(key => {
		  const date = parseDateKey(key);
		  return date >= start && date <= end;
		})
		.sort();

	  // dataMap is now an object that stores { orm, bestWeight, bestReps }
	  const dataMap = {};

	  // We'll store the best (weight, reps) that produced the highest ORM each day
	  dateKeys.forEach(k => {
		let dayMaxOrm = 0;
		let bestSet = null; // to store { weight, reps } for that day's best set

		const dayObj = calendarData[k];
		if (dayObj.hevyWorkouts) {
		  dayObj.hevyWorkouts.forEach(workout => {
			workout.exercises.forEach(ex => {
			  if (ex.title === exerciseName) {
				ex.sets.forEach(s => {
				  const setOrm = computeOrm(s.weight_kg, s.reps);
				  if (setOrm > dayMaxOrm) {
					dayMaxOrm = setOrm;
					bestSet = { weight: s.weight_kg, reps: s.reps };
				  }
				});
			  }
			});
		  });
		}

		// Only record if the day's best ORM > 0
		if (dayMaxOrm > 0 && bestSet) {
		  dataMap[k] = {
			orm: dayMaxOrm,
			bestWeight: bestSet.weight,
			bestReps: bestSet.reps
		  };
		}
	  });

	  // If no data points, exit
	  const chartKeys = Object.keys(dataMap).sort();
	  if (chartKeys.length < 1) {
		destroyOrmProgressChart();
		document.getElementById("ormProgressOverlay").classList.remove("active");
		showCustomAlert(`No ORM data found for '${exerciseName}'.`);
		return;
	  }

	  // Build arrays for Chart.js
	  // We'll keep the numeric ORMs in dataPoints,
	  // and remember that 'chartKeys[index]' can retrieve the metadata from dataMap.
	  const dataPoints = chartKeys.map(k => dataMap[k].orm);

	  // Build the user-facing labels (display dates)
	  const labels = chartKeys.map(k => {
		const d = parseDateKey(k);
		return d.toLocaleDateString('en-US', {
		  month: 'short',
		  day: 'numeric',
		  year: 'numeric'
		});
	  });

	  // Figure out suggestedMin / suggestedMax for Y-axis
	  const orms = dataPoints;
	  const minOrm = Math.min(...orms);
	  const maxOrm = Math.max(...orms);
	  const range = maxOrm - minOrm;
	  const pad = range * 0.1;
	  const suggestedMin = (minOrm - pad < 0) ? 0 : (minOrm - pad);
	  const suggestedMax = maxOrm + pad;

	  // destroy old chart if it exists
	  destroyOrmProgressChart();

	  // get canvas context
	  const ctx = document.getElementById('exerciseOrmProgressChart').getContext('2d');

	  // build highlight arrays for the chart
	  const { bgColors, borderColors, pointRadii } = buildHighlightArrays(
		chartKeys.map(k => ({ x: k, y: dataMap[k].orm })), // pass array of { x, y }
		highlightDateKey,
		'#4DAAFF',
		'#FFDD77',
		2.5,
		5
	  );

	  // Provide a custom tooltip callback to show weight x reps
	  exerciseOrmProgressChart = new Chart(ctx, {
		type: 'line',
		data: {
		  labels: labels,
		  datasets: [{
			label: `ORM: ${exerciseName}`,
			data: dataPoints, // numeric ORM values
			borderColor: '#4DAAFF',
			backgroundColor: 'rgba(77, 170, 255,0.2)',
			fill: true,
			tension: 0.1,
			pointRadius: pointRadii,
			pointBackgroundColor: bgColors,
			pointBorderColor: borderColors,
			pointHoverRadius: 6
		  }]
		},
		options: {
		  responsive: true,
		  maintainAspectRatio: false,
		  scales: {
			x: {
			  title: { display: true, text: 'Date' },
			  ticks: { color: '#ccc' },
			  grid: { color: '#555' }
			},
			y: {
			  suggestedMin,
			  suggestedMax,
			  title: { display: true, text: 'Estimated 1RM (kg)' },
			  ticks: { color: '#ccc' },
			  grid: { color: '#555' }
			}
		  },
		  plugins: {
			legend: {
			  labels: { color: '#eee' }
			},
			tooltip: {
			  callbacks: {
				// Top line in tooltip
				title: function(tooltipItems) {
				  // Typically tooltipItems is array of points; we use the first
				  return tooltipItems[0].label; // e.g. "Jan 10, 2025"
				},
				// Second line(s) in tooltip
				label: function(context) {
				  // The dataIndex points to whichever day we hovered
				  const i = context.dataIndex;
				  const dateKey = chartKeys[i]; // e.g. "2025-01-10"
				  const info = dataMap[dateKey]; // { orm, bestWeight, bestReps }

				  // Build lines
				  const ormText = `ORM: ${info.orm.toFixed(1)}kg`;
				  const setText = `(${info.bestWeight}kg x ${info.bestReps})`;
				  // Return an array => multiple lines in the tooltip
				  return [ormText, setText];
				}
			  }
			}
		  }
		}
	  });
	}

    /*
      =======================================
      = 17) Populate Calendar Button        =
      =======================================
      Only applies to the *currentYear*.
    */
	function populateEntireCalendar() {
	 // Turn the currently selectedDates into a cycle pattern
	 // We'll then fill out *only the current year* from Jan 1 to Dec 31
	 const cycleDataArray = Array.from(selectedDates).sort();
	 if(cycleDataArray.length < 2){
	   showCustomAlert("Select at least two days to create a cycle pattern.");
	   return;
	 }

	 // Check for consecutive days
	 const firstDate = parseDateKey(cycleDataArray[0]);
	 const lastDate = parseDateKey(cycleDataArray[cycleDataArray.length - 1]);
	 const daysBetween = Math.floor((lastDate - firstDate) / MS_IN_DAY) + 1;
	 
	 if(daysBetween !== cycleDataArray.length) {
	   showCustomAlert("Selected days must be consecutive with no gaps.");
	   return;
	 }

	 const sortedCycle = cycleDataArray.map(k => parseDateKey(k)).sort((a,b) => a - b);
	 const sortedCycleKeys = sortedCycle.map(d => getDateKey(d));
	 const cyclePattern = sortedCycleKeys.map(k => ({ ...getDayData(k) }));
	 const patternLength = cyclePattern.length;
	 const startDate = new Date(sortedCycle[0].getTime());

	 // We'll only overwrite the currentYear
	 const firstOfYear = new Date(currentYear, 0, 1);
	 const lastOfYear = new Date(currentYear, 11, 31);

	 // Step 1: Fill backwards within currentYear
	 let currentDate = new Date(startDate.getTime());
	 let cycleIndex = cyclePattern.length;
	 while(currentDate >= firstOfYear) {
	   currentDate.setDate(currentDate.getDate() -1);
	   cycleIndex = (cycleIndex -1 + patternLength) % patternLength;
	   if(currentDate < firstOfYear) break;
	   const dateKey = getDateKey(currentDate);
	   const cycleData = cyclePattern[cycleIndex];
	   calendarData[dateKey] = {
		 shiftClass: cycleData.shiftClass,
		 gym: cycleData.gym,
		 gymTime: cycleData.gymTime,
		 workTime: cycleData.workTime,
		 completed: cycleData.completed,
		 weight: cycleData.weight,
		 alert: cycleData.alert,
		 hevyWorkouts: cycleData.hevyWorkouts ? [...cycleData.hevyWorkouts] : []
	   };
	 }

	 // Step 2: Fill forwards within currentYear
	 currentDate = new Date(startDate.getTime());
	 cycleIndex = 0;
	 while(currentDate <= lastOfYear) {
	   const dateKey = getDateKey(currentDate);
	   const cycleData = cyclePattern[cycleIndex % cyclePattern.length];
	   calendarData[dateKey] = {
		 shiftClass: cycleData.shiftClass,
		 gym: cycleData.gym,
		 gymTime: cycleData.gymTime,
		 workTime: cycleData.workTime,
		 completed: cycleData.completed,
		 weight: cycleData.weight,
		 alert: cycleData.alert,
		 hevyWorkouts: cycleData.hevyWorkouts ? [...cycleData.hevyWorkouts] : []
	   };
	   cycleIndex++;
	   currentDate.setDate(currentDate.getDate() + 1);
	   if(currentDate > lastOfYear) break;
	 }

	 // We'll store that cycle as the default pattern
	 defaultCycleData = {
	   pattern: [...cyclePattern],
	   startDate: getDateKey(sortedCycle[0])
	 };
	 localStorage.setItem(LS_DEFAULT_CYCLE_KEY, JSON.stringify(defaultCycleData));
	 localStorage.setItem(LS_CALENDAR_DATA_KEY, JSON.stringify(calendarData));

	 selectedDates.clear();
	 renderCalendar(currentYear, currentMonth);
	 showCustomAlert("Current year's calendar has been populated with your custom cycle.");
	}
    function updatePopulateCalendarButtonState() {
      const btn = document.getElementById("populateCalendarBtn");
      if(selectedDates.size >=2){
        btn.disabled = false;
        btn.style.opacity = "1";
        btn.style.border = "2px solid gold";
      }
      else{
        btn.disabled = true;
        btn.style.opacity = "0.5";
        btn.style.border = "2px solid #555";
      }
    }

    /*
      =======================================
      =    Clear Calendar Function          =
      =======================================
    */
	function clearCalendar() {
	  showCustomConfirm("Are you sure you want to clear the entire calendar? This will remove all your data and set all days to 'None'. This action cannot be undone.", () => {
		// Clear calendar data
		for(let year = START_YEAR; year <= END_YEAR; year++) {
		  const startDate = new Date(year, 0, 1);
		  const endDate = new Date(year, 11, 31);
		  const totalDays = Math.floor((endDate - startDate) / MS_IN_DAY) + 1;

		  for(let i = 0; i < totalDays; i++) {
			const currentDate = new Date(startDate.getTime() + i * MS_IN_DAY);
			const dateKey = getDateKey(currentDate);
			calendarData[dateKey] = {
			  shiftClass: "off-bg",
			  gym: "None",
			  gymTime: "",
			  workTime: "",
			  completed: false,
			  weight: null,
			  alert: null,
			  hevyWorkouts: []
			};
		  }
		}

		// Clear presets
		customPresets = [];
		localStorage.setItem(LS_PRESETS_KEY, JSON.stringify(customPresets));
		colorOptions = [...baseColorOptions];

		localStorage.setItem(LS_CALENDAR_DATA_KEY, JSON.stringify(calendarData));
		defaultCycleData = { pattern: [], startDate: null };
		localStorage.setItem(LS_DEFAULT_CYCLE_KEY, JSON.stringify(defaultCycleData));

		selectedDates.clear();
		buildColorSwatches(); // Rebuild swatches to reflect cleared presets
		renderCalendar(currentYear, currentMonth);
		showCustomAlert("Calendar has been cleared. All days are now set to 'None'.");
	  });
	}

    /*
      =======================================
      =  Custom Alert/Prompt/Confirm        =
      =======================================
    */
    function showCustomAlert(message) {
      const overlay = document.getElementById("customAlertOverlay");
      const messageElem = document.getElementById("customAlertMessage");
      const inputElem = document.getElementById("customAlertInput");
      const confirmButtons = document.getElementById("customConfirmButtons");
      const defaultButton = document.getElementById("customDefaultButton");

      messageElem.textContent = message;
      inputElem.style.display = "none";
      confirmButtons.style.display = "none";
      defaultButton.style.display = "block";

      overlay.classList.add("active");
    }
    function showCustomConfirm(message, onConfirm) {
      const overlay = document.getElementById("customAlertOverlay");
      const messageElem = document.getElementById("customAlertMessage");
      const inputElem = document.getElementById("customAlertInput");
      const confirmButtons = document.getElementById("customConfirmButtons");
      const defaultButton = document.getElementById("customDefaultButton");

      messageElem.textContent = message;
      inputElem.style.display = "none";
      confirmButtons.style.display = "flex";
      defaultButton.style.display = "none";

      // Remove old buttons if any
      const existingYes = document.getElementById("customYesBtn");
      const existingNo = document.getElementById("customNoBtn");
      if(existingYes) existingYes.remove();
      if(existingNo) existingNo.remove();

      const yesButton = document.createElement("button");
      yesButton.id = "customYesBtn";
      yesButton.textContent = "Yes";
      yesButton.onclick = () => {
        overlay.classList.remove("active");
        onConfirm();
      };

      const noButton = document.createElement("button");
      noButton.id = "customNoBtn";
      noButton.textContent = "No";
      noButton.onclick = () => {
        overlay.classList.remove("active");
      };

      confirmButtons.appendChild(yesButton);
      confirmButtons.appendChild(noButton);
      overlay.classList.add("active");
    }
    function showCustomPrompt(message, placeholder, callback) {
      const overlay = document.getElementById("customAlertOverlay");
      const messageElem = document.getElementById("customAlertMessage");
      const inputElem = document.getElementById("customAlertInput");
      const confirmButtons = document.getElementById("customConfirmButtons");
      const defaultButton = document.getElementById("customDefaultButton");

      messageElem.textContent = message;
      inputElem.style.display = "block";
      inputElem.placeholder = placeholder || "";
      confirmButtons.style.display = "flex";
      defaultButton.style.display = "none";

      // Remove old buttons if any
      const existingYes = document.getElementById("customYesBtn");
      const existingNo = document.getElementById("customNoBtn");
      if(existingYes) existingYes.remove();
      if(existingNo) existingNo.remove();

      const yesButton = document.createElement("button");
      yesButton.id = "customYesBtn";
      yesButton.textContent = "OK";
      yesButton.onclick = () => {
        const inputVal = inputElem.value.trim();
        overlay.classList.remove("active");
        callback(inputVal);
      };

      const noButton = document.createElement("button");
      noButton.id = "customNoBtn";
      noButton.textContent = "Cancel";
      noButton.onclick = () => {
        overlay.classList.remove("active");
      };

      confirmButtons.appendChild(yesButton);
      confirmButtons.appendChild(noButton);

      inputElem.value = "";
      overlay.classList.add("active");
    }
    function closeCustomAlert() {
      const overlay = document.getElementById("customAlertOverlay");
      const messageElem = document.getElementById("customAlertMessage");
      const inputElem = document.getElementById("customAlertInput");
      const confirmButtons = document.getElementById("customConfirmButtons");
      const defaultButton = document.getElementById("customDefaultButton");

      const yesBtn = document.getElementById("customYesBtn");
      const noBtn = document.getElementById("customNoBtn");
      if(yesBtn) yesBtn.remove();
      if(noBtn) noBtn.remove();

      messageElem.textContent = "";
      inputElem.style.display = "none";
      confirmButtons.style.display = "none";
      defaultButton.style.display = "block";

      overlay.classList.remove("active");
    }
	/*
      =====================================
      = 19) Exercise Summary Modal        =
      =====================================
    */
	function openExerciseSummaryModal(exerciseName) {
	  document.getElementById("exerciseSummaryOverlay").classList.add("active");
	  
	  const content = document.getElementById("exerciseSummaryContent");
	  const stats = getExerciseStats(exerciseName);
	  
	  let html = `
		<div class="exercise-summary-header">
		  ${escapeHtml(exerciseName)}
		  <button class="compare-button" 
          style="margin: auto;"
          onclick="openExerciseHistoryModal('${escapeHtml(exerciseName)}')">
			Exercise History
		  </button>
		</div>

		<div class="key-stats-grid">
		  <div class="key-stat" data-date="${stats.heaviestWeightDate}">
			<div class="key-stat-label">Heaviest Weight</div>
			<div class="key-stat-value">${stats.heaviestWeight}kg</div>
		  </div>
		  <div class="key-stat" data-date="${stats.bestOrmDate}">
			<div class="key-stat-label">Estimated 1RM</div>
			<div class="key-stat-value glowing-orm">${stats.bestOrm.toFixed(1)}kg</div>
		  </div>
		  <div class="key-stat">
			<div class="key-stat-label">Exercise Frequency</div>
			<div class="key-stat-value">${stats.totalOccurrences}</div>
		  </div>
		  <div class="key-stat" data-date="${stats.bestSetVolumeDate}">
			<div class="key-stat-label">Best Set Volume</div>
			<div class="key-stat-value">${stats.bestSetDetails.weight}kg √ó ${stats.bestSetDetails.reps}</div>
		  </div>
		  <div class="key-stat" data-date="${stats.bestSessionVolumeDate}">
			<div class="key-stat-label">Best Session Volume</div>
			<div class="key-stat-value">${stats.bestSessionVolume.toLocaleString()}kg</div>
		  </div>
		  <div class="key-stat">
			<div class="key-stat-label">Total Volume</div>
			<div class="key-stat-value">${stats.totalVolume.toLocaleString()}kg</div>
		  </div>
		</div>

		<div class="exercise-stat-block">
		  <div class="exercise-stat-title">Best Weight by Rep Range</div>
		  <div class="rep-range-list">`;
	  
	  const sortedReps = Object.keys(stats.repRanges).map(Number).sort((a, b) => a - b);
	  
	  sortedReps.forEach(reps => {
		const data = stats.repRanges[reps];
		const isOrmSet = computeOrm(data.weight, reps) === stats.bestOrm;
		html += `
		  <div class="rep-range-row" data-date="${data.date}">
			<span class="rep-range-count">${reps} reps</span>
			<span class="rep-range-weight ${isOrmSet ? 'glowing-orm' : ''}">${data.weight}kg</span>
		  </div>
		`;
	  });
	  
	  html += '</div></div>';
	  
	  content.innerHTML = html;

	  // Add click handlers
	  // For frequency stat
	  const frequencyStats = content.querySelector('.key-stat:nth-child(3)');
	  if (frequencyStats) {
		frequencyStats.addEventListener('click', () => openExerciseFrequencyModal(exerciseName));
	  }

	  // For date-linked stats
	  content.querySelectorAll('[data-date]').forEach(element => {
		element.addEventListener('click', () => {
		  const date = element.getAttribute('data-date');
		  if (date) {
			// Convert the date to our date key format (YYYY-MM-DD)
			const dateObj = new Date(date);
			const dateKey = getDateKey(dateObj);
			openHevyModal(dateKey);
			closeExerciseSummaryModal();
		  }
		});
	  });
	  const totalVolumeStats = content.querySelector('.key-stat:nth-child(6)'); // Sixth key-stat is total volume
		if (totalVolumeStats) {
		  totalVolumeStats.addEventListener('click', () => openTotalVolumeDistributionModal());
		}
	}

	function closeExerciseSummaryModal() {
	  document.getElementById("exerciseSummaryOverlay").classList.remove("active");
	}

	function getExerciseStats(exerciseName) {
	  let totalOccurrences = 0;
	  let heaviestWeight = 0;
	  let heaviestWeightDate = null;
	  let bestOrm = 0;
	  let bestOrmDate = null;
	  let bestSetVolume = 0;
	  let bestSetVolumeDate = null;
	  let bestSetDetails = null;
	  let bestSessionVolume = 0;
	  let bestSessionVolumeDate = null;
	  let totalVolume = 0;
	  
	  // Initialize repRanges as empty object
	  const repRanges = {};
	  
	  // First pass: Go through all workouts to build rep ranges
	  Object.values(calendarData).forEach(dayData => {
		if (dayData.hevyWorkouts) {
		  dayData.hevyWorkouts.forEach(workout => {
			let sessionVolume = 0;
			
			workout.exercises.forEach(exercise => {
			  if (exercise.title === exerciseName) {
				totalOccurrences++;
				
				exercise.sets.forEach(set => {
				  const reps = set.reps;
				  const weight = set.weight_kg;
				  const setVolume = weight * reps;
				  
				  // Initialize rep range if it doesn't exist
				  if (!repRanges[reps]) {
					repRanges[reps] = {
					  weight: 0,
					  date: null
					};
				  }
				  
				  // Update rep range if this weight is higher
				  if (weight > repRanges[reps].weight) {
					repRanges[reps] = {
					  weight: weight,
					  date: workout.start_time
					};
				  }
				  
				  // Track best set volume
				  if (setVolume > bestSetVolume) {
					bestSetVolume = setVolume;
					bestSetVolumeDate = workout.start_time;
					bestSetDetails = { weight, reps };
				  }
				  
				  // Track heaviest weight
				  if (weight > heaviestWeight) {
					heaviestWeight = weight;
					heaviestWeightDate = workout.start_time;
				  }

				  // Track best ORM
				  const orm = computeOrm(weight, reps);
				  if (orm > bestOrm) {
					bestOrm = orm;
					bestOrmDate = workout.start_time;
				  }
				  
				  sessionVolume += setVolume;
				  totalVolume += setVolume;
				});
			  }
			});
			
			// Track best session
			if (sessionVolume > bestSessionVolume) {
			  bestSessionVolume = sessionVolume;
			  bestSessionVolumeDate = workout.start_time;
			}
		  });
		}
	  });
	  
	  return { 
		totalOccurrences, 
		repRanges,
		heaviestWeight,
		heaviestWeightDate,
		bestOrm,
		bestOrmDate,
		bestSetVolume,
		bestSetVolumeDate,
		bestSetDetails,
		bestSessionVolume,
		bestSessionVolumeDate,
		totalVolume
	  };
	}
	// EXERCISE HISTORY Modal
	function openExerciseHistoryModal(exerciseName) {
	  // Activate the modal overlay
	  document.getElementById("exerciseHistoryOverlay").classList.add("active");
	  document.getElementById("exerciseHistorySubheader").textContent = exerciseName;
	  // Get the content container and clear previous content
	  const content = document.getElementById("exerciseHistoryContent");
	  content.innerHTML = '';
	  
	  // Get all historical sessions for this exercise
	  const sessions = getAllSessionsForExercise(exerciseName);
	  
	  let html = '';
	  
	  // Build HTML for each session
	  sessions.forEach(session => {
		const formattedDate = session.date.toLocaleDateString('en-US', {
		  year: 'numeric',
		  month: 'long',
		  day: 'numeric'
		});
		
		html += `
		  <div class="exercise-history-entry">
			<div class="exercise-history-date">${formattedDate}</div>
			<div class="hevy-sets exercise-history-sets">
		`;
		
		// Add sets with PR detection
		session.exercise.sets.forEach((set, index) => {
		  const prInfo = getSetPRInfo(set, session.exercise.title, session.dateKey, session.workout.id, index);
		  const prClass = prInfo.isPR ? 'pr-border' : '';
		  const prLabels = prInfo.labels.length > 0 ? `
			<div class="pr-labels">
			  ${prInfo.labels.map(label => `<div class="pr-text smaller-pr">${label}</div>`).join('')}
			</div>
		  ` : '';
		  
		  html += `
			<div class="hevy-set ${prClass}" 
				 data-exercise="${escapeHtml(session.exercise.title)}"
				 data-reps="${set.reps}"
				 data-weight="${set.weight_kg}"
				 data-date-key="${session.dateKey}">
			  <span class="hevy-set-weight">${set.weight_kg}kg</span>
			  x
			  <span class="hevy-set-reps">${set.reps}</span>
			  ${prInfo.isPR ? buildStarsContainer() : ''}
			  ${prLabels}
			</div>
		  `;
		});
		
		html += `
			</div>
		  </div>
		`;
	  });

	  // Handle empty state
	  if (sessions.length === 0) {
		html = '<p style="text-align: center; color: #888; padding: 2rem;">No historical data found for this exercise.</p>';
	  }

	  // Insert generated HTML
	  content.innerHTML = html;

	  // Add click handlers for sets
	  content.addEventListener('click', (e) => {
		const setEl = e.target.closest('.hevy-set');
		if (setEl) {
		  const exerciseName = setEl.dataset.exercise;
		  const weight = parseFloat(setEl.dataset.weight);
		  const reps = parseInt(setEl.dataset.reps, 10);
		  const dateKey = setEl.dataset.dateKey;
		  openExerciseProgressionModal(exerciseName, weight, reps, dateKey);
		}
	  });

	  // Add close handler
	  document.getElementById("exerciseHistoryCloseBtn").addEventListener("click", closeExerciseHistoryModal);

	  // Scroll to top
	  content.scrollTop = 0;
	}

	function closeExerciseHistoryModal() {
	  document.getElementById("exerciseHistoryOverlay").classList.remove("active");
	}

	// Add to existing getSetPRInfo function (if not exists, create it)
	function getSetPRInfo(set, exerciseName, dateKey, workoutId, setIndex) {
	  const prInfo = {
		isPR: false,
		labels: []
	  };
	  
	  const globalPRs = getGlobalPRsForExercise(exerciseName);
	  const setDate = parseDateKey(dateKey);
	  
	  // Check weight PR
	  if (set.weight_kg === globalPRs.weightPR?.weight && 
		  setDate.getTime() === parseDateKey(globalPRs.weightPR.dateKey).getTime() &&
		  workoutId === globalPRs.weightPR.workoutId &&
		  setIndex === globalPRs.weightPR.setIndex) {
		prInfo.isPR = true;
		prInfo.labels.push('Weight PR');
	  }
	  
	  // Check volume PR
	  const setVolume = set.weight_kg * set.reps;
	  if (setVolume === globalPRs.volumePR?.volume && 
		  setDate.getTime() === parseDateKey(globalPRs.volumePR.dateKey).getTime() &&
		  workoutId === globalPRs.volumePR.workoutId &&
		  setIndex === globalPRs.volumePR.setIndex) {
		prInfo.isPR = true;
		prInfo.labels.push('Volume PR');
	  }
	  
	  // Check ORM PR
	  const setORM = computeOrm(set.weight_kg, set.reps);
	  if (setORM === globalPRs.ormPR?.orm && 
		  setDate.getTime() === parseDateKey(globalPRs.ormPR.dateKey).getTime() &&
		  workoutId === globalPRs.ormPR.workoutId &&
		  setIndex === globalPRs.ormPR.setIndex) {
		prInfo.isPR = true;
		prInfo.labels.push('1RM PR');
	  }
	  
	  return prInfo;
	}
	
	
	/*
      =======================================
      = 20) Exercise Frequency Modal        =
      =======================================
    */
	function getAllExerciseFrequencies() {
	  const frequencies = {};
	  
	  Object.values(calendarData).forEach(dayData => {
		if (dayData.hevyWorkouts) {
		  dayData.hevyWorkouts.forEach(workout => {
			workout.exercises.forEach(exercise => {
			  frequencies[exercise.title] = (frequencies[exercise.title] || 0) + 1;
			});
		  });
		}
	  });
	  
	  // Convert to array and sort by frequency
	  return Object.entries(frequencies)
		.map(([name, count]) => ({ name, count }))
		.sort((a, b) => b.count - a.count);
	}

	function openExerciseFrequencyModal(selectedExercise) {
	  document.getElementById("exerciseFrequencyOverlay").classList.add("active");
	  
	  const frequencies = getAllExerciseFrequencies();
	  
	  // Prepare data for Chart.js
	  const labels = frequencies.map(f => f.name);
	  const data = frequencies.map(f => f.count);
	  const backgroundColor = labels.map(label => 
		label === selectedExercise ? '#FFDD77' : '#4DAAFF'
	  );
	  
	  if (exerciseFrequencyChart) {
		exerciseFrequencyChart.destroy();
	  }
	  
	  const ctx = document.getElementById('exerciseFrequencyChart').getContext('2d');
	  exerciseFrequencyChart = new Chart(ctx, {
		type: 'bar',
		data: {
		  labels: labels,
		  datasets: [{
			data: data,
			backgroundColor: backgroundColor,
			borderColor: backgroundColor,
			borderWidth: 1
		  }]
		},
		options: {
		  responsive: true,
		  maintainAspectRatio: false,
		  plugins: {
			legend: {
			  display: false
			},
			title: {
			  display: true,
			  text: '',
			  color: '#fff',
			  font: { size: 16 }
			}
		  },
		  scales: {
			y: {
			  beginAtZero: true,
			  title: {
				display: true,
				text: 'Frequency',
				color: '#ccc'
			  },
			  ticks: { color: '#ccc' },
			  grid: { color: '#555' }
			},
			x: {
			  ticks: { 
				color: '#ccc',
				maxRotation: 45,
				minRotation: 45
			  },
			  grid: { color: '#555' }
			}
		  }
		}
	  });
	}

	function closeExerciseFrequencyModal() {
	  document.getElementById("exerciseFrequencyOverlay").classList.remove("active");
	  if (exerciseFrequencyChart) {
		exerciseFrequencyChart.destroy();
		exerciseFrequencyChart = null;
	  }
	}
	
	function getExerciseVolumeTotals() {
	  const volumeTotals = {};
	  
	  Object.values(calendarData).forEach(dayData => {
		if (dayData.hevyWorkouts) {
		  dayData.hevyWorkouts.forEach(workout => {
			workout.exercises.forEach(exercise => {
			  const exerciseName = exercise.title;
			  if (!volumeTotals[exerciseName]) {
				volumeTotals[exerciseName] = 0;
			  }
			  
			  exercise.sets.forEach(set => {
				volumeTotals[exerciseName] += set.weight_kg * set.reps;
			  });
			});
		  });
		}
	  });
	  
	  // Convert to array and sort by volume
	  return Object.entries(volumeTotals)
		.map(([name, volume]) => ({ name, volume }))
		.sort((a, b) => b.volume - a.volume);
	}
	/*
      =========================================
      = 21) Total Volume Distribution Modal   =
      =========================================
    */
	
	let lastDistributionData = null; // store the main data vs. "others" data for re-draws

	function openTotalVolumeDistributionModal(selectedExercise = null) {
	  // 1) Show the overlay
	  document.getElementById("totalVolumeDistributionOverlay").classList.add("active");
	  
	  // 2) Gather volume data for all exercises
	  const volumeData = getExerciseVolumeTotals(); 
	  // e.g. volumeData: [{ name: "Bench Press", volume: 12345 }, { name: "Squat", volume: 23456 }, ...]

	  // (Optional) Sort descending, so largest is first
	  volumeData.sort((a, b) => b.volume - a.volume);
	  
	  // 3) Compute total volume across all exercises
	  const grandTotal = volumeData.reduce((sum, item) => sum + item.volume, 0);

	  // 4) Show total weight in the modal
	  const distributionModal = document.getElementById("totalVolumeDistributionModal");
	  let totalWeightElem = distributionModal.querySelector("#grandTotalWeight");
	  if (!totalWeightElem) {
		totalWeightElem = document.createElement("div");
		totalWeightElem.id = "grandTotalWeight";
		totalWeightElem.style.cssText = `
		  font-size: 1rem;
		  text-align: center;
		  color: #FFDD77;
		  margin-bottom: 0.75rem;
		  font-weight: 600;
		`;
		distributionModal.insertBefore(totalWeightElem, distributionModal.querySelector(".modal-row"));
	  }
	  totalWeightElem.textContent = `Total Weight Lifted: ${grandTotal.toLocaleString()} kg`;

	  // 5) Prepare labels and data arrays
	  const labels = volumeData.map(d => d.name);
	  const data = volumeData.map(d => d.volume);

	  // 6) Build color array from the 24 shift-time colors
	  const shiftColorKeys = Object.keys(workTimeColors).sort();  // ["0000","0100",...,"2300"]
	  const shiftColorVals = shiftColorKeys.map(k => workTimeColors[k]); // array of hex codes
	  const colorCount = shiftColorVals.length;
	  
	  const backgroundColors = labels.map((_, i) => {
		return shiftColorVals[i % colorCount];
	  });

	  // 7) Determine slice offsets to pop out the selected exercise
	  const offsetArray = new Array(labels.length).fill(0);
	  if (selectedExercise) {
		const highlightIndex = labels.findIndex(label => label === selectedExercise);
		if (highlightIndex >= 0) {
		  offsetArray[highlightIndex] = 30; // bigger offset for that slice
		}
	  }

	  // 8) Destroy old chart if needed
	  if (totalVolumeDistributionChart) {
		totalVolumeDistributionChart.destroy();
		totalVolumeDistributionChart = null;
	  }
	  
	  // 9) Build the new Donut chart
	  const ctx = document.getElementById("totalVolumeDistributionChart").getContext("2d");
	  totalVolumeDistributionChart = new Chart(ctx, {
		type: "doughnut",
		data: {
		  labels: labels,
		  datasets: [{
			data: data,
			backgroundColor: backgroundColors,
			borderWidth: 1,   // remove outline
			spacing: 1,       // smaller gap between slices
			offset: offsetArray
		  }]
		},
		options: {
		  responsive: true,
		  rotation: 0,
		  maintainAspectRatio: false,
		  cutout: "50%", // donut hole size
		  plugins: {
			legend: {
			  position: "right",
			  labels: {
				color: "#eee",
				padding: 10,
				font: { size: 11 }
			  }
			},
			tooltip: {
			  callbacks: {
				label: function(context) {
				  const value = context.raw;
				  const total = context.dataset.data.reduce((a, b) => a + b, 0);
				  const percentage = ((value / total) * 100).toFixed(1);
				  return `${context.label}: ${value.toLocaleString()}kg (${percentage}%)`;
				}
			  }
			},
			title: {
			  display: true,
			  text: "",
			  color: "#FFDD77",
			  font: { size: 16, weight: "bold" },
			  padding: { top: 10, bottom: 20 }
			}
		  }
		}
	  });
	}

	/**
	 * Closes the Total Volume Distribution Modal & destroys the chart.
	 */
	function closeTotalVolumeDistributionModal() {
	  document.getElementById("totalVolumeDistributionOverlay").classList.remove("active");
	  if (totalVolumeDistributionChart) {
		totalVolumeDistributionChart.destroy();
		totalVolumeDistributionChart = null;
	  }
	}
	
    /*
      =======================================
      = 22) DOM Loaded: Event Setup         =
      =======================================
    */
	window.addEventListener("DOMContentLoaded", () => {
	  // Add this at the very start of the function
	  const styleSheet = document.createElement('style');
	  baseColorOptions.concat(customPresets).forEach(option => {
		if (option.data && option.data.color) {
		  styleSheet.textContent += `.${option.className} { background-color: ${option.data.color}; }`;
		}
	  });
	  document.head.appendChild(styleSheet);
	  buildColorSwatches();

      // Single modal
      document.getElementById("singleSaveBtn").addEventListener("click", saveSingleModal);
      document.getElementById("singleRevertBtn").addEventListener("click", revertSingleModal);
      document.getElementById("singleCancelBtn").addEventListener("click", closeSingleModal);
      document.querySelectorAll("#singleModal .reset-emoji").forEach(btn => {
        btn.addEventListener("click", () => { resetSingleField(btn.getAttribute("data-field")); });
      });

      // Multi modal
      document.getElementById("multiKeySelect").addEventListener("change", handleMultiKeyChange);
      document.getElementById("multiSaveBtn").addEventListener("click", saveMultiModal);
      document.getElementById("multiRevertBtn").addEventListener("click", revertMultiModal);
      document.getElementById("multiCancelBtn").addEventListener("click", closeMultiModal);
	  
	  // Frequency modal
	  document.getElementById("exerciseFrequencyCloseBtn").addEventListener("click", closeExerciseFrequencyModal);

      // Stats
      document.getElementById("statsBtn").addEventListener("click", openStatsModal);
      document.getElementById("statsCloseBtn").addEventListener("click", closeStatsModal);

      // Backup
      document.getElementById("saveDataBtn").addEventListener("click", saveData);
      document.getElementById("loadDataBtn").addEventListener("click", () => {
        document.getElementById("importFileInput").click();
      });
      document.getElementById("importFileInput").addEventListener("change", (event) => {
        const file = event.target.files[0];
        if(file) {
          showCustomConfirm("Loading data will overwrite your current calendar data. Proceed?", () => {
            loadData(file);
          });
        }
        event.target.value = "";
      });

      // Hevy import
      document.getElementById("hevyImportBtn").addEventListener("click", () => {
        showCustomPrompt("Enter your Hevy API key:", "API Key", (apiKey) => {
          if(apiKey){
            importHevyData(apiKey);
          } else {
            showCustomAlert("Hevy API key is required to import data.");
          }
        });
      });

      // Populate calendar
      document.getElementById("populateCalendarBtn").addEventListener("click", () => {
        showCustomConfirm("Populate the current year with the selected cycle? This will overwrite existing data in that year for those days.", () => {
          populateEntireCalendar();
        });
      });

      // Hevy summary modal
      document.getElementById("hevyCloseBtn").addEventListener("click", closeHevyModal);

      // Volume chart modal
      document.getElementById("volumeCloseBtn").addEventListener("click", closeVolumeModal);

      // Exercise volume chart modal
      document.getElementById("exerciseVolumeCloseBtn").addEventListener("click", closeExerciseVolumeModal);

      // Combined progression modal
      document.getElementById("exerciseProgressCloseBtn").addEventListener("click", closeExerciseProgressModal);
	  
	  // Total Volume Distribution Modal
	  document.getElementById("totalVolumeDistributionCloseBtn").addEventListener("click", closeTotalVolumeDistributionModal);
	  
	  document.addEventListener('click', (e) => {
        const rangeBtn = e.target.closest('.date-range-btn');
        if (rangeBtn && !rangeBtn.classList.contains('active')) {
          // Update active state
          document.querySelectorAll('.date-range-btn').forEach(btn => btn.classList.remove('active'));
          rangeBtn.classList.add('active');
          
          // Rebuild charts with new range if we have current progression data
          if (currentProgressionExercise && currentProgressionDateKey) {
            buildExerciseWeightProgressChart(
              currentProgressionExercise,
              currentProgressionReps,
              currentProgressionDateKey
            );
            buildExerciseRepProgressChart(
              currentProgressionExercise,
              currentProgressionWeight,
              currentProgressionDateKey
            );
          }
        }
      });
	  
	  document.getElementById("volumeModal").addEventListener("click", (e) => {
	  const rangeBtn = e.target.closest(".date-range-btn");
	  if (!rangeBtn) return;

	  if (rangeBtn.classList.contains("active")) return;

	  // Toggle active state
	  document.querySelectorAll("#volumeModal .date-range-btn")
		.forEach(btn => btn.classList.remove("active"));
	  rangeBtn.classList.add("active");

	  // Rebuild the volume chart
	  if (currentVolumeDateKey) {
		buildVolumeChart(currentVolumeDateKey);
	  }
	});

	// ORM progress modal
	document.getElementById("ormProgressCloseBtn").addEventListener("click", closeOrmProgressModal);
		  
	// ORM date range button handlers
	document.getElementById("exerciseOrmProgressModal").addEventListener('click', (e) => {
	  const ormRangeBtn = e.target.closest('.date-range-btn');
	  if (ormRangeBtn && !ormRangeBtn.classList.contains('active')) {
		// Update active state
		document.querySelectorAll('#exerciseOrmProgressModal .date-range-btn')
		  .forEach(btn => btn.classList.remove('active'));
		ormRangeBtn.classList.add('active');
		
		// Rebuild ORM chart with new range if we have current data
		if (currentOrmExercise && currentOrmDateKey) {
		  buildExerciseOrmProgressChart(currentOrmExercise, currentOrmDateKey);
		}
	  }
	});
	
	document.getElementById("exerciseVolumeModal").addEventListener("click", (e) => {
	  const rangeBtn = e.target.closest(".date-range-btn");
	  if (!rangeBtn) return;

	  // If it‚Äôs already active, do nothing
	  if (rangeBtn.classList.contains("active")) return;

	  // Otherwise, remove active from all, then set active on the clicked one
	  document.querySelectorAll("#exerciseVolumeModal .date-range-btn")
		.forEach(btn => btn.classList.remove("active"));
	  rangeBtn.classList.add("active");

	  // Rebuild the chart using the newly selected range
	  if (currentExerciseVolumeName && currentExerciseVolumeDateKey) {
		buildExerciseVolumeProgressionChart(currentExerciseVolumeName, currentExerciseVolumeDateKey);
	  }
	});

      // Clear Calendar
      document.getElementById("clearCalendarBtn").addEventListener("click", clearCalendar);

      // Help
      document.getElementById("helpBtn").addEventListener("click", () => {
        showCustomAlert("Help feature is coming soon!");
      });

      // Calendar cell selection (click & drag)
      document.addEventListener("mousedown", (e) => {
        // If overlay or a button is clicked, skip
        if(document.querySelector(".overlay.active")) return;
        if(e.target.closest("button")) return;

        // Middle mouse => open Hevy
        if (e.button === 1) {
          e.preventDefault();
          const dayCell = e.target.closest(".day-cell");
          if (dayCell) {
            const dateKey = dayCell.getAttribute("data-date-key");
            if (dateKey) {
              openHevyModal(dateKey);
            }
          }
          return;
        }

        if(e.target.closest(".refresh-emoji") || e.target.closest(".completed-badge")) return;
        e.preventDefault();

        const dayCell = e.target.closest(".day-cell");
        if(!dayCell){
          selectedDates.clear();
          renderCalendar(currentYear, currentMonth);
          return;
        }
        isDragging = true;

        if(!e.ctrlKey && !e.metaKey){
          selectedDates.clear();
        }

        const startRow = parseInt(dayCell.getAttribute("data-row"), 10);
        const startCol = parseInt(dayCell.getAttribute("data-col"), 10);
        const dateKey = dayCell.getAttribute("data-date-key");
        if(dateKey) selectedDates.add(dateKey);
        renderCalendar(currentYear, currentMonth);

        const mouseMoveHandler = (moveEvent) => {
          if(!isDragging) return;
          const cell = moveEvent.target.closest(".day-cell");
          if(cell){
            const row = parseInt(cell.getAttribute("data-row"), 10);
            const col = parseInt(cell.getAttribute("data-col"), 10);
            const minRow = Math.min(startRow, row);
            const maxRow = Math.max(startRow, row);
            const minCol = Math.min(startCol, col);
            const maxCol = Math.max(startCol, col);

            if(!moveEvent.ctrlKey && !moveEvent.metaKey){
              selectedDates.clear();
            }
            const allCells = document.querySelectorAll(".calendar-grid .day-cell");
            allCells.forEach(c => {
              const r = parseInt(c.getAttribute("data-row"), 10);
              const cc = parseInt(c.getAttribute("data-col"), 10);
              if(r >= minRow && r <= maxRow && cc >= minCol && cc <= maxCol){
                const dk = c.getAttribute("data-date-key");
                if(dk) selectedDates.add(dk);
              }
            });
            renderCalendar(currentYear, currentMonth);
          }
        };
        const mouseUpHandler = () => {
          isDragging = false;
          document.removeEventListener("mousemove", mouseMoveHandler);
          document.removeEventListener("mouseup", mouseUpHandler);
        };
        document.addEventListener("mousemove", mouseMoveHandler);
        document.addEventListener("mouseup", mouseUpHandler);
      });
	  
	document.addEventListener("keydown", (e) => {
	  // Check if user pressed 'h' or 'H'
	  if (e.key === "h" || e.key === "H") {
		// Check if any overlay (modal) is active
		const anyOverlayActive = document.querySelector(".overlay.active");
		if (anyOverlayActive) {
		  // If a modal is already open, do nothing
		  return;
		}

		// Only proceed if exactly one date is selected
		if (selectedDates.size === 1) {
		  const [dateKey] = [...selectedDates];
		  openHevyModal(dateKey);
		} else {
		  showCustomAlert("You must have exactly one day cell selected to open the Hevy summary with the H key.");
		}
	  }
	});
	
	document.getElementById("exerciseSummaryCloseBtn").addEventListener("click", closeExerciseSummaryModal);
	document.getElementById("exerciseHistoryCloseBtn").addEventListener("click", closeExerciseHistoryModal);
      // Finally, initial render:
      renderCalendar(currentYear, currentMonth);
    });
	
	
  </script>
</body>
</html>
