<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>2025 Calendar (Refactored + Hevy Chart)</title>

  <!-- Include Chart.js from a CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700;900&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html, body {
      height: 100%;
      width: 100%;
      background: #1E1E1E;
      color: #EAEAEA;
      font-family: 'Montserrat', sans-serif;
      user-select: none; /* Prevent text selection on entire page */
    }
    body {
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .main-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 800px;
      padding: 1rem;
    }

    /* Month Bar */
    .month-bar {
      display: flex;
      flex-direction: row;
      align-items: center;
      margin-bottom: 1rem;
      width: 100%;
      justify-content: center;
    }
    .month-title {
      font-size: 1.1rem;
      font-weight: 700;
      padding: 0.2rem 0.5rem;
      width: 140px;
      text-align: center;
      white-space: nowrap;
    }
    .arrow-buttons {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      margin-left: 2rem;
    }
    .month-nav-buttons {
      display: inline-flex;
      gap: 0.5rem;
    }
    .data-buttons {
      display: inline-flex;
      gap: 0.5rem;
      margin-left: 1.5rem;
      align-items: center;
    }
    .arrow-button {
      background-color: #333;
      border: 1px solid #555;
      color: #EAEAEA;
      cursor: pointer;
      font-size: 1rem;
      min-width: 2rem;
      height: 2rem;
      border-radius: 4px;
      text-align: center;
      line-height: 2rem;
      padding: 0 0.5rem;
      transition: background-color 0.2s, border 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .arrow-button:hover {
      background-color: #444;
    }
    .arrow-button:disabled {
      background-color: #555;
      cursor: not-allowed;
      opacity: 0.5;
    }

    .arrow-button img {
      vertical-align: middle;
      display: inline-block;
      position: relative;
      top: -1px; /* Adjust this value as needed to center the icon */
    }

    /* Calendar Layout */
    .calendar-container {
      width: 100%;
      max-width: 700px;
    }
    .calendar-header,
    .calendar-grid {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 0.3rem;
    }
    .calendar-header div {
      text-align: center;
      font-weight: bold;
      padding: 0.5rem 0;
      border-bottom: 1px solid #444;
      font-size: 0.85rem;
    }
    .calendar-grid {
      margin-top: 0.5rem;
    }

    /* Day Cell */
    .day-cell {
      aspect-ratio: 1 / 1;
      border-radius: 2px;
      position: relative;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s ease-in-out;
      padding: 0.5rem;
    }
    .day-cell:hover {
      outline: 2px solid #888;
    }
    .faded {
      opacity: 0.15;
      pointer-events: none;
    }
    .morning-bg    { background-color: #FFAD66; }
    .late-day-bg   { background-color: #CC8A52; }
    .afternoon-bg  { background-color: #7AB6D9; }
    .evening-bg    { background-color: #4F7EAA; }
    .night-bg      { background-color: #5C4EA2; }
    .off-bg        { background-color: #3A3A3A; }
    .al-bg         { background-color: #616161; }
    .custom-shift  { /* Custom dynamic background (if needed) */ }
    .selected {
      outline: 2px solid limegreen !important;
    }
    .today {
      outline: 3px solid #FFD700;
    }

    /* Date & Icons */
    .date-num {
      position: absolute;
      top: 4px;
      left: 6px;
      font-weight: bold;
      font-size: 0.75rem;
      color: rgba(255,255,255,0.8);
      white-space: nowrap;
      pointer-events: none;
    }
    .refresh-emoji {
      position: absolute;
      top: 4px;
      right: 6px;
      font-size: 1rem;
      z-index: 3;
      cursor: pointer;
      opacity: 0.15;
      transition: opacity 0.2s;
    }
    .refresh-emoji:hover {
      opacity: 1.0;
    }

    /* Extra info overlays */
    .weight-display {
      position: absolute;
      top: 42%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 0.9rem;
      text-align: center;
      white-space: nowrap;
      color: #FFF;
      font-weight: bold;
      pointer-events: none;
    }
    .shift-time-text {
      position: absolute;
      top: 60%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 1rem;
      font-weight: bold;
      white-space: nowrap;
      color: rgba(0, 0, 0, 0.3);
      pointer-events: none;
    }
    .free-time-text {
      position: absolute;
      top: 10%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 0.65rem;
      font-weight: bold;
      white-space: nowrap;
      color: rgba(0, 0, 0, 0.3);
      pointer-events: none;
    }
    .workout-info {
      position: absolute;
      bottom: 4px;
      left: 0;
      right: 0;
      text-align: center;
      font-size: 0.75rem;
      line-height: 1.1;
      color: #FFF;
      opacity: 0.75;
      pointer-events: none;
    }

    /* Completed Badge */
    .completed-badge {
      position: absolute;
      bottom: 4px;
      right: 4px;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background-color: #28a745;
      color: #fff;
      font-size: 1rem;
      text-align: center;
      line-height: 24px;
      box-shadow: 0 0 5px rgba(0,0,0,0.5);
      cursor: pointer;
      user-select: none;
      transition: opacity 0.2s ease-out, transform 0.2s ease-out;
      opacity: 0;
    }
    .day-cell:hover .completed-badge:not(.enabled) {
      opacity: 0.3;
    }
    .day-cell.completed .completed-badge.enabled {
      opacity: 1.0;
    }
    .completed-badge:hover {
      transform: scale(1.1);
      opacity: 1.0;
    }

    /* Alert Feature */
    .alert-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 50%;
      z-index: 2;
      pointer-events: none;
    }
    .alert-text {
      position: absolute;
      top: 1.2rem;
      left: 0;
      right: 0;
      margin: 0 auto;
      width: 80%;
      text-align: center;
      font-size: 0.65rem;
      font-weight: bold;
      color: #fff;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.6);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      z-index: 3;
      pointer-events: none;
    }

    /* Overlays and Modals */
    .overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.6);
      z-index: 999;
      justify-content: center;
      align-items: center;
    }
    .overlay.active {
      display: flex;
    }
    .modal {
      position: relative; /* For positioning modal-date if needed */
      background: #2D2D2D;
      padding: 1.5rem;
      border-radius: 6px;
      width: 420px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.7);
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    .modal-date {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 0.9rem;
      color: #ccc;
    }
    .modal h2 {
      font-size: 1.2rem;
      margin-bottom: 0.5rem;
      text-align: center;
    }
    .modal-row {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }
    .modal-row label {
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .reset-emoji {
      cursor: pointer;
      opacity: 0.6;
      transition: opacity 0.2s;
      font-size: 1rem;
    }
    .reset-emoji:hover {
      opacity: 1.0;
    }
    .modal-row select, 
    .modal-row input[type=text] {
      width: 100%;
      padding: 0.3rem;
      border: 1px solid #555;
      background: #444;
      color: #EAEAEA;
      border-radius: 4px;
      font-size: 0.85rem;
    }
    .modal-buttons {
      display: flex;
      justify-content: space-between;
      gap: 1rem;
      margin-top: 0.5rem;
    }
    .modal-buttons button {
      flex: 1;
      cursor: pointer;
      padding: 0.5rem;
      font-size: 0.9rem;
      border: 1px solid #555;
      border-radius: 4px;
      background: #444;
      color: #EAEAEA;
      transition: background-color 0.2s;
    }
    .modal-buttons button:hover {
      background: #555;
    }
    .color-swatches {
      display: flex;
      flex-wrap: nowrap;
      gap: 0.5rem;
      overflow-x: auto;
    }
    .swatch {
      width: 32px;
      height: 32px;
      border-radius: 4px;
      cursor: pointer;
      border: 2px solid transparent;
      flex: 0 0 auto;
    }
    .swatch.active {
      border-color: limegreen;
    }
    .shift-label-text {
      color: #f0f0f0;
      font-weight: bold;
    }

    /* Stats Counters Text */
    .counter-value {
      color: #77DD77;
      font-weight: bold;
    }
    .stats-summary {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      margin-bottom: 1rem;
    }
    .stat-item {
      font-size: 1.1rem;
      color: #77DD77;
      margin-bottom: 0.5rem;
    }
    #weightChart, #exerciseWeightProgressionChart, #exerciseRepProgressionChart, #volumeChart {
      width: 100%;
      height: 250px;
    }

    /* Pulse Animation (generic) */
    @keyframes pulseEffect {
      0% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(255, 255, 0, 0.5);
      }
      50% {
        transform: scale(1.03);
        box-shadow: 0 0 8px 4px rgba(255, 255, 0, 0.25);
      }
      100% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(255, 255, 0, 0);
      }
    }
    .cell-pulse {
      animation: pulseEffect 0.8s ease-out;
    }

    /* Gold PR Border (no pulse) */
    .pr-border {
      border: 2px solid gold;
    }

    /* Hevy Workout Blocks */
    .hevy-workout {
      margin-bottom: 1.5rem;
    }
    .hevy-workout:last-child {
      margin-bottom: 0;
    }
    .hevy-workout-title {
      font-size: 1.1rem;
      font-weight: bold;
      color: white;
      margin-bottom: 0.5rem;
    }
    .hevy-exercise {
      margin-bottom: 1rem;
      padding: 0.5rem;
      background: #2D2D2D;
      border-radius: 4px;
      position: relative;
    }
    .hevy-exercise-title {
      font-weight: bold;
      color: #EAEAEA;
      margin-bottom: 0.5rem;
      display: flex;
      align-items: center;
    }
    .hevy-sets {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      gap: 0.5rem;
    }
    .hevy-set {
      background: #444;
      padding: 0.4rem;
      border-radius: 3px;
      text-align: center;
      font-size: 0.85rem;
      cursor: pointer; /* We will use a click to show/hide graph */
      display: inline-block;
      position: relative;
      transition: all 0.2s;
    }
    .hevy-set-weight, .hevy-set-reps {
      cursor: pointer;
      transition: color 0.2s;
    }
    .hevy-set-weight:hover, .hevy-set-reps:hover {
      color: #FFFF77; 
    }
    .hevy-total {
      margin-top: 1rem;
      padding-top: 0.5rem;
      border-top: 1px solid #555;
      font-weight: bold;
      color: white;
      cursor: pointer;
      transition: color 0.2s;
    }
    .hevy-total:hover {
      color: #FFDD77; /* Change to desired hover color */
    }

    /* Updated: One Rep Max line */
    .hevy-orm {
      margin-top: 0.5rem;
      color: white; /* matching the volume color */
      font-weight: normal; /* not bold */
      cursor: pointer;
      transition: color 0.2s;
    }
    .hevy-orm:hover {
      color: #FFDD77;
    }

    /* Volume Over Time for Each Exercise */
    .hevy-exercise-volume {
      margin-top: 0.5rem;
      color: white;
      cursor: pointer;
      transition: color 0.2s;
    }
    .hevy-exercise-volume:hover {
      color: #FFDD77;
    }

    /* Hevy Modal Layout */
    .hevy-modal-content {
      display: flex;
      flex-direction: row;
      gap: 1rem;
      width: 100%;
      align-items: center;
      justify-content: center;
    }
    #hevyModalWorkoutDetails {
      flex: 1;
      overflow-y: auto;
      max-height: 450px;
    }
    #hevyProgressChartContainer {
      flex: 1;
      max-width: 300px;
      display: none; /* Hidden until user selects a set */
    }
    #hevyProgressChart {
      width: 100%;
      height: 300px;
    }

    /* Exercise Volume Over Time Modal */
    #exerciseVolumeOverlay {
      z-index: 1000; /* Higher than hevyOverlay */
    }
    #exerciseVolumeModal {
      width: 500px;
    }
    #exerciseVolumeChart {
      width: 100%;
      height: 300px;
    }

    /* Exercise Weight Progression Modal */
    #exerciseProgressOverlay {
      z-index: 1001; /* Higher than exerciseVolumeOverlay */
    }
    #exerciseWeightProgressionModal {
      width: 500px;
    }
    #exerciseWeightProgressionChart {
      width: 100%;
      height: 300px;
    }

    /* Rep Progress Modal */
    #repProgressOverlay {
      z-index: 1002; /* Higher than exerciseProgressOverlay */
    }
    #exerciseRepProgressionModal {
      width: 500px;
    }
    #exerciseRepProgressionChart {
      width: 100%;
      height: 300px;
    }

    /* Volume Over Time Modal */
    #volumeOverlay {
      z-index: 1003; /* Higher than all other overlays so far */
    }
    #volumeModal {
      width: 600px;
    }
    #volumeChart {
      width: 100%;
      height: 400px;
    }

    /* ORM Progress Modal */
    #ormProgressOverlay {
      z-index: 1004; /* Highest so far */
    }
    #exerciseOrmProgressModal {
      width: 500px;
    }
    #exerciseOrmProgressChart {
      width: 100%;
      height: 300px;
    }

    /* Custom Alert Overlay */
    .custom-alert-modal {
      background: #2D2D2D;
      padding: 1.5rem;
      border-radius: 6px;
      width: 300px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.7);
      display: flex;
      flex-direction: column;
      gap: 1rem;
      text-align: center;
      justify-content: center;
      align-items: center;
    }
    .custom-alert-modal p {
      font-size: 1rem;
      color: #EAEAEA;
    }
    .custom-alert-modal input[type="text"] {
      padding: 0.5rem;
      border: 1px solid #555;
      border-radius: 4px;
      background: #444;
      color: #EAEAEA;
      font-size: 1rem;
    }
    .custom-alert-modal button {
      padding: 0.5rem;
      font-size: 0.9rem;
      border: 1px solid #555;
      border-radius: 4px;
      background: #444;
      color: #EAEAEA;
      cursor: pointer;
      transition: background-color 0.2s;
      flex: 1;
    }
    .custom-alert-modal button:hover {
      background: #555;
    }
    .custom-alert-modal .confirm-buttons {
      display: flex;
      gap: 1rem;
    }

    /* Loading Overlay */
    .loading-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.6);
      z-index: 1002; /* Adjust as needed */
      justify-content: center;
      align-items: center;
    }
    .loading-overlay.active {
      display: flex;
    }
    .spinner {
      border: 6px solid rgba(255, 255, 255, 0.3);
      border-top: 6px solid #fff;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  
  </style>
</head>
<body>
  <div class="main-wrapper">
    <!-- Month/Navigation/Buttons Bar -->
    <div class="month-bar">
      <div id="monthLabel" class="month-title">January 2025</div>
      <div class="arrow-buttons">
        <div class="month-nav-buttons">
          <button class="arrow-button" onclick="prevMonth()" title="Previous Month">▲</button>
          <button class="arrow-button" onclick="nextMonth()" title="Next Month">▼</button>
        </div>
        <div class="data-buttons">
          <!-- Save Button -->
          <button class="arrow-button" id="saveDataBtn" title="Save Data">💾</button>
          <!-- Load Button -->
          <button class="arrow-button" id="loadDataBtn" title="Load Data">📁</button>
          <!-- Import Hevy Button -->
          <button class="arrow-button" id="hevyImportBtn" title="Import Hevy">
            <img src="https://play-lh.googleusercontent.com/_HgX2ELOeBOIS6H-99ymHkNcEOlqoEncbt0x-D1MSgXx0ao8sTd7GRe16u-v70EgaAI"
                 alt="Hevy" style="width:18px;height:18px;">
          </button>
          <!-- Populate Calendar Button -->
          <button class="arrow-button" id="populateCalendarBtn" title="Populate Calendar" disabled style="opacity: 0.5; border: 2px solid #555;">
            📅
          </button>
          <!-- Stats Button -->
          <button class="arrow-button" id="statsBtn" title="View Statistics">📉</button>
          <!-- Clear Calendar Button -->
          <button class="arrow-button" id="clearCalendarBtn" title="Clear Calendar">🗋</button>
          <!-- Help Button -->
          <button class="arrow-button" id="helpBtn" title="Help">❔</button>
        </div>
      </div>
      <input type="file" id="importFileInput" accept=".json" style="display: none;">
    </div>
    <!-- Calendar -->
    <div class="calendar-container" id="calendar"></div>
  </div>

  <!-- Single-Cell Edit Overlay -->
  <div class="overlay" id="singleOverlay">
    <div class="modal" id="singleModal">
      <div class="modal-date" id="singleModalDate">2 January</div>
      <h2>Edit Cell</h2>
      <!-- SHIFT Presets -->
      <div class="modal-row">
        <label>
          <span id="singleShiftMainLabel">Shift Presets:</span>
          <span class="shift-label-text" id="singleShiftLabelText">(none)</span>
          <span class="reset-emoji" data-field="shiftClass" title="Reset Shift">⟳</span>
        </label>
        <div class="color-swatches" id="singleColorSwatchesContainer"></div>
      </div>
      <!-- GYM -->
      <div class="modal-row">
        <label>Workout Type
          <span class="reset-emoji" data-field="gym" title="Reset Workout Type">⟳</span>
        </label>
        <select id="singleWorkoutTypeSelect">
          <option value="Push">Push</option>
          <option value="Pull">Pull</option>
          <option value="Rest">Rest</option>
          <option value="Upper">Upper</option>
          <option value="Lower">Lower</option>
          <option value="Chest">Chest</option>
          <option value="Arms">Arms</option>
          <option value="Shoulders">Shoulders</option>
          <option value="Back">Back</option>
          <option value="Legs">Legs</option>
          <option value="Cardio">Cardio</option>
          <option value="None">None</option>
        </select>
      </div>
      <!-- Gym Time -->
      <div class="modal-row">
        <label>Gym Time (HHMM)
          <span class="reset-emoji" data-field="gymTime" title="Reset Gym Time">⟳</span>
        </label>
        <input type="text" id="singleGymTimeInput" placeholder="e.g. 2100">
      </div>
      <!-- Work Time – Dropdown -->
      <div class="modal-row">
        <label>Work Time (HHMM)
          <span class="reset-emoji" data-field="workTime" title="Reset Work Time">⟳</span>
        </label>
        <select id="singleWorkTimeSelect"></select>
      </div>
      <!-- Weight -->
      <div class="modal-row">
        <label>Weight (kg)
          <span class="reset-emoji" data-field="weight" title="Reset Weight">⟳</span>
        </label>
        <input type="text" id="singleWeightInput" placeholder="e.g. 88.0">
      </div>
      <!-- Alert Type -->
      <div class="modal-row">
        <label>Alert Type
          <span class="reset-emoji" data-field="alertType" title="Reset Alert Type">⟳</span>
        </label>
        <select id="singleAlertTypeSelect">
          <option value="None">⚪ None</option>
          <option value="Generic">🟢 Generic</option>
          <option value="Birthday">🟣 Birthday</option>
          <option value="Work">🔵 Work</option>
          <option value="PublicHoliday">🟡 Public Holiday</option>
        </select>
      </div>
      <!-- Alert Text -->
      <div class="modal-row">
        <label>Alert Text
          <span class="reset-emoji" data-field="alertText" title="Reset Alert Text">⟳</span>
        </label>
        <input type="text" id="singleAlertTextInput" placeholder="e.g. My birthday!">
      </div>

      <div class="modal-buttons">
        <button id="singleSaveBtn" title="Save Changes">Save</button>
        <button id="singleRevertBtn" style="font-size:1.5rem;" title="Revert Changes">⟳</button>
        <button id="singleCancelBtn" title="Cancel">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Multi-Cell Edit Overlay -->
  <div class="overlay" id="multiOverlay">
    <div class="modal" id="multiModal">
      <h2>Edit Cells</h2>
      <!-- Key to Change -->
      <div class="modal-row">
        <label>Select Key to Change</label>
        <select id="multiKeySelect">
          <option value="">(select key)</option>
          <option value="shiftClass">Shift Presets</option>
          <option value="gym">Workout Type</option>
          <option value="gymTime">Gym Time</option>
          <option value="workTime">Work Time</option>
          <option value="weight">Weight</option>
          <option value="alertType">Alert Type</option>
          <option value="alertText">Alert Text</option>
        </select>
      </div>
      <!-- SHIFT Presets Swatches Row -->
      <div class="modal-row" id="multiShiftSwatchesRow" style="display:none;">
        <label>
          Choose Shift Preset:
          <span class="shift-label-text" id="multiShiftLabelText">(none)</span>
        </label>
        <div class="color-swatches" id="multiColorSwatchesContainer"></div>
      </div>
      <!-- Alert Type Row -->
      <div class="modal-row" id="multiAlertTypeRow" style="display:none;">
        <label>Alert Type</label>
        <select id="multiAlertTypeSelect">
          <option value="None">⚪ None</option>
          <option value="Generic">🟢 Generic</option>
          <option value="Birthday">🟣 Birthday</option>
          <option value="Work">🔵 Work</option>
          <option value="PublicHoliday">🟡 Public Holiday</option>
        </select>
      </div>
      <!-- Work Time Row -->
      <div class="modal-row" id="multiWorkTimeRow" style="display: none;">
        <label>Work Time (HHMM)</label>
        <select id="multiWorkTimeSelect"></select>
      </div>
      <!-- Value Row for other keys -->
      <div class="modal-row" id="multiValueRow" style="display:none;">
        <label>New Value</label>
        <input type="text" id="multiValueInput" placeholder="">
      </div>
      <!-- Value Row for Workout Type -->
      <div class="modal-row" id="multiWorkoutTypeRow" style="display:none;">
        <label>New Workout Type</label>
        <select id="multiWorkoutTypeSelect">
          <option value="Push">Push</option>
          <option value="Pull">Pull</option>
          <option value="Rest">Rest</option>
          <option value="Upper">Upper</option>
          <option value="Lower">Lower</option>
          <option value="Chest">Chest</option>
          <option value="Arms">Arms</option>
          <option value="Shoulders">Shoulders</option>
          <option value="Back">Back</option>
          <option value="Legs">Legs</option>
          <option value="Cardio">Cardio</option>
          <option value="None">None</option>
        </select>
      </div>
      <div class="modal-buttons">
        <button id="multiSaveBtn" title="Save Changes">Save</button>
        <button id="multiRevertBtn" style="font-size:1.5rem;" title="Revert Changes">⟳</button>
        <button id="multiCancelBtn" title="Cancel">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Stats Overlay -->
  <div class="overlay" id="statsOverlay">
    <div class="modal" id="statsModal">
      <h2>Statistics</h2>
      <div class="stats-summary">
        <div class="stat-item">
          Sessions Completed: <span class="counter-value" id="sessionCounter">0</span>
        </div>
        <div class="stat-item">
          Days Trained: <span class="counter-value" id="daysTrainedCounter">0</span>
        </div>
        <div class="stat-item">
          Percentage Trained: <span class="counter-value" id="percentageCounter">0.00%</span>
        </div>
      </div>
      <div class="modal-row" style="height:300px;">
        <canvas id="weightChart"></canvas>
      </div>
      <div class="modal-buttons">
        <button id="statsCloseBtn" title="Close Statistics">Close</button>
      </div>
    </div>
  </div>

  <!-- Hevy Workout Summary Overlay -->
  <div class="overlay" id="hevyOverlay">
    <div class="modal" id="hevyModal">
      <h2>Hevy Workout Summary</h2>
      <div class="hevy-modal-content">
        <div id="hevyModalWorkoutDetails"></div>
        <div id="hevyProgressChartContainer">
          <canvas id="hevyProgressChart"></canvas>
        </div>
      </div>
      <div class="modal-buttons">
        <button id="hevyCloseBtn" title="Close Hevy Summary">Close</button>
      </div>
    </div>
  </div>

  <!-- Volume Over Time Overlay -->
  <div class="overlay" id="volumeOverlay">
    <div class="modal" id="volumeModal">
      <div class="modal-date" id="volumeModalDate"></div>
      <h2>Volume Over Time</h2>
      <div class="modal-row" style="height:300px;">
        <canvas id="volumeChart"></canvas>
      </div>
      <div class="modal-buttons">
        <button id="volumeCloseBtn" title="Close Volume Chart">Close</button>
      </div>
    </div>
  </div>

  <!-- Exercise Volume Over Time Overlay -->
  <div class="overlay" id="exerciseVolumeOverlay">
    <div class="modal" id="exerciseVolumeModal">
      <h2>Exercise Volume Over Time</h2>
      <div class="modal-row" style="height:300px;">
        <canvas id="exerciseVolumeChart"></canvas>
      </div>
      <div class="modal-buttons">
        <button id="exerciseVolumeCloseBtn" title="Close Exercise Volume Chart">Close</button>
      </div>
    </div>
  </div>

  <!-- Exercise Weight Progression Modal -->
  <div class="overlay" id="exerciseProgressOverlay">
    <div class="modal" id="exerciseWeightProgressionModal">
      <div class="modal-date" id="exerciseWeightProgressionModalDate"></div>
      <h2>Exercise: Weight Progression</h2>
      <div class="modal-row" style="height:300px;">
        <canvas id="exerciseWeightProgressionChart"></canvas>
      </div>
      <div class="modal-buttons">
        <button id="exerciseProgressCloseBtn" title="Close Weight Progression">Close</button>
      </div>
    </div>
  </div>

  <!-- Rep Progress Modal -->
  <div class="overlay" id="repProgressOverlay">
    <div class="modal" id="exerciseRepProgressionModal">
      <div class="modal-date" id="exerciseRepProgressionModalDate"></div>
      <h2>Exercise: Rep Progression</h2>
      <div class="modal-row" style="height:300px;">
        <canvas id="exerciseRepProgressionChart"></canvas>
      </div>
      <div class="modal-buttons">
        <button id="repProgressCloseBtn" title="Close Rep Progression">Close</button>
      </div>
    </div>
  </div>

  <!-- ORM Progress Modal -->
  <div class="overlay" id="ormProgressOverlay">
    <div class="modal" id="exerciseOrmProgressModal">
      <h2>Exercise: ORM Progression</h2>
      <div class="modal-row" style="height:300px;">
        <canvas id="exerciseOrmProgressChart"></canvas>
      </div>
      <div class="modal-buttons">
        <button id="ormProgressCloseBtn" title="Close ORM Progression">Close</button>
      </div>
    </div>
  </div>

  <!-- Custom Alert Overlay -->
  <div class="overlay" id="customAlertOverlay">
    <div class="custom-alert-modal" id="customAlertModal">
      <p id="customAlertMessage"></p>
      <input type="text" id="customAlertInput" style="display: none;" placeholder="">
      <div class="confirm-buttons" id="customConfirmButtons" style="display: none;"></div>
      <div class="default-button" id="customDefaultButton" style="display: block;">
        <button onclick="closeCustomAlert()" title="OK">OK</button>
      </div>
    </div>
  </div>

  <!-- Loading Overlay -->
  <div class="overlay loading-overlay" id="loadingOverlay">
    <div class="custom-alert-modal">
      <p>Loading...</p>
      <div class="spinner"></div>
    </div>
  </div>

  <script>
    /*
      =======================================
      =      1) Data, Constants, Config     =
      =======================================
    */
    const monthNames = [
      "January","February","March","April","May","June",
      "July","August","September","October","November","December"
    ];
    const dayNames = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];
    const LS_CALENDAR_DATA_KEY = "calendar2025Data";
    const LS_DEFAULT_CYCLE_KEY = "defaultCycle2025";
    const MS_IN_DAY = 86400000;

    let calendarData = JSON.parse(localStorage.getItem(LS_CALENDAR_DATA_KEY)) || {};
    let defaultCycleData = JSON.parse(localStorage.getItem(LS_DEFAULT_CYCLE_KEY)) || {
      pattern: [],
      startDate: null
    };
    let currentYear = 2025;
    let currentMonth = 0;
    const selectedDates = new Set();
    let isDragging = false;

    // For charts
    let weightChart = null;
    let hevyProgressChart = null;
    let exerciseWeightProgressionChart = null;
    let exerciseRepProgressionChart = null;
    let volumeChart = null;
    let exerciseVolumeChart = null;
    let exerciseOrmProgressChart = null;

    /*
      =======================================
      =       2) Helper Functions           =
      =======================================
    */
    function getDateKey(dateObj) {
      const y = dateObj.getFullYear();
      const m = String(dateObj.getMonth() + 1).padStart(2,"0");
      const d = String(dateObj.getDate()).padStart(2,"0");
      return `${y}-${m}-${d}`;
    }
    function parseDateKey(dateKey) {
      const [y,m,d] = dateKey.split("-").map(Number);
      return new Date(y, m-1, d);
    }
    function isToday(dateObj) {
      const now = new Date();
      return (
        dateObj.getFullYear() === now.getFullYear() &&
        dateObj.getMonth() === now.getMonth() &&
        dateObj.getDate() === now.getDate()
      );
    }
    function isOffDayShift(shiftClass) {
      return (shiftClass === "off-bg" || shiftClass === "al-bg");
    }
    function isTrainingDay(dayObj) {
      return (dayObj.gym !== "Rest" && dayObj.gym !== "None");
    }
    function validateTimeHHMM(value) {
      if (!value) return true; 
      return !!value.match(/^([01]\d|2[0-3])[0-5]\d$/);
    }
    function formatTimeForDisplay(time24) {
      if(!time24) return "";
      const hour = parseInt(time24.substring(0,2),10);
      const minute = time24.substring(2,4);
      let period = "am";
      let displayHour = hour;
      if(hour >= 12){
        period = "pm";
        if(hour > 12) displayHour = hour - 12;
      }
      if(hour === 0){
        displayHour = 12;
        period = "am";
      }
      return `${displayHour}:${minute}${period}`;
    }
    function getDayData(dateKey) {
      if(!calendarData[dateKey]) {
        calendarData[dateKey] = {
          shiftClass: "off-bg",
          gym: "None",
          gymTime: "",
          workTime: "",
          completed: false,
          weight: null,
          alert: null,
          hevyWorkouts: []
        };
      }
      return calendarData[dateKey];
    }
    function setDayData(dateKey, newData) {
      if(!calendarData[dateKey]) {
        calendarData[dateKey] = {};
      }
      Object.assign(calendarData[dateKey], newData);
      localStorage.setItem(LS_CALENDAR_DATA_KEY, JSON.stringify(calendarData));
    }
    function getLastRecordedWeightBefore(dateKey) {
      const dateObj = parseDateKey(dateKey);
      const d = new Date(dateObj.getTime());
      d.setDate(d.getDate() - 1);
      while(d.getFullYear() === 2025 && d >= new Date(2025,0,1)) {
        const prevKey = getDateKey(d);
        if (calendarData[prevKey] && calendarData[prevKey].weight > 0) {
          return calendarData[prevKey].weight;
        }
        d.setDate(d.getDate() - 1);
      }
      return null;
    }
    function getWeightArrow(dateKey) {
      const dayObj = getDayData(dateKey);
      if(!dayObj.weight || parseFloat(dayObj.weight) <= 0) return ""; 
      const lastWeight = getLastRecordedWeightBefore(dateKey);
      if(!lastWeight) return "";
      if(dayObj.weight > lastWeight)  return "↑";
      if(dayObj.weight < lastWeight)  return "↓";
      return "";
    }
    function computeFreeTime(dateKey) {
      const dayObj = getDayData(dateKey);
      if(!dayObj.workTime || isOffDayShift(dayObj.shiftClass)){
        return null;
      }
      const curStartHour = parseInt(dayObj.workTime.substring(0,2),10);
      const curStartMin = parseInt(dayObj.workTime.substring(2,4),10);
      let currentShiftDate = parseDateKey(dateKey);
      currentShiftDate.setHours(curStartHour, curStartMin, 0, 0);

      let currentShiftEnd = new Date(currentShiftDate.getTime() + 10 * 3600000);

      // Next day that has a valid workTime
      let nextDate = new Date(parseDateKey(dateKey).getTime());
      nextDate.setDate(nextDate.getDate() + 1);
      let nextWorkShiftDate = null;

      while(nextDate.getFullYear() === 2025) {
        const nextKey = getDateKey(nextDate);
        const nextDay = getDayData(nextKey);
        if(nextDay.workTime && !isOffDayShift(nextDay.shiftClass)) {
          nextWorkShiftDate = new Date(nextDate.getTime());
          const nxHr = parseInt(nextDay.workTime.substring(0,2),10);
          const nxMin = parseInt(nextDay.workTime.substring(2,4),10);
          nextWorkShiftDate.setHours(nxHr, nxMin, 0, 0);
          break;
        }
        nextDate.setDate(nextDate.getDate() + 1);
      }
      if(!nextWorkShiftDate) return null;

      let nextPrepTime = new Date(nextWorkShiftDate.getTime() - 3600000); 
      let gapHours = (nextPrepTime - currentShiftEnd) / 3600000;

      // Subtract 8 hours sleep
      gapHours -= 8;

      return Math.max(0, Math.floor(gapHours));
    }
    function computeCurrentDayFreeTimeFull() {
      const now = new Date();
      let nextDate = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);
      let nextWorkShiftDate = null;

      while(nextDate.getFullYear() === 2025) {
        const nextKey = getDateKey(nextDate);
        const nextDay = getDayData(nextKey);
        if(nextDay.workTime && !isOffDayShift(nextDay.shiftClass)) {
          nextWorkShiftDate = new Date(nextDate.getTime());
          const nxHr = parseInt(nextDay.workTime.substring(0,2),10);
          const nxMin = parseInt(nextDay.workTime.substring(2,4),10);
          nextWorkShiftDate.setHours(nxHr, nxMin, 0, 0);
          break;
        }
        nextDate.setDate(nextDate.getDate() + 1);
      }
      if(!nextWorkShiftDate) return "N/A";

      const diffMs = nextWorkShiftDate - now - 8 * 3600000; // Subtract 8 hours sleep
      const totalMinutes = Math.floor(diffMs / 60000);
      const hours = Math.floor(totalMinutes / 60);
      const minutes = totalMinutes % 60;
      return `${hours.toString().padStart(2,"0")}:${minutes.toString().padStart(2,"0")}`;
    }
    function getDefaultDataForDate(dateKey){
      if(!defaultCycleData.pattern.length || !defaultCycleData.startDate){
        return {
          shiftClass: "off-bg",
          gym: "None",
          gymTime: "",
          workTime: "",
          completed: false,
          weight: null,
          alert: null,
          hevyWorkouts: []
        };
      }
      const startDate = parseDateKey(defaultCycleData.startDate);
      const currentDate = parseDateKey(dateKey);
      const diffDays = Math.floor((currentDate - startDate) / MS_IN_DAY);
      const patternLength = defaultCycleData.pattern.length;
      const patternIndex = ((diffDays % patternLength) + patternLength) % patternLength; 
      return defaultCycleData.pattern[patternIndex];
    }
    function escapeHtml(str) {
      return str.replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }

    // --- NEW HELPER: Compute 1RM using Brzycki/Epley ---
    function computeOrm(weightKg, reps) {
      if(reps <= 0 || weightKg <= 0) return 0;
      // Use Brzycki if reps <= 10, else Epley
      if(reps <= 10) {
        // Brzycki formula
        return weightKg / (1.0278 - 0.0278 * reps);
      } else {
        // Epley formula
        return weightKg * (1 + (reps / 30));
      }
    }

    // --- NEW HELPERS: Return the max so far (before date) for weight, volume, ORM ---
    function getMaxWeightForExerciseBeforeDate(exerciseName, dateKey) {
      const targetDate = parseDateKey(dateKey);
      let maxWeight = 0;
      for(const k of Object.keys(calendarData)) {
        const d = parseDateKey(k);
        if(d < targetDate) {
          const dayObj = calendarData[k];
          if(dayObj.hevyWorkouts) {
            dayObj.hevyWorkouts.forEach(workout => {
              workout.exercises.forEach(ex => {
                if(ex.title === exerciseName) {
                  ex.sets.forEach(s => {
                    if(s.weight_kg > maxWeight) maxWeight = s.weight_kg;
                  });
                }
              });
            });
          }
        }
      }
      return maxWeight;
    }

    function getMaxVolumeForExerciseBeforeDate(exerciseName, dateKey) {
      const targetDate = parseDateKey(dateKey);
      let maxVolume = 0;
      for(const k of Object.keys(calendarData)) {
        const d = parseDateKey(k);
        if(d < targetDate) {
          let dayVolume = 0;
          const dayObj = calendarData[k];
          if(dayObj.hevyWorkouts) {
            dayObj.hevyWorkouts.forEach(workout => {
              workout.exercises.forEach(ex => {
                if(ex.title === exerciseName) {
                  ex.sets.forEach(s => {
                    dayVolume += (s.weight_kg * s.reps);
                  });
                }
              });
            });
          }
          if(dayVolume > maxVolume) {
            maxVolume = dayVolume;
          }
        }
      }
      return maxVolume;
    }

    function getMaxOrmForExerciseBeforeDate(exerciseName, dateKey) {
      const targetDate = parseDateKey(dateKey);
      let maxOrm = 0;
      for(const k of Object.keys(calendarData)) {
        const d = parseDateKey(k);
        if(d < targetDate) {
          const dayObj = calendarData[k];
          if(dayObj.hevyWorkouts) {
            dayObj.hevyWorkouts.forEach(workout => {
              workout.exercises.forEach(ex => {
                if(ex.title === exerciseName) {
                  ex.sets.forEach(s => {
                    const thisOrm = computeOrm(s.weight_kg, s.reps);
                    if(thisOrm > maxOrm) {
                      maxOrm = thisOrm;
                    }
                  });
                }
              });
            });
          }
        }
      }
      return maxOrm;
    }
	
	function getBestWeightAndRepsBeforeDate(exerciseName, dateKey) {
	  let bestWeight = 0;
	  let bestRepsForWeight = 0;

	  const targetDate = parseDateKey(dateKey);

	  for (const k of Object.keys(calendarData)) {
		const d = parseDateKey(k);
		if (d < targetDate) {
		  const dayObj = calendarData[k];
		  if (dayObj.hevyWorkouts) {
			dayObj.hevyWorkouts.forEach(workout => {
			  workout.exercises.forEach(ex => {
				if (ex.title === exerciseName) {
				  ex.sets.forEach(s => {
					// Check if we found a bigger weight
					if (s.weight_kg > bestWeight) {
					  bestWeight = s.weight_kg;
					  bestRepsForWeight = s.reps;
					}
					// If the weight is exactly our best but the reps are higher, update
					else if (s.weight_kg === bestWeight && s.reps > bestRepsForWeight) {
					  bestRepsForWeight = s.reps;
					}
				  });
				}
			  });
			});
		  }
		}
	  }

	  return { bestWeight, bestRepsForWeight };
	}
    /*
      =======================================
      =       3) Calendar Rendering         =
      =======================================
    */
    function renderCalendar(year, month) {
      document.getElementById("monthLabel").textContent = `${monthNames[month]} ${year}`;
      const calendar = document.getElementById("calendar");
      calendar.innerHTML = "";

      const headerEl = renderCalendarHeader();
      const gridEl = renderCalendarGrid(year, month);

      calendar.appendChild(headerEl);
      calendar.appendChild(gridEl);

      updateCounters();
      updatePopulateCalendarButtonState();
    }
    function renderCalendarHeader() {
      const headerGrid = document.createElement("div");
      headerGrid.classList.add("calendar-header");
      dayNames.forEach(d => {
        const hd = document.createElement("div");
        hd.textContent = d;
        headerGrid.appendChild(hd);
      });
      return headerGrid;
    }
    function renderCalendarGrid(year, month) {
      const grid = document.createElement("div");
      grid.classList.add("calendar-grid");

      const daysInMonth = new Date(year, month + 1, 0).getDate();
      const firstDay = new Date(year, month, 1);
      const startWeekday = firstDay.getDay();
      let rowIndex = 0, colIndex = 0;

      // Blank cells before the first day
      for(let i = 0; i < startWeekday; i++){
        grid.appendChild(blankCell(rowIndex, colIndex++));
      }

      // Days of the current month
      for(let dayNum = 1; dayNum <= daysInMonth; dayNum++){
        const dateObj = new Date(year, month, dayNum);
        const cell = renderDayCell(dateObj, dayNum);
        cell.setAttribute("data-row", rowIndex);
        cell.setAttribute("data-col", colIndex);
        grid.appendChild(cell);

        colIndex++;
        if(colIndex > 6){
          colIndex = 0;
          rowIndex++;
        }
      }

      // Fill remaining cells to make 6 weeks (42 total)
      const totalCellsUsed = startWeekday + daysInMonth;
      const remainingCells = 42 - totalCellsUsed;
      for(let i = 0; i < remainingCells; i++){
        grid.appendChild(blankCell(rowIndex, colIndex++));
        if(colIndex > 6){
          colIndex = 0;
          rowIndex++;
        }
      }
      return grid;
    }
    function blankCell(row, col) {
      const blank = document.createElement("div");
      blank.classList.add("day-cell", "faded");
      blank.setAttribute("data-row", row);
      blank.setAttribute("data-col", col);
      return blank;
    }
    function renderDayCell(dateObj, dayNum) {
      const dateKey = getDateKey(dateObj);
      const dayData = getDayData(dateKey);

      const cell = document.createElement("div");
      cell.classList.add("day-cell");

      // Shift color or custom
      if(dayData.workTime && !isOffDayShift(dayData.shiftClass)) {
        if(dayData.shiftClass === "custom-shift" && workTimeColors[dayData.workTime]) {
          cell.style.backgroundColor = workTimeColors[dayData.workTime];
        } else if(workTimeColors[dayData.workTime]) {
          cell.style.backgroundColor = workTimeColors[dayData.workTime];
        } else {
          cell.classList.add(dayData.shiftClass);
        }
      } else {
        cell.classList.add(dayData.shiftClass);
      }

      cell.setAttribute("data-date-key", dateKey);

      if(isToday(dateObj)) cell.classList.add("today");
      if(dayData.completed) cell.classList.add("completed");
      if(selectedDates.has(dateKey)) cell.classList.add("selected");

      // Date number
      const dateDiv = document.createElement("div");
      dateDiv.classList.add("date-num");
      dateDiv.textContent = dayNum;
      cell.appendChild(dateDiv);

      // Free time
      if(isToday(dateObj)) {
        if(isOffDayShift(dayData.shiftClass)) {
          const currentFreeTime = computeCurrentDayFreeTimeFull();
          appendFreeTime(cell, currentFreeTime, true);
        } else {
          const freeTime = computeFreeTime(dateKey);
          if(freeTime) appendFreeTime(cell, freeTime);
        }
      } else {
        const freeTime = computeFreeTime(dateKey);
        if(freeTime) appendFreeTime(cell, freeTime);
      }

      // Refresh icon
      const refreshDiv = document.createElement("div");
      refreshDiv.classList.add("refresh-emoji");
      refreshDiv.textContent = "⟳";
      refreshDiv.addEventListener("mousedown", e => e.stopPropagation());
      refreshDiv.addEventListener("click", e => {
        e.stopPropagation();
        if(!selectedDates.has(dateKey)){
          selectedDates.clear();
          selectedDates.add(dateKey);
        }
        openCustomizationPopup();
      });
      cell.appendChild(refreshDiv);

      // Alerts
      if(dayData.alert && dayData.alert.type && dayData.alert.type !== "None") {
        const color = alertColors[dayData.alert.type] || "#32CD32";
        const overlay = document.createElement("div");
        overlay.classList.add("alert-overlay");
        overlay.style.background = `linear-gradient(to bottom, ${color}CC, transparent 100%)`;
        cell.appendChild(overlay);

        const alertSpan = document.createElement("div");
        alertSpan.classList.add("alert-text");
        alertSpan.textContent = dayData.alert.text || "";
        cell.appendChild(alertSpan);
      }

      // Weight display
      const weightDiv = document.createElement("div");
      weightDiv.classList.add("weight-display");
      if(dayData.weight && parseFloat(dayData.weight) > 0) {
        const arrow = getWeightArrow(dateKey);
        let arrowColor = "#FFF";
        if(arrow === "↑") arrowColor = "#FF4444";
        if(arrow === "↓") arrowColor = "#66CC66";

        const textSpan = `${dayData.weight}kg`;
        if(arrow){
          if(arrow === "↑"){
            weightDiv.innerHTML = `<span style="font-size:120%; color:${arrowColor}; margin-right:0.3em;">${arrow}</span> ${textSpan}`;
            weightDiv.style.color = arrowColor;
          } else {
            weightDiv.innerHTML = `${textSpan} <span style="font-size:120%; color:${arrowColor}; margin-left:0.3em;">${arrow}</span>`;
            weightDiv.style.color = arrowColor;
          }
        } else {
          weightDiv.textContent = textSpan;
        }
      }
      cell.appendChild(weightDiv);

      // Shift time
      const shiftTimeDiv = document.createElement("div");
      shiftTimeDiv.classList.add("shift-time-text");
      if(dayData.shiftClass === "al-bg") {
        shiftTimeDiv.textContent = "AL";
      } else if(dayData.workTime && !isOffDayShift(dayData.shiftClass)) {
        shiftTimeDiv.textContent = dayData.workTime;
      }
      cell.appendChild(shiftTimeDiv);

      // Workout info
      const wDiv = document.createElement("div");
      wDiv.classList.add("workout-info");
      if(dayData.gym === "Rest") {
        wDiv.textContent = "😴";
        wDiv.style.opacity = "1.0";
      }
      else if(dayData.gym === "None") {
        wDiv.textContent = "";
      }
      else {
        wDiv.innerHTML = `${dayData.gym}: ${formatTimeForDisplay(dayData.gymTime || "")}`;
      }
      cell.appendChild(wDiv);

      // Completed badge
      const badgeDiv = document.createElement("div");
      badgeDiv.classList.add("completed-badge");
      if(dayData.completed) badgeDiv.classList.add("enabled");
      badgeDiv.addEventListener("mousedown", e => e.stopPropagation());
      badgeDiv.addEventListener("click", (e) => {
        e.stopPropagation();
        setDayData(dateKey, { completed: !dayData.completed });
        renderCalendar(currentYear, currentMonth);
      });
      badgeDiv.innerHTML = `
        <svg width="16" height="16" fill="none" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" />
        </svg>
      `;
      cell.appendChild(badgeDiv);

      return cell;
    }
    function appendFreeTime(cell, freeTimeValue, isTodayOffShift) {
      const freeTimeDiv = document.createElement("div");
      freeTimeDiv.classList.add("free-time-text");
      freeTimeDiv.textContent = freeTimeValue;
      if(isTodayOffShift) {
        freeTimeDiv.style.color = "gold";
        freeTimeDiv.style.opacity = "0.7";
      }
      cell.appendChild(freeTimeDiv);
    }

    /*
      =======================================
      =    4) Single vs Multi Popup Flow    =
      =======================================
    */
    function openCustomizationPopup() {
      if(selectedDates.size === 0){
        showCustomAlert("No days selected. Please select a cell first.");
        return;
      }
      if(selectedDates.size === 1){
        openSingleModal();
      } else {
        openMultiModal();
      }
    }

    // 4a) Single-Cell Modal
    let currentSingleDayKey = null;

    function populateWorkTimeSelect(selectId, selectedValue){
      const selectElem = document.getElementById(selectId);
      selectElem.innerHTML = "";
      Object.keys(workTimeColors).sort().forEach(time => {
        const option = document.createElement("option");
        option.value = time;
        option.textContent = time;
        option.style.backgroundColor = workTimeColors[time] || "#444";
        option.style.color = "#fff";
        if(time === selectedValue) { option.selected = true; }
        selectElem.appendChild(option);
      });
    }
    function updateSingleWorkTimeState(){
      const active = document.querySelector("#singleColorSwatchesContainer .swatch.active");
      if(active){
        const preset = active.id.replace("swatch-single-", "");
        document.getElementById("singleWorkTimeSelect").disabled =
          (preset === "off-bg" || preset === "al-bg");
      }
    }
    function openSingleModal() {
      document.getElementById("singleOverlay").classList.add("active");
      document.querySelectorAll("#singleColorSwatchesContainer .swatch").forEach(s => s.classList.remove("active"));

      const [dKey] = [...selectedDates];
      currentSingleDayKey = dKey;
      const dayData = getDayData(dKey);

      // Date
      const dateObj = parseDateKey(currentSingleDayKey);
      const formattedDate = `${dateObj.getDate()} ${monthNames[dateObj.getMonth()]}`;
      document.getElementById("singleModalDate").textContent = formattedDate;

      // Shift Preset
      document.querySelectorAll("#singleColorSwatchesContainer .swatch").forEach(swatch => {
        if(swatch.id === `swatch-single-${dayData.shiftClass}`){
          swatch.classList.add("active");
        } else {
          swatch.classList.remove("active");
        }
      });
      const preset = colorOptions.find(opt => opt.className === dayData.shiftClass);
      document.getElementById("singleShiftLabelText").textContent = preset ? preset.label : "Custom Shift";

      // Form values
      document.getElementById("singleWorkoutTypeSelect").value = dayData.gym || "None";
      document.getElementById("singleGymTimeInput").value = dayData.gymTime || "";
      populateWorkTimeSelect("singleWorkTimeSelect", dayData.workTime);
      document.getElementById("singleWeightInput").value = dayData.weight || "";

      if(isOffDayShift(dayData.shiftClass)) {
        document.getElementById("singleWorkTimeSelect").disabled = true;
      } else {
        document.getElementById("singleWorkTimeSelect").disabled = false;
      }

      // Alerts
      let alertVal = "None";
      if(dayData.alert && dayData.alert.type && dayData.alert.type !== "None") {
        alertVal = dayData.alert.type;
      }
      document.getElementById("singleAlertTypeSelect").value = alertVal;
      document.getElementById("singleAlertTextInput").value =
        (dayData.alert && dayData.alert.text) ? dayData.alert.text : "";
    }
    function closeSingleModal() {
      document.getElementById("singleOverlay").classList.remove("active");
    }
    function resetSingleField(fieldName) {
      if(!currentSingleDayKey) return;
      const defaultData = getDefaultDataForDate(currentSingleDayKey);
      if(!defaultData) return;

      if(fieldName === "shiftClass"){
        document.querySelectorAll("#singleColorSwatchesContainer .swatch").forEach(s => s.classList.remove("active"));
        const sw = document.getElementById("swatch-single-" + defaultData.shiftClass);
        if(sw) sw.classList.add("active");
        const preset = colorOptions.find(o => o.className === defaultData.shiftClass);
        document.getElementById("singleShiftLabelText").textContent = preset ? preset.label : "(none)";

        if(isOffDayShift(defaultData.shiftClass)) {
          document.getElementById("singleWorkTimeSelect").disabled = true;
        } else {
          document.getElementById("singleWorkTimeSelect").disabled = false;
        }
      } else if(fieldName === "gym"){
        document.getElementById("singleWorkoutTypeSelect").value = defaultData.gym;
      } else if(fieldName === "gymTime"){
        document.getElementById("singleGymTimeInput").value = defaultData.gymTime || "";
      } else if(fieldName === "workTime"){
        populateWorkTimeSelect("singleWorkTimeSelect", defaultData.workTime);
      } else if(fieldName === "weight"){
        document.getElementById("singleWeightInput").value = defaultData.weight || "";
      } else if(fieldName === "alertType"){
        if(defaultData.alert && defaultData.alert.type){
          document.getElementById("singleAlertTypeSelect").value = defaultData.alert.type;
        } else {
          document.getElementById("singleAlertTypeSelect").value = "None";
        }
      } else if(fieldName === "alertText"){
        if(defaultData.alert && defaultData.alert.text){
          document.getElementById("singleAlertTextInput").value = defaultData.alert.text;
        } else {
          document.getElementById("singleAlertTextInput").value = "";
        }
      }
    }
    function saveSingleModal() {
      if(!currentSingleDayKey) return;
      const updates = {};
      const activeSwatch = document.querySelector("#singleColorSwatchesContainer .swatch.active");
      if(activeSwatch){
        updates.shiftClass = activeSwatch.id.replace("swatch-single-", "");
      }
      updates.gym = document.getElementById("singleWorkoutTypeSelect").value.trim();

      // Gym time
      const newGymTime = document.getElementById("singleGymTimeInput").value.trim();
      if(newGymTime){
        if(!validateTimeHHMM(newGymTime)){
          showCustomAlert("Invalid Gym Time. Use HHMM format (e.g. 2100).");
          return;
        }
        updates.gymTime = newGymTime;
      } else {
        updates.gymTime = "";
      }

      // Work time
      if(updates.shiftClass === "off-bg" || updates.shiftClass === "al-bg"){
        updates.workTime = "";
      } else {
        updates.workTime = document.getElementById("singleWorkTimeSelect").value;
        const isPreset = Object.values(presetWorkTimeMapping).includes(updates.workTime);
        if(!isPreset){
          updates.shiftClass = "custom-shift";
        }
      }

      // Weight
      const weightVal = document.getElementById("singleWeightInput").value.trim();
      if(weightVal){
        let wf = parseFloat(weightVal);
        if(isNaN(wf) || wf <= 0){
          showCustomAlert("Invalid weight.");
          return;
        }
        updates.weight = wf.toFixed(1);
      } else {
        updates.weight = null;
      }

      // Alert
      const alertType = document.getElementById("singleAlertTypeSelect").value;
      const alertText = document.getElementById("singleAlertTextInput").value.trim();
      if(alertType && alertType !== "None"){
        updates.alert = { type: alertType, text: alertText || "" };
      } else {
        updates.alert = null;
      }

      setDayData(currentSingleDayKey, updates);
      closeSingleModal();
      renderCalendar(currentYear, currentMonth);

      // Pulse highlight
      setTimeout(() => {
        const cellElement = document.querySelector(`[data-date-key="${currentSingleDayKey}"]`);
        if(cellElement){
          cellElement.classList.add("cell-pulse");
          cellElement.addEventListener("animationend", function handler(){
            cellElement.classList.remove("cell-pulse");
            cellElement.removeEventListener("animationend", handler);
          });
        }
      }, 100);
    }
    function revertSingleModal() {
      if(!currentSingleDayKey) return;
      const defaultData = getDefaultDataForDate(currentSingleDayKey);
      if(defaultData){
        setDayData(currentSingleDayKey, {
          shiftClass: defaultData.shiftClass,
          gym: defaultData.gym,
          gymTime: defaultData.gymTime || "",
          workTime: defaultData.workTime || "",
          completed: defaultData.completed || false,
          weight: defaultData.weight || null,
          alert: defaultData.alert || null,
          hevyWorkouts: defaultData.hevyWorkouts ? [...defaultData.hevyWorkouts] : []
        });
      }
      closeSingleModal();
      renderCalendar(currentYear, currentMonth);
    }

    // 4b) Multi-Cell Modal
    function openMultiModal() {
      document.getElementById("multiOverlay").classList.add("active");
      document.getElementById("multiKeySelect").value = "";
      document.getElementById("multiValueInput").value = "";
      document.getElementById("multiValueInput").placeholder = "";
      document.getElementById("multiShiftSwatchesRow").style.display = "none";
      document.getElementById("multiAlertTypeRow").style.display = "none";
      document.getElementById("multiWorkTimeRow").style.display = "none";
      document.getElementById("multiWorkoutTypeRow").style.display = "none";
      document.getElementById("multiAlertTypeSelect").value = "None";
      document.querySelectorAll("#multiColorSwatchesContainer .swatch").forEach(s => s.classList.remove("active"));
      document.getElementById("multiShiftLabelText").textContent = "(none)";
    }
    function closeMultiModal() {
      document.getElementById("multiOverlay").classList.remove("active");
    }
    function handleMultiKeyChange() {
      const key = document.getElementById("multiKeySelect").value;
      const valRow = document.getElementById("multiValueRow");
      const shiftRow = document.getElementById("multiShiftSwatchesRow");
      const alertRow = document.getElementById("multiAlertTypeRow");
      const workTimeRow = document.getElementById("multiWorkTimeRow");
      const workoutTypeRow = document.getElementById("multiWorkoutTypeRow");

      shiftRow.style.display = "none";
      valRow.style.display = "none";
      alertRow.style.display = "none";
      workTimeRow.style.display = "none";
      workoutTypeRow.style.display = "none";

      if(key === "shiftClass"){
        shiftRow.style.display = "flex";
      } else if(key === "alertType"){
        alertRow.style.display = "flex";
      } else if(key === "workTime"){
        workTimeRow.style.display = "flex";
        populateWorkTimeSelect("multiWorkTimeSelect", "");
      } else if(key === "gym"){
        workoutTypeRow.style.display = "flex";
      } else if(key){
        valRow.style.display = "flex";
        document.getElementById("multiValueInput").placeholder = multiPlaceholderMap[key] || "";
      }
    }
    function saveMultiModal() {
      const key = document.getElementById("multiKeySelect").value;
      if(!key){
        showCustomAlert("Please select a key to change.");
        return;
      }

      let newValue;
      if(key === "shiftClass"){
        const swatch = document.querySelector("#multiColorSwatchesContainer .swatch.active");
        if(!swatch){
          showCustomAlert("Please choose a shift preset.");
          return;
        }
        newValue = swatch.id.replace("swatch-multi-", "");
      } else if(key === "alertType"){
        newValue = document.getElementById("multiAlertTypeSelect").value;
      } else if(key === "workTime"){
        newValue = document.getElementById("multiWorkTimeSelect").value;
      } else if(key === "gym"){
        newValue = document.getElementById("multiWorkoutTypeSelect").value;
      } else {
        newValue = document.getElementById("multiValueInput").value.trim();
      }

      if(key === "gymTime" && newValue){
        if(!validateTimeHHMM(newValue)){
          showCustomAlert("Invalid time. Use HHMM format (e.g. 0600).");
          return;
        }
      }
      if(key === "weight"){
        if(newValue){
          let wf = parseFloat(newValue);
          if(isNaN(wf) || wf <= 0){
            showCustomAlert("Invalid weight.");
            return;
          }
          newValue = wf.toFixed(1);
        } else {
          newValue = null;
        }
      }

      selectedDates.forEach(dKey => {
        const updated = {};

        if(key === "shiftClass"){
          updated.shiftClass = newValue;
          if(presetWorkTimeMapping[newValue]) {
            updated.workTime = presetWorkTimeMapping[newValue];
          } else if(newValue === "off-bg" || newValue === "al-bg"){
            updated.workTime = "";
          }
        }
        else if(key === "gym"){
          updated.gym = newValue || "";
        }
        else if(key === "gymTime"){
          updated.gymTime = newValue || "";
        }
        else if(key === "workTime"){
          updated.workTime = newValue || "";
          const found = Object.entries(presetWorkTimeMapping)
                             .find(([preset, time]) => time === newValue);
          if(found) {
            updated.shiftClass = found[0];
          } else {
            updated.shiftClass = "custom-shift";
          }
        }
        else if(key === "weight"){
          updated.weight = newValue ? newValue : null;
        }
        else if(key === "alertType"){
          if(newValue === "None"){
            updated.alert = null;
          } else {
            updated.alert = { type: newValue, text: "" };
          }
        }
        else if(key === "alertText"){
          if(newValue){
            if(calendarData[dKey].alert && calendarData[dKey].alert.type && calendarData[dKey].alert.type !== "None"){
              updated.alert = { type: calendarData[dKey].alert.type, text: newValue };
            } else {
              updated.alert = { type: "Generic", text: newValue };
            }
          } else {
            updated.alert = null;
          }
        }

        setDayData(dKey, updated);
      });

      closeMultiModal();
      renderCalendar(currentYear, currentMonth);

      // Pulse highlight
      setTimeout(() => {
        selectedDates.forEach(dKey => {
          const cellElement = document.querySelector(`[data-date-key="${dKey}"]`);
          if(cellElement){
            cellElement.classList.add("cell-pulse");
            cellElement.addEventListener("animationend", function handler(){
              cellElement.classList.remove("cell-pulse");
              cellElement.removeEventListener("animationend", handler);
            });
          }
        });
      }, 100);
    }
    function revertMultiModal() {
      selectedDates.forEach(dKey => {
        const defaultData = getDefaultDataForDate(dKey);
        if(defaultData){
          setDayData(dKey, {
            shiftClass: defaultData.shiftClass,
            gym: defaultData.gym,
            gymTime: defaultData.gymTime || "",
            workTime: defaultData.workTime || "",
            completed: defaultData.completed || false,
            weight: defaultData.weight || null,
            alert: defaultData.alert || null,
            hevyWorkouts: defaultData.hevyWorkouts ? [...defaultData.hevyWorkouts] : []
          });
        }
      });
      closeMultiModal();
      renderCalendar(currentYear, currentMonth);
    }

    /*
      =======================================
      =          5) Counters (Stats)        =
      =======================================
    */
    function updateCounters() {
      let completedCount = 0;
      let earliestDateKey = null;

      Object.keys(calendarData).forEach(key => {
        const dayObj = calendarData[key];
        if(dayObj.completed && isTrainingDay(dayObj)){
          completedCount++;
          if(!earliestDateKey || key < earliestDateKey){
            earliestDateKey = key;
          }
        }
      });

      let daysTrained = 0;
      if(earliestDateKey){
        const earliestDate = parseDateKey(earliestDateKey);
        const now = new Date();
        if(now.getFullYear() === 2025){
          let diff = now - earliestDate;
          let rawDays = Math.floor(diff / MS_IN_DAY);
          if(rawDays < 0) rawDays = 0;
          daysTrained = rawDays + 1;
        }
      }
      let percentage = 0;
      if(daysTrained > 0){
        percentage = (completedCount / daysTrained) * 100;
      }

      document.getElementById("sessionCounter").textContent = completedCount;
      document.getElementById("daysTrainedCounter").textContent = daysTrained;
      document.getElementById("percentageCounter").textContent = percentage.toFixed(2) + '%';
    }

    /*
      =======================================
      =         6) Navigation               =
      =======================================
    */
    function prevMonth() {
      currentMonth--;
      if(currentMonth < 0){
        currentMonth = 11;
        currentYear--;
      }
      if(currentYear < 2025){
        currentYear = 2025;
        currentMonth = 0;
      }
      selectedDates.clear();
      renderCalendar(currentYear, currentMonth);
    }
    function nextMonth() {
      currentMonth++;
      if(currentMonth > 11){
        currentMonth = 0;
        currentYear++;
      }
      if(currentYear > 2025){
        currentYear = 2025;
        currentMonth = 11;
      }
      selectedDates.clear();
      renderCalendar(currentYear, currentMonth);
    }

    /*
      =======================================
      =   7) Shift Preset & Color Swatches  =
      =======================================
    */
    const colorOptions = [
      { className: "morning-bg",   label: "Day Shift" },
      { className: "late-day-bg",  label: "Late-Day Shift" },
      { className: "afternoon-bg", label: "Afternoon Shift" },
      { className: "evening-bg",   label: "Evening Shift" },
      { className: "night-bg",     label: "Night Shift" },
      { className: "off-bg",       label: "Off (Weekly Leave)" },
      { className: "al-bg",        label: "Annual Leave" }
    ];
    const workTimeColors = {
      "0000": "#926E8E","0100": "#A47887","0200": "#B78381","0300": "#C8917A",
      "0400": "#DB9C73","0500": "#EDA76D","0600": "#FFAD66","0700": "#EEAE74",
      "0800": "#DEAF83","0900": "#D0A77D","1000": "#BDB2A0","1100": "#ACB3AE",
      "1200": "#9CB4BC","1300": "#8CB4CA","1400": "#7AB6D9","1500": "#76A7D1",
      "1600": "#7198C9","1700": "#6D8BC2","1800": "#697DBA","1900": "#627AA3",
      "2000": "#6060AA","2100": "#5C4EA2","2200": "#6E599B","2300": "#806395"
    };
    const alertColors = {
      "Generic": "#32CD32",
      "Birthday": "#FF69B4",
      "Work": "#1E90FF",
      "PublicHoliday": "#FFD700"
    };
    const presetWorkTimeMapping = {
      "morning-bg": "0600",
      "late-day-bg": "0900",
      "afternoon-bg": "1400",
      "evening-bg": "1900",
      "night-bg": "2100"
    };
    const multiPlaceholderMap = {
      shiftClass: "Use swatches below",
      gym: "Select Workout Type",
      gymTime: "HHMM e.g. 2100",
      workTime: "Choose work time",
      weight: "e.g. 88.0",
      alertType: "",
      alertText: "e.g. My special event"
    };

    function buildColorSwatches() {
      function buildSet(containerId, prefix, labelTextId) {
        const container = document.getElementById(containerId);
        colorOptions.forEach(opt => {
          const div = document.createElement("div");
          div.id = `swatch-${prefix}-${opt.className}`;
          div.className = `swatch ${opt.className}`;
          div.title = opt.label;
          div.addEventListener("mouseover", () => {
            document.getElementById(labelTextId).textContent = opt.label;
          });
          div.addEventListener("mouseout", () => {
            const activeSw = container.querySelector(".swatch.active");
            if(activeSw) {
              const className = activeSw.id.replace(`swatch-${prefix}-`, "");
              const found = colorOptions.find(o => o.className === className);
              document.getElementById(labelTextId).textContent = found ? found.label : "(none)";
            } else {
              document.getElementById(labelTextId).textContent = "(none)";
            }
          });
          div.addEventListener("click", () => {
            container.querySelectorAll(".swatch").forEach(s => s.classList.remove("active"));
            div.classList.add("active");
            if(prefix === "single") {
              updateSingleWorkTimeState();
              const thisPreset = div.id.replace("swatch-single-", "");
              if(presetWorkTimeMapping[thisPreset]) {
                document.getElementById("singleWorkTimeSelect").value = presetWorkTimeMapping[thisPreset];
              }
            } else if(prefix === "multi") {
              if(document.getElementById("multiKeySelect").value === "shiftClass") {
                const thisPreset = div.id.replace("swatch-multi-", "");
                if(presetWorkTimeMapping[thisPreset]) {
                  document.getElementById("multiWorkTimeSelect").value = presetWorkTimeMapping[thisPreset];
                }
              }
            }
          });
          container.appendChild(div);
        });
      }
      buildSet("singleColorSwatchesContainer", "single", "singleShiftLabelText");
      buildSet("multiColorSwatchesContainer", "multi", "multiShiftLabelText");
    }

    /*
      =======================================
      =   8) Data Backup (Load/Save JSON)   =
      =======================================
    */
    function saveData() {
      const dataToSave = {
        calendarData: calendarData,
        defaultCycle: defaultCycleData
      };
      const dataStr = JSON.stringify(dataToSave, null, 2);
      const blob = new Blob([dataStr], { type: "application/json" });
      const url  = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = 'calendar-data-backup.json';
      a.click();
      URL.revokeObjectURL(url);
    }
    function loadData(file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const importedData = JSON.parse(e.target.result);
          if(!importedData || typeof importedData !== 'object'){
            showCustomAlert("Invalid JSON data.");
            return;
          }
          if(!importedData.calendarData || typeof importedData.calendarData !== 'object'){
            showCustomAlert("Invalid or missing calendarData in JSON.");
            return;
          }
          calendarData = importedData.calendarData;
          localStorage.setItem(LS_CALENDAR_DATA_KEY, JSON.stringify(calendarData));

          if(importedData.defaultCycle && typeof importedData.defaultCycle === 'object'){
            defaultCycleData = importedData.defaultCycle;
            localStorage.setItem(LS_DEFAULT_CYCLE_KEY, JSON.stringify(defaultCycleData));
          } else {
            defaultCycleData = {
              pattern: [],
              startDate: null
            };
            localStorage.setItem(LS_DEFAULT_CYCLE_KEY, JSON.stringify(defaultCycleData));
          }

          selectedDates.clear();
          renderCalendar(currentYear, currentMonth);
          updateCounters();
          showCustomAlert("Data loaded successfully!");
        } catch(err){
          showCustomAlert("Failed to parse JSON file. Please ensure it's valid.");
        }
      };
      reader.readAsText(file);
    }

    /*
      =======================================
      =    9) Import Hevy Data from API     =
      =======================================
    */
    async function importHevyData(userApiKey) {
      try {
        document.getElementById("loadingOverlay").classList.add("active");

        const countResponse = await fetch("https://api.hevyapp.com/v1/workouts/count", {
          method: "GET",
          headers: {
            "accept": "application/json",
            "api-key": userApiKey
          }
        });
        if (!countResponse.ok) throw new Error("Failed to fetch workout count.");
        const countData = await countResponse.json();
        const totalWorkouts = countData.workout_count;

        const pageSize = 10;
        const totalPages = Math.ceil(totalWorkouts / pageSize);
        let allWorkouts = [];

        for (let page = 1; page <= totalPages; page++) {
          const response = await fetch(`https://api.hevyapp.com/v1/workouts?page=${page}&pageSize=${pageSize}`, {
            method: "GET",
            headers: {
              "accept": "application/json",
              "api-key": userApiKey
            }
          });
          if (!response.ok) throw new Error("Failed to fetch workouts page " + page);
          const data = await response.json();
          if (data.workouts && Array.isArray(data.workouts)) {
            allWorkouts = allWorkouts.concat(data.workouts);
          }
        }

        let importedCount = 0;
        allWorkouts.forEach(workout => {
          let dateKey = null;

          // Check if title is in "dd/mm/2025" format
          if (workout.title && /^(\d{1,2})\/(\d{1,2})\/2025$/.test(workout.title)) {
            const parts = workout.title.split("/");
            const dayNum = parseInt(parts[0], 10);
            const monthNum = parseInt(parts[1], 10);
            const yearNum = parseInt(parts[2], 10);
            if(yearNum === 2025){
              dateKey = `${yearNum}-${String(monthNum).padStart(2, "0")}-${String(dayNum).padStart(2,"0")}`;
            }
          }
          // If title format is off, use start_time
          if(!dateKey && workout.start_time){
            const startTime = new Date(workout.start_time);
            if(startTime.getFullYear() === 2025){
              dateKey = getDateKey(startTime);
            }
          }

          if(dateKey && dateKey.startsWith("2025-")){
            const dayData = getDayData(dateKey);
            if (!dayData.hevyWorkouts) {
              dayData.hevyWorkouts = [];
            }
            const duplicate = dayData.hevyWorkouts.some(existing => existing.id === workout.id);
            if (!duplicate) {
              dayData.hevyWorkouts.push(workout);
              dayData.completed = true; 
              setDayData(dateKey, dayData);
              importedCount++;
            }
          }
        });
        showCustomAlert(`Imported ${importedCount} new Hevy workouts into calendar.`);
        renderCalendar(currentYear, currentMonth);
      } catch(err) {
        console.error(err);
        showCustomAlert("An error occurred while importing Hevy data: " + err.message);
      } finally {
        document.getElementById("loadingOverlay").classList.remove("active");
      }
    }

    /*
      =======================================
      = 10) Stats Modal & 'WeightChart'     =
      =======================================
    */
    function openStatsModal() {
      document.getElementById("statsOverlay").classList.add("active");
      buildWeightChart();
    }
    function closeStatsModal() {
      document.getElementById("statsOverlay").classList.remove("active");
      if(weightChart){
        weightChart.destroy();
        weightChart = null;
      }
    }
    function buildWeightChart(){
      const weightKeys = Object.keys(calendarData)
        .filter(k => calendarData[k].weight && parseFloat(calendarData[k].weight) > 0)
        .sort();
      if(weightKeys.length < 1){
        if(weightChart){
          weightChart.destroy();
          weightChart = null;
        }
        return;
      }
      const dataPoints = weightKeys.map(k => ({ x: k, y: parseFloat(calendarData[k].weight) }));
      const labels = weightKeys.map(k => {
        const d = parseDateKey(k);
        return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
      });
      const weights = dataPoints.map(dp => dp.y);
      const minWeight = Math.min(...weights);
      const maxWeight = Math.max(...weights);
      const suggestedMin = Math.max(0, minWeight - 1);
      const suggestedMax = maxWeight + 1;

      if(weightChart){
        weightChart.destroy();
        weightChart = null;
      }
      const ctx = document.getElementById('weightChart').getContext('2d');

      // We highlight "today" if it's in data
      const todayKey = getDateKey(new Date());
      const { bgColors, borderColors, pointRadii } = buildHighlightArrays(
        dataPoints, todayKey, '#77DD77', 'red', 4, 8
      );

      weightChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Weight (kg)',
            data: dataPoints.map(dp => dp.y),
            borderColor: '#77DD77',
            backgroundColor: 'rgba(119,221,119,0.2)',
            fill: true,
            tension: 0.2,
            pointRadius: pointRadii,
            pointBackgroundColor: bgColors,
            pointBorderColor: borderColors,
            pointHoverRadius: 6
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: { 
              title: { display: true, text: 'Date' }, 
              ticks: { color: '#ccc' }, 
              grid: { color: '#555' }
            },
            y: { 
              suggestedMin, 
              suggestedMax, 
              title: { display: true, text: 'Weight (kg)' }, 
              ticks: { color: '#ccc' }, 
              grid: { color: '#555' } 
            }
          },
          plugins: {
            legend: { labels: { color: '#eee' } }
          }
        }
      });
    }
    function buildHighlightArrays(dataPoints, highlightDateKey, normalColor, highlightColor, normalRadius=4, highlightRadius=6) {
      const bgColors = [];
      const borderColors = [];
      const pointRadii = [];

      dataPoints.forEach(dp => {
        if(dp.x === highlightDateKey) {
          bgColors.push(highlightColor);
          borderColors.push("#fff");
          pointRadii.push(highlightRadius);
        } else {
          bgColors.push(normalColor);
          borderColors.push(normalColor);
          pointRadii.push(normalRadius);
        }
      });

      return { bgColors, borderColors, pointRadii };
    }

    /*
      ========================================
      = 11) Hevy Workout Summary Modal       =
      ========================================
    */
    function openHevyModal(dateKey) {
      document.getElementById("hevyOverlay").classList.add("active");
      const dayData = getDayData(dateKey);
      renderHevyWorkoutsToContainer(dayData.hevyWorkouts, "hevyModalWorkoutDetails", dateKey);
      destroyHevyProgressChart();
      document.getElementById("hevyProgressChartContainer").style.display = "none";
    }
    function closeHevyModal() {
      document.getElementById("hevyOverlay").classList.remove("active");
      destroyHevyProgressChart();
    }
    function destroyHevyProgressChart() {
      if(hevyProgressChart) {
        hevyProgressChart.destroy();
        hevyProgressChart = null;
      }
    }

    /*
      ================================================
      = 12) Rendering Hevy Workouts + PR Logic       =
      ================================================
    */
	function renderHevyWorkoutsToContainer(workouts, containerId, dateKey) {
	  const container = document.getElementById(containerId);
	  if (!workouts || workouts.length === 0) {
		container.innerHTML = "<p>No Hevy workout data for this day.</p>";
		return;
	  }

	  let html = "";

	  workouts.forEach(workout => {
		html += `<div class="hevy-workout">`;
		html += `<div class="hevy-workout-title">${escapeHtml(workout.title)}</div>`;

		workout.exercises.forEach(exercise => {
		  // Get the single best (weight, reps) from all days before dateKey
		  const { bestWeight, bestRepsForWeight } = getBestWeightAndRepsBeforeDate(exercise.title, dateKey);

		  // We'll also check if the user achieved new volume/ORM PR, same as before:
		  const prevMaxVolume = getMaxVolumeForExerciseBeforeDate(exercise.title, dateKey);
		  const prevMaxOrm    = getMaxOrmForExerciseBeforeDate(exercise.title, dateKey);

		  // compute day-level volume & highest set weight & highest ORM
		  let exerciseVolume = 0;
		  let highestOrmForThisExercise = 0;
		  exercise.sets.forEach(s => {
			const setVolume = s.weight_kg * s.reps;
			exerciseVolume += setVolume;

			const setOrm = computeOrm(s.weight_kg, s.reps);
			if (setOrm > highestOrmForThisExercise) {
			  highestOrmForThisExercise = setOrm;
			}
		  });

		  // Is today's volume a PR?
		  const isVolumePR = exerciseVolume > prevMaxVolume;
		  // Is today's ORM a PR?
		  const isOrmPR    = highestOrmForThisExercise > prevMaxOrm;

		  const candidates = [];
		  exercise.sets.forEach((s, i) => {
			// Condition for being "new weight PR"
			if (
			  s.weight_kg > bestWeight ||
			  (s.weight_kg === bestWeight && s.reps > bestRepsForWeight)
			) {
			  candidates.push({ index: i, weight: s.weight_kg, reps: s.reps });
			}
		  });

		  let highlightSetIndex = -1;
		  if (candidates.length > 0) {
			// 1) Find the largest weight among candidates
			const maxWeight = Math.max(...candidates.map(c => c.weight));
			// 2) Filter only those with that maxWeight
			const topWeightSets = candidates.filter(c => c.weight === maxWeight);
			// 3) Among them, find the highest reps
			const bestReps = Math.max(...topWeightSets.map(c => c.reps));
			// 4) highlight the first that hits that bestReps
			const highlight = topWeightSets.find(c => c.reps === bestReps);
			highlightSetIndex = highlight.index;
		  }

		  // Now build HTML for this exercise
		  html += `<div class="hevy-exercise">`;
		  html += `<div class="hevy-exercise-title">${escapeHtml(exercise.title)}</div>`;

		  // Each set
		  html += `<div class="hevy-sets">`;
		  exercise.sets.forEach((set, i) => {
			let setClasses = "hevy-set";
			let prSpan = "";
			if (i === highlightSetIndex) {
			  setClasses += " pr-border"; // gold border
			  prSpan = ` <span style="color:gold">PR</span>`; // show "PR" in gold
			}

			html += `
			  <div class="${setClasses}"
				   data-exercise="${escapeHtml(exercise.title)}"
				   data-reps="${set.reps}"
				   data-weight="${set.weight_kg}">
				<span class="hevy-set-weight">${set.weight_kg}kg</span>
				x
				<span class="hevy-set-reps">${set.reps}</span>
				${prSpan}
				${set.rpe ? `<br>RPE: ${set.rpe}` : ""}
			  </div>
			`;
		  });
		  html += `</div>`; // end .hevy-sets

		  // Volume line
		  let volumeText = `Volume: ${exerciseVolume.toLocaleString()}kg`;
		  if (isVolumePR) {
			volumeText += ` <span style="color:gold">PR</span>`;
		  }
		  html += `
			<div class="hevy-exercise-volume"
				 data-exercise="${escapeHtml(exercise.title)}"
				 data-date-key="${dateKey}">
			  ${volumeText}
			</div>
		  `;

		  // One Rep Max line
		  let ormText = "One Rep Max: N/A";
		  if (highestOrmForThisExercise > 0) {
			ormText = `One Rep Max: ${highestOrmForThisExercise.toFixed(1)}kg`;
			if (isOrmPR) {
			  ormText += ` <span style="color:gold">PR</span>`;
			}
		  }
		  html += `
			<div class="hevy-orm"
				 data-exercise="${escapeHtml(exercise.title)}"
				 data-date-key="${dateKey}">
			  ${ormText}
			</div>
		  `;

		  html += `</div>`; // end .hevy-exercise
		});

		// Summaries across entire workout (total volume)
		let totalWeight = 0;
		workout.exercises.forEach(ex => {
		  ex.sets.forEach(s => {
			totalWeight += (s.weight_kg * s.reps);
		  });
		});
		html += `<div class="hevy-total" data-date-key="${dateKey}">Total Volume: ${totalWeight.toLocaleString()}kg</div>`;

		html += `</div>`; // end .hevy-workout
	  });

	  container.innerHTML = html;

	  // Attach click handlers (same as before)
	  container.onclick = (e) => {
		// (1) volume for an exercise
		const volumeEl = e.target.closest(".hevy-exercise-volume");
		if (volumeEl) {
		  e.stopPropagation();
		  const exerciseName = volumeEl.getAttribute("data-exercise");
		  const dKey = volumeEl.getAttribute("data-date-key");
		  openExerciseVolumeModal(exerciseName, dKey);
		  return;
		}

		// (2) user clicked weight or reps
		if (e.target.classList.contains("hevy-set-weight") ||
			e.target.classList.contains("hevy-set-reps")) {
		  e.stopPropagation();
		  const setParent = e.target.closest(".hevy-set");
		  const exerciseName = setParent.getAttribute("data-exercise");
		  const weight = Number(setParent.getAttribute("data-weight"));
		  const reps = parseInt(setParent.getAttribute("data-reps"), 10);

		  if (e.target.classList.contains("hevy-set-weight")) {
			// open rep progression modal (fixed weight)
			openRepProgressModal(exerciseName, weight, dateKey);
		  } else {
			// open weight progression modal (fixed reps)
			openExerciseProgressModal(exerciseName, reps, dateKey);
		  }
		  return;
		}

		// (3) total volume
		const totalEl = e.target.closest(".hevy-total");
		if (totalEl) {
		  e.stopPropagation();
		  const associatedDateKey = totalEl.getAttribute("data-date-key");
		  openVolumeModal(associatedDateKey);
		  return;
		}

		// (4) One Rep Max
		const ormEl = e.target.closest(".hevy-orm");
		if (ormEl) {
		  e.stopPropagation();
		  const exerciseName = ormEl.getAttribute("data-exercise");
		  const dKey = ormEl.getAttribute("data-date-key");
		  openOrmProgressModal(exerciseName, dKey);
		  return;
		}
	  };
	}

    /*
      ================================================
      = 13) Exercise Weight Progress Modal & Chart   =
      ================================================
    */
    function destroyExerciseProgressChart() {
      if(exerciseWeightProgressionChart) {
        exerciseWeightProgressionChart.destroy();
        exerciseWeightProgressionChart = null;
      }
    }
    function openExerciseProgressModal(exerciseName, repCount, dateKey) {
      document.querySelector("#exerciseWeightProgressionModal h2").textContent =
        `Weight progress at ${repCount} reps`;
      document.getElementById("exerciseProgressOverlay").classList.add("active");
      buildExerciseProgressChart(exerciseName, repCount, dateKey);
    }
    function closeExerciseProgressModal() {
      document.getElementById("exerciseProgressOverlay").classList.remove("active");
      destroyExerciseProgressChart();
    }
    function buildExerciseProgressChart(exerciseName, repCount, highlightDateKey) {
      const dateKeys = Object.keys(calendarData).sort();
      const dataMap = {};
      dateKeys.forEach(k => {
        const dayObj = calendarData[k];
        if(dayObj.hevyWorkouts && dayObj.hevyWorkouts.length > 0) {
          let maxWeightForThatDay = 0;
          dayObj.hevyWorkouts.forEach(w => {
            w.exercises.forEach(ex => {
              if(ex.title === exerciseName) {
                ex.sets.forEach(s => {
                  if(s.reps === repCount) {
                    if(s.weight_kg > maxWeightForThatDay) {
                      maxWeightForThatDay = s.weight_kg;
                    }
                  }
                });
              }
            });
          });
          if(maxWeightForThatDay > 0) {
            dataMap[k] = maxWeightForThatDay;
          }
        }
      });

      const chartKeys = Object.keys(dataMap).sort();
      if(chartKeys.length < 1) {
        destroyExerciseProgressChart();
        document.getElementById("exerciseProgressOverlay").classList.remove("active");
        showCustomAlert("No progression data found for that set.");
        return;
      }

      const dataPoints = chartKeys.map(k => ({ x: k, y: dataMap[k] }));
      const labels = chartKeys.map(k => {
        const d = parseDateKey(k);
        return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
      });
      const weights = dataPoints.map(dp => dp.y);
      const minWeight = Math.min(...weights);
      const maxWeight = Math.max(...weights);
      const suggestedMin = Math.max(0, minWeight - 1);
      const suggestedMax = maxWeight + 1;

      destroyExerciseProgressChart();
      const ctx = document.getElementById('exerciseWeightProgressionChart').getContext('2d');

      const { bgColors, borderColors, pointRadii } = buildHighlightArrays(
        dataPoints, highlightDateKey, 'rgba(119,221,119,1)', 'red', 4, 8
      );

      exerciseWeightProgressionChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: `${exerciseName} (${repCount} reps)`,
            data: dataPoints.map(dp => dp.y),
            borderColor: '#77DD77',
            backgroundColor: 'rgba(119,221,119,0.2)',
            fill: true,
            tension: 0.2,
            pointRadius: pointRadii,
            pointBackgroundColor: bgColors,
            pointBorderColor: borderColors,
            pointHoverRadius: 6
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              title: { display: true, text: 'Date' },
              ticks: { color: '#ccc' },
              grid: { color: '#555' }
            },
            y: {
              suggestedMin,
              suggestedMax,
              title: { display: true, text: 'Weight (kg)' },
              ticks: { color: '#ccc' },
              grid: { color: '#555' }
            }
          },
          plugins: {
            legend: { labels: { color: '#eee' } }
          }
        }
      });
    }

    /*
      ================================================
      = 14) Exercise Rep Progress Modal & Chart      =
      ================================================
    */
    function destroyRepProgressChart() {
      if(exerciseRepProgressionChart) {
        exerciseRepProgressionChart.destroy();
        exerciseRepProgressionChart = null;
      }
    }
    function openRepProgressModal(exerciseName, weight, dateKey) {
      document.querySelector("#exerciseRepProgressionModal h2").textContent =
        `Rep progress at ${weight}kg`;
      document.getElementById("repProgressOverlay").classList.add("active");
      buildRepProgressChart(exerciseName, weight, dateKey);
    }
    function closeRepProgressModal() {
      document.getElementById("repProgressOverlay").classList.remove("active");
      destroyRepProgressChart();
    }
    function buildRepProgressChart(exerciseName, weight, highlightDateKey) {
      const dateKeys = Object.keys(calendarData).sort();
      const dataMap = {};
      dateKeys.forEach(k => {
        const dayObj = calendarData[k];
        if(dayObj.hevyWorkouts && dayObj.hevyWorkouts.length > 0) {
          let maxRepForThatDay = 0;
          dayObj.hevyWorkouts.forEach(w => {
            w.exercises.forEach(ex => {
              if(ex.title === exerciseName) {
                ex.sets.forEach(s => {
                  if(Number(s.weight_kg) === Number(weight)) {
                    if(s.reps > maxRepForThatDay){
                      maxRepForThatDay = s.reps;
                    }
                  }
                });
              }
            });
          });
          if(maxRepForThatDay > 0) {
            dataMap[k] = maxRepForThatDay;
          }
        }
      });

      const chartKeys = Object.keys(dataMap).sort();
      if(chartKeys.length < 1) {
        destroyRepProgressChart();
        document.getElementById("repProgressOverlay").classList.remove("active");
        showCustomAlert("No rep progression data found for that set.");
        return;
      }

      const dataPoints = chartKeys.map(k => ({ x: k, y: dataMap[k] }));
      const labels = chartKeys.map(k => {
        const d = parseDateKey(k);
        return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
      });
      const reps = dataPoints.map(dp => dp.y);
      const minRep = Math.min(...reps);
      const maxRep = Math.max(...reps);
      const suggestedMin = Math.max(0, minRep - 1);
      const suggestedMax = maxRep + 1;

      destroyRepProgressChart();
      const ctx = document.getElementById('exerciseRepProgressionChart').getContext('2d');

      const { bgColors, borderColors, pointRadii } = buildHighlightArrays(
        dataPoints, highlightDateKey, 'rgba(255,165,0,1)', 'red', 4, 8
      );

      exerciseRepProgressionChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: `Repetitions: ${exerciseName} (${weight}kg)`,
            data: dataPoints.map(dp => dp.y),
            borderColor: '#FFA500',
            backgroundColor: 'rgba(255,165,0,0.2)',
            fill: true,
            tension: 0.2,
            pointRadius: pointRadii,
            pointBackgroundColor: bgColors,
            pointBorderColor: borderColors,
            pointHoverRadius: 6
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: { 
              title: { display: true, text: 'Date' }, 
              ticks: { color: '#ccc' }, 
              grid: { color: '#555' }
            },
            y: { 
              suggestedMin, 
              suggestedMax, 
              title: { display: true, text: 'Repetitions' }, 
              ticks: { color: '#ccc' }, 
              grid: { color: '#555' } 
            }
          },
          plugins: { legend: { labels: { color: '#eee' } } }
        }
      });
    }

    /*
      =======================================
      = 15) Volume Over Time (Day-Level)    =
      =======================================
    */
    function openVolumeModal(dateKey) {
      document.getElementById("volumeOverlay").classList.add("active");
      buildVolumeChart(dateKey);
    }
    function closeVolumeModal() {
      document.getElementById("volumeOverlay").classList.remove("active");
      if(volumeChart){
        volumeChart.destroy();
        volumeChart = null;
      }
    }
    function buildVolumeChart(highlightDateKey) {
      const dateKeys = Object.keys(calendarData)
        .filter(k => calendarData[k].hevyWorkouts && calendarData[k].hevyWorkouts.length > 0)
        .sort();

      const dataPoints = dateKeys.map(k => {
        const day = calendarData[k];
        let volume = 0;
        day.hevyWorkouts.forEach(w => {
          w.exercises.forEach(ex => {
            ex.sets.forEach(set => {
              volume += set.weight_kg * set.reps;
            });
          });
        });
        return { x: k, y: volume };
      });

      if(dataPoints.length < 1){
        showCustomAlert("No volume data found.");
        return;
      }
      const labels = dataPoints.map(dp => {
        const d = parseDateKey(dp.x);
        return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
      });

      const volumes = dataPoints.map(dp => dp.y);
      const minVolume = Math.min(...volumes);
      const maxVolume = Math.max(...volumes);
      const suggestedMin = Math.max(0, minVolume - 10);
      const suggestedMax = maxVolume + 10;

      if(volumeChart){
        volumeChart.destroy();
        volumeChart = null;
      }
      const ctx = document.getElementById('volumeChart').getContext('2d');

      const { bgColors, borderColors, pointRadii } = buildHighlightArrays(
        dataPoints, highlightDateKey, 'rgba(255,165,0,1)', 'red', 2, 6
      );

      volumeChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Volume (kg)',
            data: dataPoints.map(dp => dp.y),
            borderColor: '#FFA500',
            backgroundColor: 'rgba(255,165,0,0.2)',
            fill: true,
            tension: 0.2,
            pointRadius: pointRadii,
            pointBackgroundColor: bgColors,
            pointBorderColor: borderColors,
            pointHoverRadius: 4
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: { 
              title: { display: true, text: 'Date' }, 
              ticks: { color: '#ccc' }, 
              grid: { color: '#555' }
            },
            y: { 
              suggestedMin, 
              suggestedMax, 
              title: { display: true, text: 'Volume (kg)' }, 
              ticks: { color: '#ccc' }, 
              grid: { color: '#555' } 
            }
          },
          plugins: { legend: { labels: { color: '#eee' } } }
        }
      });
    }

    /*
      =======================================
      = 16) Per-Exercise Volume Chart       =
      =======================================
    */
    function openExerciseVolumeModal(exerciseName, dateKey) {
      document.getElementById("exerciseVolumeOverlay").classList.add("active");
      buildExerciseVolumeProgressionChart(exerciseName, dateKey);
    }
    function closeExerciseVolumeModal() {
      document.getElementById("exerciseVolumeOverlay").classList.remove("active");
      destroyExerciseVolumeChart();
    }
    function destroyExerciseVolumeChart() {
      if(exerciseVolumeChart) {
        exerciseVolumeChart.destroy();
        exerciseVolumeChart = null;
      }
    }
    function buildExerciseVolumeProgressionChart(exerciseName, highlightDateKey) {
      const dateKeys = Object.keys(calendarData).sort();
      const dataMap = {}; 

      dateKeys.forEach(k => {
        const dayObj = calendarData[k];
        if(dayObj.hevyWorkouts && dayObj.hevyWorkouts.length > 0) {
          let exerciseVolume = 0;
          dayObj.hevyWorkouts.forEach(workout => {
            workout.exercises.forEach(ex => {
              if(ex.title === exerciseName) {
                ex.sets.forEach(s => {
                  exerciseVolume += (s.weight_kg * s.reps);
                });
              }
            });
          });
          if(exerciseVolume > 0) {
            dataMap[k] = exerciseVolume;
          }
        }
      });

      const chartKeys = Object.keys(dataMap).sort();
      if(chartKeys.length < 1) {
        destroyExerciseVolumeChart();
        document.getElementById("exerciseVolumeOverlay").classList.remove("active");
        showCustomAlert(`No volume data found for '${exerciseName}'.`);
        return;
      }

      const dataPoints = chartKeys.map(k => ({ x: k, y: dataMap[k] }));
      const labels = chartKeys.map(k => {
        const d = parseDateKey(k);
        return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
      });

      const volumes = dataPoints.map(dp => dp.y);
      const minV = Math.min(...volumes);
      const maxV = Math.max(...volumes);
      const range = maxV - minV;
      const pad = range * 0.1;
      const suggestedMin = (minV - pad < 0) ? 0 : (minV - pad);
      const suggestedMax = maxV + pad;

      destroyExerciseVolumeChart();
      const ctx = document.getElementById('exerciseVolumeChart').getContext('2d');

      const { bgColors, borderColors, pointRadii } = buildHighlightArrays(
        dataPoints, highlightDateKey, 'rgba(77,221,255,1)', 'red', 4, 8
      );

      exerciseVolumeChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: `Volume: ${exerciseName}`,
            data: dataPoints.map(dp => dp.y),
            borderColor: '#4DDCFF',
            backgroundColor: 'rgba(77,221,255,0.2)',
            fill: true,
            tension: 0.2,
            pointRadius: pointRadii,
            pointBackgroundColor: bgColors,
            pointBorderColor: borderColors,
            pointHoverRadius: 6
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: { 
              title: { display: true, text: 'Date' }, 
              ticks: { color: '#ccc' }, 
              grid: { color: '#555' }
            },
            y: { 
              suggestedMin, 
              suggestedMax, 
              title: { display: true, text: 'Exercise Volume (kg)' }, 
              ticks: { color: '#ccc' }, 
              grid: { color: '#555' } 
            }
          },
          plugins: { legend: { labels: { color: '#eee' } } }
        }
      });
    }

    /*
      =======================================
      = 17) ORM Progress Over Time Chart    =
      =======================================
    */
    function openOrmProgressModal(exerciseName, dateKey) {
      document.getElementById("ormProgressOverlay").classList.add("active");
      buildExerciseOrmProgressChart(exerciseName, dateKey);
    }
    function closeOrmProgressModal() {
      document.getElementById("ormProgressOverlay").classList.remove("active");
      destroyOrmProgressChart();
    }
    function destroyOrmProgressChart() {
      if(exerciseOrmProgressChart) {
        exerciseOrmProgressChart.destroy();
        exerciseOrmProgressChart = null;
      }
    }
    function buildExerciseOrmProgressChart(exerciseName, highlightDateKey) {
      const dateKeys = Object.keys(calendarData).sort();
      const dataMap = {};

      dateKeys.forEach(k => {
        let dayMaxOrm = 0;
        const dayObj = calendarData[k];
        if(dayObj.hevyWorkouts) {
          dayObj.hevyWorkouts.forEach(workout => {
            workout.exercises.forEach(ex => {
              if(ex.title === exerciseName) {
                ex.sets.forEach(s => {
                  const setOrm = computeOrm(s.weight_kg, s.reps);
                  if(setOrm > dayMaxOrm) {
                    dayMaxOrm = setOrm;
                  }
                });
              }
            });
          });
        }
        if(dayMaxOrm > 0) {
          dataMap[k] = dayMaxOrm;
        }
      });

      const chartKeys = Object.keys(dataMap).sort();
      if(chartKeys.length < 1) {
        destroyOrmProgressChart();
        document.getElementById("ormProgressOverlay").classList.remove("active");
        showCustomAlert(`No ORM data found for '${exerciseName}'.`);
        return;
      }

      const dataPoints = chartKeys.map(k => ({ x: k, y: dataMap[k] }));
      const labels = chartKeys.map(k => {
        const d = parseDateKey(k);
        return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
      });

      const orms = dataPoints.map(dp => dp.y);
      const minOrm = Math.min(...orms);
      const maxOrm = Math.max(...orms);
      const range = maxOrm - minOrm;
      const pad = range * 0.1;
      const suggestedMin = (minOrm - pad < 0) ? 0 : (minOrm - pad);
      const suggestedMax = maxOrm + pad;

      destroyOrmProgressChart();
      const ctx = document.getElementById('exerciseOrmProgressChart').getContext('2d');

      const { bgColors, borderColors, pointRadii } = buildHighlightArrays(
        dataPoints, highlightDateKey, 'rgba(255,255,0,1)', 'red', 4, 8
      );

      exerciseOrmProgressChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: `ORM: ${exerciseName}`,
            data: dataPoints.map(dp => dp.y),
            borderColor: '#FFFF00',
            backgroundColor: 'rgba(255,255,0,0.2)',
            fill: true,
            tension: 0.2,
            pointRadius: pointRadii,
            pointBackgroundColor: bgColors,
            pointBorderColor: borderColors,
            pointHoverRadius: 6
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              title: { display: true, text: 'Date' },
              ticks: { color: '#ccc' },
              grid: { color: '#555' }
            },
            y: {
              suggestedMin,
              suggestedMax,
              title: { display: true, text: 'Estimated 1RM (kg)' },
              ticks: { color: '#ccc' },
              grid: { color: '#555' }
            }
          },
          plugins: {
            legend: { labels: { color: '#eee' } }
          }
        }
      });
    }

    /*
      =======================================
      = 18) Populate Calendar Button        =
      =======================================
    */
    function populateEntireCalendar() {
      const cycleDataArray = Array.from(selectedDates).sort();
      if(cycleDataArray.length === 0){
        showCustomAlert("No cycle selected.");
        return;
      }

      const sortedCycle = cycleDataArray.map(k => parseDateKey(k)).sort((a,b) => a - b);
      const sortedCycleKeys = sortedCycle.map(d => getDateKey(d));
      const cyclePattern = sortedCycleKeys.map(k => ({ ...getDayData(k) }));
      const patternLength = cyclePattern.length;
      const startDate = new Date(sortedCycle[0].getTime());

      const firstOfYear = new Date(2025, 0, 1);
      const lastOfYear = new Date(2025, 11, 31);

      // Backwards
      let currentDate = new Date(startDate.getTime());
      let cycleIndex = cyclePattern.length;
      while(currentDate > firstOfYear){
        currentDate.setDate(currentDate.getDate() -1);
        cycleIndex = (cycleIndex -1 + patternLength) % patternLength;
        const dateKey = getDateKey(currentDate);
        const cycleData = cyclePattern[cycleIndex];
        calendarData[dateKey] = {
          shiftClass: cycleData.shiftClass,
          gym: cycleData.gym,
          gymTime: cycleData.gymTime,
          workTime: cycleData.workTime,
          completed: cycleData.completed,
          weight: cycleData.weight,
          alert: cycleData.alert,
          hevyWorkouts: cycleData.hevyWorkouts ? [...cycleData.hevyWorkouts] : []
        };
      }

      // Forwards
      currentDate = new Date(startDate.getTime());
      cycleIndex = 0;
      while(currentDate <= lastOfYear){
        const dateKey = getDateKey(currentDate);
        const cycleData = cyclePattern[cycleIndex % cyclePattern.length];
        calendarData[dateKey] = {
          shiftClass: cycleData.shiftClass,
          gym: cycleData.gym,
          gymTime: cycleData.gymTime,
          workTime: cycleData.workTime,
          completed: cycleData.completed,
          weight: cycleData.weight,
          alert: cycleData.alert,
          hevyWorkouts: cycleData.hevyWorkouts ? [...cycleData.hevyWorkouts] : []
        };
        cycleIndex++;
        currentDate.setDate(currentDate.getDate() + 1);
      }

      defaultCycleData = {
        pattern: [...cyclePattern],
        startDate: getDateKey(sortedCycle[0])
      };
      localStorage.setItem(LS_DEFAULT_CYCLE_KEY, JSON.stringify(defaultCycleData));
      localStorage.setItem(LS_CALENDAR_DATA_KEY, JSON.stringify(calendarData));

      selectedDates.clear();
      renderCalendar(currentYear, currentMonth);
      showCustomAlert("Calendar has been successfully populated with your custom cycle.");
    }
    function updatePopulateCalendarButtonState() {
      const btn = document.getElementById("populateCalendarBtn");
      if(selectedDates.size >=2){
        btn.disabled = false;
        btn.style.opacity = "1";
        btn.style.border = "2px solid gold";
      }
      else{
        btn.disabled = true;
        btn.style.opacity = "0.5";
        btn.style.border = "2px solid #555";
      }
    }

    /*
      =======================================
      =  19)  Clear Calendar Function       =
      =======================================
    */
    function clearCalendar() {
      showCustomConfirm("Are you sure you want to clear the entire calendar? This will remove all your data and set all days to 'None'. This action cannot be undone.", () => {
        const startDate = new Date(2025, 0, 1);
        const endDate = new Date(2025, 11, 31);
        const totalDays = Math.floor((endDate - startDate) / MS_IN_DAY) + 1;

        for(let i = 0; i < totalDays; i++){
          const currentDate = new Date(startDate.getTime() + i * MS_IN_DAY);
          const dateKey = getDateKey(currentDate);
          calendarData[dateKey] = {
            shiftClass: "off-bg",
            gym: "None",
            gymTime: "",
            workTime: "",
            completed: false,
            weight: null,
            alert: null,
            hevyWorkouts: []
          };
        }

        localStorage.setItem(LS_CALENDAR_DATA_KEY, JSON.stringify(calendarData));
        defaultCycleData = { pattern: [], startDate: null };
        localStorage.setItem(LS_DEFAULT_CYCLE_KEY, JSON.stringify(defaultCycleData));

        selectedDates.clear();
        renderCalendar(currentYear, currentMonth);
        showCustomAlert("Calendar has been cleared. All days are now set to 'None'.");
      });
    }

    /*
      =======================================
      =  20)  Custom Alert/Prompt/Confirm   =
      =======================================
    */
    function showCustomAlert(message) {
      const overlay = document.getElementById("customAlertOverlay");
      const messageElem = document.getElementById("customAlertMessage");
      const inputElem = document.getElementById("customAlertInput");
      const confirmButtons = document.getElementById("customConfirmButtons");
      const defaultButton = document.getElementById("customDefaultButton");

      messageElem.textContent = message;
      inputElem.style.display = "none";
      confirmButtons.style.display = "none";
      defaultButton.style.display = "block";

      overlay.classList.add("active");
    }
    function showCustomConfirm(message, onConfirm) {
      const overlay = document.getElementById("customAlertOverlay");
      const messageElem = document.getElementById("customAlertMessage");
      const inputElem = document.getElementById("customAlertInput");
      const confirmButtons = document.getElementById("customConfirmButtons");
      const defaultButton = document.getElementById("customDefaultButton");

      messageElem.textContent = message;
      inputElem.style.display = "none";
      confirmButtons.style.display = "flex";
      defaultButton.style.display = "none";

      // Remove old buttons if any
      const existingYes = document.getElementById("customYesBtn");
      const existingNo = document.getElementById("customNoBtn");
      if(existingYes) existingYes.remove();
      if(existingNo) existingNo.remove();

      const yesButton = document.createElement("button");
      yesButton.id = "customYesBtn";
      yesButton.textContent = "Yes";
      yesButton.onclick = () => {
        overlay.classList.remove("active");
        onConfirm();
      };

      const noButton = document.createElement("button");
      noButton.id = "customNoBtn";
      noButton.textContent = "No";
      noButton.onclick = () => {
        overlay.classList.remove("active");
      };

      confirmButtons.appendChild(yesButton);
      confirmButtons.appendChild(noButton);
      overlay.classList.add("active");
    }
    function showCustomPrompt(message, placeholder, callback) {
      const overlay = document.getElementById("customAlertOverlay");
      const messageElem = document.getElementById("customAlertMessage");
      const inputElem = document.getElementById("customAlertInput");
      const confirmButtons = document.getElementById("customConfirmButtons");
      const defaultButton = document.getElementById("customDefaultButton");

      messageElem.textContent = message;
      inputElem.style.display = "block";
      inputElem.placeholder = placeholder || "";
      confirmButtons.style.display = "flex";
      defaultButton.style.display = "none";

      // Remove old buttons if any
      const existingYes = document.getElementById("customYesBtn");
      const existingNo = document.getElementById("customNoBtn");
      if(existingYes) existingYes.remove();
      if(existingNo) existingNo.remove();

      const yesButton = document.createElement("button");
      yesButton.id = "customYesBtn";
      yesButton.textContent = "OK";
      yesButton.onclick = () => {
        const inputVal = inputElem.value.trim();
        overlay.classList.remove("active");
        callback(inputVal);
      };

      const noButton = document.createElement("button");
      noButton.id = "customNoBtn";
      noButton.textContent = "Cancel";
      noButton.onclick = () => {
        overlay.classList.remove("active");
      };

      confirmButtons.appendChild(yesButton);
      confirmButtons.appendChild(noButton);

      inputElem.value = "";
      overlay.classList.add("active");
    }
    function closeCustomAlert() {
      const overlay = document.getElementById("customAlertOverlay");
      const messageElem = document.getElementById("customAlertMessage");
      const inputElem = document.getElementById("customAlertInput");
      const confirmButtons = document.getElementById("customConfirmButtons");
      const defaultButton = document.getElementById("customDefaultButton");

      const yesBtn = document.getElementById("customYesBtn");
      const noBtn = document.getElementById("customNoBtn");
      if(yesBtn) yesBtn.remove();
      if(noBtn) noBtn.remove();

      messageElem.textContent = "";
      inputElem.style.display = "none";
      confirmButtons.style.display = "none";
      defaultButton.style.display = "block";

      overlay.classList.remove("active");
    }

    /*
      =======================================
      = 21) DOM Loaded: Event Setup         =
      =======================================
    */
    window.addEventListener("DOMContentLoaded", () => {
      buildColorSwatches();

      // Single modal
      document.getElementById("singleSaveBtn").addEventListener("click", saveSingleModal);
      document.getElementById("singleRevertBtn").addEventListener("click", revertSingleModal);
      document.getElementById("singleCancelBtn").addEventListener("click", closeSingleModal);
      document.querySelectorAll("#singleModal .reset-emoji").forEach(btn => {
        btn.addEventListener("click", () => { resetSingleField(btn.getAttribute("data-field")); });
      });

      // Multi modal
      document.getElementById("multiKeySelect").addEventListener("change", handleMultiKeyChange);
      document.getElementById("multiSaveBtn").addEventListener("click", saveMultiModal);
      document.getElementById("multiRevertBtn").addEventListener("click", revertMultiModal);
      document.getElementById("multiCancelBtn").addEventListener("click", closeMultiModal);

      // Stats
      document.getElementById("statsBtn").addEventListener("click", openStatsModal);
      document.getElementById("statsCloseBtn").addEventListener("click", closeStatsModal);

      // Backup
      document.getElementById("saveDataBtn").addEventListener("click", saveData);
      document.getElementById("loadDataBtn").addEventListener("click", () => {
        document.getElementById("importFileInput").click();
      });
      document.getElementById("importFileInput").addEventListener("change", (event) => {
        const file = event.target.files[0];
        if(file) {
          showCustomConfirm("Loading data will overwrite your current calendar data. Proceed?", () => {
            loadData(file);
          });
        }
        event.target.value = "";
      });

      // Hevy import
      document.getElementById("hevyImportBtn").addEventListener("click", () => {
        showCustomPrompt("Enter your Hevy API key:", "API Key", (apiKey) => {
          if(apiKey){
            importHevyData(apiKey);
          } else {
            showCustomAlert("Hevy API key is required to import data.");
          }
        });
      });

      // Populate calendar
      document.getElementById("populateCalendarBtn").addEventListener("click", () => {
        showCustomConfirm("Populate the calendar with the selected cycle? This will overwrite existing data for those days.", () => {
          populateEntireCalendar();
        });
      });

      // Hevy summary modal
      document.getElementById("hevyCloseBtn").addEventListener("click", closeHevyModal);

      // Volume chart modal
      document.getElementById("volumeCloseBtn").addEventListener("click", closeVolumeModal);

      // Exercise volume chart modal
      document.getElementById("exerciseVolumeCloseBtn").addEventListener("click", closeExerciseVolumeModal);

      // Exercise progress modals
      document.getElementById("exerciseProgressCloseBtn").addEventListener("click", closeExerciseProgressModal);
      document.getElementById("repProgressCloseBtn").addEventListener("click", closeRepProgressModal);

      // ORM progress modal
      document.getElementById("ormProgressCloseBtn").addEventListener("click", closeOrmProgressModal);

      // Clear Calendar
      document.getElementById("clearCalendarBtn").addEventListener("click", clearCalendar);

      // Help
      document.getElementById("helpBtn").addEventListener("click", () => {
        showCustomAlert("Help feature is coming soon!");
      });

      // Calendar cell selection
      document.addEventListener("mousedown", (e) => {
        // If overlay or a button is clicked, skip
        if(document.querySelector(".overlay.active")) return;
        if(e.target.closest("button")) return;

        // Middle mouse => open Hevy
        if (e.button === 1) {
          e.preventDefault();
          const dayCell = e.target.closest(".day-cell");
          if (dayCell) {
            const dateKey = dayCell.getAttribute("data-date-key");
            if (dateKey) {
              openHevyModal(dateKey);
            }
          }
          return;
        }

        if(e.target.closest(".refresh-emoji") || e.target.closest(".completed-badge")) return;
        e.preventDefault();

        const dayCell = e.target.closest(".day-cell");
        if(!dayCell){
          selectedDates.clear();
          renderCalendar(currentYear, currentMonth);
          return;
        }
        isDragging = true;

        if(!e.ctrlKey && !e.metaKey){
          selectedDates.clear();
        }

        const startRow = parseInt(dayCell.getAttribute("data-row"), 10);
        const startCol = parseInt(dayCell.getAttribute("data-col"), 10);
        const dateKey = dayCell.getAttribute("data-date-key");
        if(dateKey) selectedDates.add(dateKey);
        renderCalendar(currentYear, currentMonth);

        const mouseMoveHandler = (moveEvent) => {
          if(!isDragging) return;
          const cell = moveEvent.target.closest(".day-cell");
          if(cell){
            const row = parseInt(cell.getAttribute("data-row"), 10);
            const col = parseInt(cell.getAttribute("data-col"), 10);
            const minRow = Math.min(startRow, row);
            const maxRow = Math.max(startRow, row);
            const minCol = Math.min(startCol, col);
            const maxCol = Math.max(startCol, col);

            if(!moveEvent.ctrlKey && !moveEvent.metaKey){
              selectedDates.clear();
            }
            const allCells = document.querySelectorAll(".calendar-grid .day-cell");
            allCells.forEach(c => {
              const r = parseInt(c.getAttribute("data-row"), 10);
              const cc = parseInt(c.getAttribute("data-col"), 10);
              if(r >= minRow && r <= maxRow && cc >= minCol && cc <= maxCol){
                const dk = c.getAttribute("data-date-key");
                if(dk) selectedDates.add(dk);
              }
            });
            renderCalendar(currentYear, currentMonth);
          }
        };
        const mouseUpHandler = () => {
          isDragging = false;
          document.removeEventListener("mousemove", mouseMoveHandler);
          document.removeEventListener("mouseup", mouseUpHandler);
        };
        document.addEventListener("mousemove", mouseMoveHandler);
        document.addEventListener("mouseup", mouseUpHandler);
      });

      renderCalendar(currentYear, currentMonth);
    });
  </script>
</body>
</html>
