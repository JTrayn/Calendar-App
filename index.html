<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Multi-Year Calendar (2020-2030) + Hevy Chart</title>

  <!-- Include Chart.js from a CDN -->
  <script src="exercise_templates.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700;900&display=swap');

	/* =========================================
	   1) IMPORTS & FONT / BASE RESET
	   ========================================= */
	@import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700;900&display=swap');
	* {
	  margin: 0;
	  padding: 0;
	  box-sizing: border-box;
	}
	html, body {
	  height: 100%;
	  width: 100%;
	  background: #1E1E1E;
	  color: #EAEAEA;
	  font-family: 'Montserrat', sans-serif;
	  user-select: none;
	}

	/* =========================================
	   2) BODY LAYOUT & MAIN WRAPPER
	   ========================================= */
	body {
	  display: flex;
	  justify-content: center;
	  align-items: center;
	}
	.main-wrapper {
	  background: rgba(50, 50, 50, 0.5);
	  padding: 1rem;
	  border-radius: 8px;
	  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
	  max-width: 800px;
	  width: 1000px;
	  margin: 20px auto;
	  display: flex;
	  flex-direction: column;
	  align-items: center;
	  backdrop-filter: blur(2px);
	  -webkit-backdrop-filter: blur(2px);
	}

	/* =========================================
	   3) MONTH BAR & NAVIGATION BUTTONS
	   ========================================= */
	.month-bar {
	  display: flex;
	  flex-direction: row;
	  align-items: center;
	  margin-bottom: 1rem;
	  width: 100%;
	  justify-content: center;
	}
	.month-title {
	  font-size: 1.1rem;
	  font-weight: 700;
	  padding: 0.2rem 0.5rem;
	  width: 200px;
	  text-align: center;
	  white-space: nowrap;
	}
	.arrow-buttons {
	  display: inline-flex;
	  align-items: center;
	  gap: 0.5rem;
	  margin-left: 2rem;
	}
	.month-nav-buttons {
	  display: inline-flex;
	  gap: 0.5rem;
	}
	.data-buttons {
	  display: inline-flex;
	  gap: 0.5rem;
	  margin-left: 1.5rem;
	  align-items: center;
	}
	.arrow-button {
	  background-color: rgba(51, 51, 51, 0.3);
	  border: 0px solid #555;
	  color: #EAEAEA;
	  cursor: pointer;
	  font-size: 1rem;
	  min-width: 2rem;
	  height: 2rem;
	  border-radius: 4px;
	  text-align: center;
	  line-height: 2rem;
	  padding: 0 0.5rem;
	  transition: background-color 0.2s, border 0.2s;
	  display: flex;
	  align-items: center;
	  justify-content: center;
	}
	.arrow-button:hover {
	  background-color: #444;
	}
	.arrow-button:disabled {
	  background-color: #555;
	  cursor: not-allowed;
	  opacity: 0.5;
	}
	.arrow-button img {
	  vertical-align: middle;
	  display: inline-block;
	  position: relative;
	  top: -1px;
	}

	/* =========================================
	   4) CALENDAR LAYOUT
	   ========================================= */
	.calendar-container {
	  width: 100%;
	  max-width: 700px;
	}
	.calendar-header,
	.calendar-grid {
	  display: grid;
	  grid-template-columns: repeat(7, 1fr);
	  gap: 0.3rem;
	}
	.calendar-header div {
	  text-align: center;
	  font-weight: bold;
	  padding: 0.5rem 0;
	  border-bottom: 1px solid rgba(68, 68, 68, 0.5);
	  font-size: 0.85rem;
	}
	.calendar-grid {
	  margin-top: 0.5rem;
	}

	/* =========================================
	   5) DAY CELL STYLES
	   ========================================= */
	.day-cell {
	  aspect-ratio: 1 / 1;
	  border-radius: 2px;
	  position: relative;
	  overflow: hidden;
	  display: flex;
	  flex-direction: column;
	  justify-content: center;
	  align-items: center;
	  font-size: 0.8rem;
	  cursor: pointer;
	  transition: all 0.2s ease-in-out;
	  padding: 0.5rem;
	}
	.day-cell:hover {
	  outline: 2px solid #888;
	}
	.faded {
	  opacity: 0.15;
	  pointer-events: none;
	}

	.off-bg {
	  background-color: #3A3A3A;
	  opacity: 0.8;
	}
	.al-bg {
	  background-color: #616161;
	  opacity: 0.9;
	}
	.custom-shift {}
	.selected {
	  outline: 2px solid limegreen !important;
	}
	.today {
	  outline: 3px solid #FFD700;
	}

	/* =========================================
	   6) DAY CELL CONTENT (ICONS, TEXT, ETC.)
	   ========================================= */
	.date-num {
	  position: absolute;
	  top: 4px;
	  left: 6px;
	  font-weight: bold;
	  font-size: 0.75rem;
	  color: rgba(255,255,255,0.8);
	  white-space: nowrap;
	  pointer-events: none;
	}
	.refresh-emoji {
	  position: absolute;
	  top: 4px;
	  right: 6px;
	  font-size: 1rem;
	  z-index: 3;
	  cursor: pointer;
	  opacity: 0.15;
	  transition: opacity 0.2s;
	}
	.refresh-emoji:hover {
	  opacity: 1.0;
	}
	.weight-display {
	  position: absolute;
	  top: 42%;
	  left: 50%;
	  transform: translate(-50%, -50%);
	  font-size: 0.9rem;
	  text-align: center;
	  white-space: nowrap;
	  color: #FFF;
	  font-weight: bold;
	  pointer-events: none;
	}
	.shift-time-text {
	  position: absolute;
	  top: 60%;
	  left: 50%;
	  transform: translate(-50%, -50%);
	  font-size: 1rem;
	  font-weight: bold;
	  white-space: nowrap;
	  color: rgba(0, 0, 0, 0.3);
	  pointer-events: none;
	}
	.free-time-text {
	  position: absolute;
	  top: 10%;
	  left: 50%;
	  transform: translate(-50%, -50%);
	  font-size: 0.65rem;
	  font-weight: bold;
	  white-space: nowrap;
	  color: rgba(0, 0, 0, 0.3);
	  pointer-events: none;
	}
	.workout-info {
	  position: absolute;
	  bottom: 4px;
	  left: 0;
	  right: 0;
	  text-align: center;
	  font-size: 0.75rem;
	  line-height: 1.1;
	  color: #FFF;
	  opacity: 0.75;
	  pointer-events: none;
	}

	/* =========================================
	   7) COMPLETED BADGE
	   ========================================= */
	.completed-badge {
	  position: absolute;
	  bottom: 4px;
	  right: 4px;
	  width: 24px;
	  height: 24px;
	  border-radius: 50%;
	  background-color: #28a745;
	  color: #fff;
	  font-size: 1rem;
	  text-align: center;
	  line-height: 24px;
	  box-shadow: 0 0 5px rgba(0,0,0,0.5);
	  cursor: pointer;
	  user-select: none;
	  transition: opacity 0.2s ease-out, transform 0.2s ease-out;
	  opacity: 0;
	}
	.day-cell:hover .completed-badge:not(.enabled) {
	  opacity: 0.3;
	}
	.day-cell.completed .completed-badge.enabled {
	  opacity: 1.0;
	}
	.completed-badge:hover {
	  transform: scale(1.1);
	  opacity: 1.0;
	}

	/* =========================================
	   8) ALERT OVERLAY & TEXT
	   ========================================= */
	.alert-overlay {
	  position: absolute;
	  top: 0;
	  left: 0;
	  right: 0;
	  height: 50%;
	  pointer-events: none;
	}
	.alert-text {
	  position: absolute;
	  top: 1.2rem;
	  left: 0;
	  right: 0;
	  margin: 0 auto;
	  width: 80%;
	  text-align: center;
	  font-size: 0.65rem;
	  font-weight: bold;
	  color: #fff;
	  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.6);
	  white-space: nowrap;
	  overflow: hidden;
	  text-overflow: ellipsis;
	  pointer-events: none;
	}

	/* =========================================
	   9) MODAL OVERLAYS: BASE STYLES
	   ========================================= */
	.overlay {
	  display: none;
	  position: fixed;
	  top: 0;
	  left: 0;
	  width: 100%;
	  height: 100%;
	  background-color: rgba(0,0,0,0.6);
	  justify-content: center;
	  align-items: center;
	  opacity: 0;
	  transition: opacity 0.3s ease;
	}
	.overlay.active {
	  display: flex;
	  opacity: 1;
	}
	.modal {
	  position: relative;
	  background: #2D2D2D;
	  padding: 1.5rem;
	  border-radius: 6px;
	  width: 420px;
	  box-shadow: 0 2px 10px rgba(0,0,0,0.7);
	  display: flex;
	  flex-direction: column;
	  gap: 0.1rem;
	  transform: translateY(-20px);
	  animation: slideDownFade 0.3s forwards;
	}
	@keyframes slideDownFade {
	  0% {
		opacity: 0;
		transform: translateY(-20px);
	  }
	  100% {
		opacity: 1;
		transform: translateY(0);
	  }
	}
	.modal h2 {
	  font-size: 1.2rem;
	  margin-bottom: 0.5rem;
	  text-align: center;
	}
	.modal-buttons {
	  display: flex;
	  justify-content: space-between;
	  gap: 1rem;
	  margin-top: 0.5rem;
	}
	.modal-buttons button {
	  flex: 1;
	  cursor: pointer;
	  padding: 0.5rem;
	  font-size: 0.9rem;
	  border: 1px solid #555;
	  border-radius: 4px;
	  background: #444;
	  color: #EAEAEA;
	  transition: background-color 0.2s;
	}
	.modal-buttons button:hover {
	  background: #555;
	}

	/* =========================================
	   10) SINGLE-CELL EDIT MODAL (#singleModal)
	   ========================================= */
	#singleOverlay .modal#singleModal {
	  width: 420px;
	  padding: 1rem;
	  padding-bottom: 0rem;
	  max-height: 80vh; /* Increased to restore taller appearance */
	  overflow-y: auto;
	  display: flex;
	  flex-direction: column;
	}
	#singleModal h2 {
	  font-size: 1.1rem;
	  color: #EAEAEA;
	  margin-bottom: 0rem;
	  text-align: center;
	  padding-bottom: 0.4rem;
	  border-bottom: 1px solid #444;
	}
	#singleModal .modal-date {
	  position: static;
	  margin-top: 0.5rem;
	  margin-bottom: 0.5rem;
	  text-align: center;
	  font-size: 0.9rem;
	  color: #888;
	}
	#singleModal .modal-subtitle {
	  text-align: center;
	  color: #888;
	  font-size: 0.9rem;
	  margin: -1rem 0 0rem 0;
	}
	#singleModal .modal-row {
	  display: flex;
	  flex-direction: column;
	  gap: 0.25rem;
	  background: #393939;
	  padding: 0.5rem;
	  border-radius: 6px;
	  margin-bottom: 0.35rem;
	  transition: background-color 0.2s;
	}
	#singleModal .modal-row:hover {
	  background: #424242;
	}
	#singleModal .modal-row label {
	  font-size: 0.9rem;
	  display: flex;
	  align-items: center;
	  gap: 0.5rem;
	  justify-content: flex-start;
	}
	#singleModal .reset-emoji {
	  cursor: pointer;
	  opacity: 0.5;
	  transition: all 0.2s;
	  font-size: 1rem;
	  padding: 4px;
	  border-radius: 4px;
	  margin-left: auto;
	}
	#singleModal .reset-emoji:hover {
	  opacity: 1;
	  transform: rotate(180deg);
	}
	#singleModal select,
	#singleModal input[type="text"] {
	  width: 100%;
	  padding: 0.35rem;
	  background: #2D2D2D;
	  border: 1px solid #555;
	  border-radius: 4px;
	  color: #EAEAEA;
	  font-size: 0.8rem;
	  transition: all 0.2s;
	  height: 28px;
	}
	#singleModal select:hover,
	#singleModal input[type="text"]:hover {
	  border-color: #666;
	}
	#singleModal select:focus,
	#singleModal input[type="text"]:focus {
	  border-color: #4DAAFF;
	  outline: none;
	  box-shadow: 0 0 0 2px rgba(77, 170, 255, 0.2);
	}
	#singleModal .color-swatches {
	  display: grid;
	  grid-template-columns: repeat(auto-fit, minmax(32px, 1fr));
	  gap: 0.5rem;
	  margin-top: 0.5rem;
	}
	#singleModal .swatch {
	  aspect-ratio: 1;
	  border-radius: 4px;
	  cursor: pointer;
	  border: 2px solid transparent;
	  transition: all 0.2s;
	}
	#singleModal .swatch:hover {
	  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
	}
	#singleModal .swatch.active {
	  border-color: #4DAAFF;
	  box-shadow: 0 0 0 2px rgba(77, 170, 255, 0.3);
	}
	#singleModal .shift-label-text {
	  color: #4DAAFF;
	  font-weight: 500;
	  font-size: 0.85rem;
	  margin-left: 0.5rem;
	  flex-grow: 1;
	}
	#singleModal .modal-buttons {
	  display: grid;
	  grid-template-columns: 1fr auto 1fr;
	  gap: 0.5rem;
	  padding-top: 0.5rem;
	  padding-bottom: 0.5rem;
	  border-top: 1px solid #444;
	  margin-top: auto;
	  position: sticky;
	  bottom: 0;
	  background: #2D2D2D;
	}
	#singleModal #singleSaveBtn {
	  background: #4DAAFF;
	  color: white;
	}
	#singleModal #singleSaveBtn:hover {
	  background: #82c3ff;
	}
	#singleModal #singleRevertBtn {
	  background: #555;
	  color: #EEE;
	  font-size: 1.2rem;
	  padding: 0.4rem 1rem;
	}
	#singleModal #singleRevertBtn:hover {
	  background: #666;
	}
	#singleModal #singleCancelBtn {
	  background: #444;
	  color: #EEE;
	}
	#singleModal #singleCancelBtn:hover {
	  background: #555;
	}
	#singleModal select:disabled,
	#singleModal input[type="text"]:disabled {
	  background: #333;
	  border-color: #444;
	  color: #666;
	  cursor: not-allowed;
	}
	#singleModal #singleAlertTypeSelect option {
	  padding: 0.5rem;
	  background: #2D2D2D;
	}
	#singleColorSwatchesContainer .swatch.off-bg {
	  background-color: #2D2D2D;
	}
	#singleRevertBtn .rotate-emoji {
	  display: inline-block;
	  transition: transform 0.2s;
	}
	#singleRevertBtn:hover .rotate-emoji {
	  transform: rotate(180deg);
	}

	/* =========================================
	   11) MULTI-CELL EDIT MODAL (#multiModal)
	   ========================================= */
	#multiOverlay .modal#multiModal {
	  background: #2D2D2D;
	  border-radius: 8px;
	  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
	  width: 380px;
	  padding: 1rem;
	  max-height: 50vh;
	  overflow-y: auto;
	  display: flex;
	  flex-direction: column;
	}
	#multiModal h2 {
	  font-size: 1.1rem;
	  color: #EAEAEA;
	  margin-bottom: 0.5rem;
	  text-align: center;
	  padding-bottom: 0.4rem;
	  border-bottom: 1px solid #444;
	}
	#multiModal .modal-row {
	  display: flex;
	  flex-direction: column;
	  gap: 0.25rem;
	  background: #393939;
	  padding: 0.5rem;
	  border-radius: 6px;
	  margin-bottom: 0.35rem;
	  transition: background-color 0.2s;
	}
	#multiModal .modal-row:hover {
	  background: #424242;
	}
	#multiModal .modal-row label {
	  font-size: 0.9rem;
	  display: flex;
	  align-items: center;
	  gap: 0.5rem;
	}
	#multiModal select,
	#multiModal input[type="text"] {
	  width: 100%;
	  padding: 0.35rem;
	  background: #2D2D2D;
	  border: 1px solid #555;
	  border-radius: 4px;
	  color: #EAEAEA;
	  font-size: 0.8rem;
	  transition: all 0.2s;
	  height: 28px;
	}
	#multiModal select:hover,
	#multiModal input[type="text"]:hover {
	  border-color: #666;
	}
	#multiModal select:focus,
	#multiModal input[type="text"]:focus {
	  border-color: #4DAAFF;
	  outline: none;
	  box-shadow: 0 0 0 2px rgba(77, 170, 255, 0.2);
	}
	#multiModal .color-swatches {
	  display: grid;
	  grid-template-columns: repeat(auto-fit, minmax(32px, 1fr));
	  gap: 0.5rem;
	  margin-top: 0.5rem;
	}
	#multiModal .swatch {
	  aspect-ratio: 1;
	  border-radius: 4px;
	  cursor: pointer;
	  border: 2px solid transparent;
	  transition: all 0.2s;
	}
	#multiModal .swatch:hover {
	  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
	}
	#multiModal .swatch.active {
	  border-color: #4DAAFF;
	  box-shadow: 0 0 0 2px rgba(77, 170, 255, 0.3);
	}
	#multiColorSwatchesContainer .swatch.off-bg {
	  background-color: #2D2D2D;
	}
	#multiModal .shift-label-text {
	  color: #4DAAFF;
	  font-weight: 500;
	  font-size: 0.85rem;
	}
	#multiModal .modal-buttons {
	  display: grid;
	  grid-template-columns: 1fr auto 1fr;
	  gap: 0.5rem;
	  padding-top: 0.5rem;
	  border-top: 1px solid #444;
	  margin-top: auto;
	  position: sticky;
	  bottom: 0;
	  background: #2D2D2D;
	}
	#multiModal #multiSaveBtn {
	  background: #4DAAFF;
	  color: white;
	}
	#multiModal #multiSaveBtn:hover {
	  background: #82c3ff;
	}
	#multiModal #multiRevertBtn {
	  background: #555;
	  color: #EEE;
	  font-size: 1.2rem;
	  padding: 0.4rem 1rem;
	}
	#multiModal #multiRevertBtn:hover {
	  background: #666;
	}
	#multiModal #multiCancelBtn {
	  background: #444;
	  color: #EEE;
	}
	#multiModal #multiCancelBtn:hover {
	  background: #555;
	}
	#multiRevertBtn .rotate-emoji {
	  display: inline-block;
	  transition: transform 0.2s;
	}
	#multiRevertBtn:hover .rotate-emoji {
	  transform: rotate(180deg);
	}

	/* =========================================
	   12) STATS OVERLAY & WEIGHT CHART
	   ========================================= */
	#statsOverlay .modal#statsModal {
	  width: 420px;
	}
	#statsModal h2 {
	  font-size: 1.2rem;
	  text-align: center;
	  margin-bottom: 0.5rem;
	}
	.stats-summary {
	  display: flex;
	  flex-direction: column;
	  align-items: flex-start;
	  margin-bottom: 1rem;
	}
	.stat-item {
	  font-size: 1.1rem;
	  color: white;
	  margin-bottom: 0.5rem;
	}
	.counter-value {
	  color: white;
	  font-weight: bold;
	}
	#weightChart {
	  width: 100%;
	  height: 250px;
	}
	#statsCloseBtn {
	  cursor: pointer;
	}

	/* =========================================
	   13) PULSE ANIMATION (GENERIC)
	   ========================================= */
	@keyframes pulseEffect {
	  0% {
		transform: scale(1);
		box-shadow: 0 0 0 0 rgba(255, 255, 0, 0.5);
	  }
	  50% {
		transform: scale(1.03);
		box-shadow: 0 0 8px 4px rgba(255, 255, 0, 0.25);
	  }
	  100% {
		transform: scale(1);
		box-shadow: 0 0 0 0 rgba(255, 255, 0, 0);
	  }
	}
	.cell-pulse {
	  animation: pulseEffect 0.8s ease-out;
	}

	/* =========================================
	   14) UPDATED PR STYLING (SHIMMER & GLOW)
	   ========================================= */

	.pr-text {
	  position: relative;
	  display: inline-block;
	  background: linear-gradient(
		90deg,
		#FFD86F 0%,
		#FFE8A6 50%,
		#FFD86F 100%
	  );
	  background-size: 200% 200%;
	  background-position: 0% 50%;
	  -webkit-background-clip: text;
	  -webkit-text-fill-color: transparent;
	  background-clip: text;
	  color: transparent;
	  text-shadow:
		0 0 6px rgba(255, 216, 111, 0.6),
		0 0 2px rgba(255, 216, 111, 0.4);
	  animation: textShimmer 3s infinite ease-in-out;
	}

	@keyframes textShimmer {
	  0%   { background-position: 0%   50%; }
	  50%  { background-position: 100% 50%; }
	  100% { background-position: 0%   50%; }
	}

	.pr-border {
	  position: relative;
	  border: 2px solid #FFD86F;
	  overflow: visible;
	}

	.hevy-set.pr-border {
	  background: #000000; /* Your black background on PR sets */
	}

	/* Glimmering border animation */
	.pr-border::after {
	  content: "";
	  position: absolute;
	  top: -2px;
	  left: -2px;
	  right: -2px;
	  bottom: -2px;
	  background: linear-gradient(
		60deg,
		rgba(255, 216, 111, 0.1) 0%,
		rgba(255, 232, 166, 0.3) 50%,
		rgba(255, 216, 111, 0.1) 100%
	  );
	  background-size: 200% 200%;
	  background-position: 0% 50%;
	  border-radius: 4px;
	  pointer-events: none;
	  z-index: 0;
	  animation: borderShimmer 3s infinite ease-in-out;
	}

	@keyframes borderShimmer {
	  0%   { background-position: 0%   50%; }
	  50%  { background-position: 100% 50%; }
	  100% { background-position: 0%   50%; }
	}

	/* 14A) Twinkling PR Stars (always visible) */
	.pr-border .stars-container {
	  pointer-events: none; /* so stars don‚Äôt block clicks on the set */
	}

	/* 
	   Every star is visible by default (opacity:1) 
	   and uses the twinkle animation with different delays.
	*/
	.pr-border .stars-container [class^="star-"] {
	  position: absolute;
	  opacity: 1;
	  filter: drop-shadow(0 0 6px rgba(255, 215, 0, 0.8));
	  animation: twinkle 1.5s ease-in-out infinite;
	}

	.pr-border .stars-container .star-1 {
	  top: -10%;  left:  5%;  width: 9px;
	  animation-delay: 0.1s;
	}
	.pr-border .stars-container .star-2 {
	  top:  10%;  left: 90%;  width: 10px;
	  animation-delay: 0.3s;
	}
	.pr-border .stars-container .star-3 {
	  top:  40%;  left:  8%;  width: 9px;
	  animation-delay: 0.5s;
	}
	.pr-border .stars-container .star-4 {
	  top:  55%;  left: 95%;  width: 13px;
	  animation-delay: 0.7s;
	}
	.pr-border .stars-container .star-5 {
	  top:  70%;  left: 40%;  width: 9px;
	  animation-delay: 0.9s;
	}
	.pr-border .stars-container .star-6 {
	  top:  -15%;  left: 70%;  width: 11px;
	  animation-delay: 1.1s;
	}
	.pr-border .stars-container .star-7 {
	  top:  55%;  left:  -5%;  width: 9px;
	  animation-delay: 1.3s;
	}
	.pr-border .stars-container .star-8 {
	  top:  85%;  left: 78%;  width: 7px;
	  animation-delay: 1.5s;
	}
	.pr-border .stars-container .star-9 {
	  top:  5%;  left: 50%;  width: 11px;
	  animation-delay: 1.7s;
	}
	.pr-border .stars-container .star-10 {
	  top: 85%;   left: 25%;  width: 12px;
	  animation-delay: 1.9s;
	}
	/* Twinkle keyframes (flicker) */
	@keyframes twinkle {
	  0%, 100% {
		opacity: 1;
		transform: scale(1);
	  }
	  50% {
		opacity: 0.4;
		transform: scale(0.9);
	  }
	}
	/* Example star path fill color (white-ish gold) */
	.fil0 {
	  fill: #FFF9E6;
	}
	.pr-labels .pr-text.smaller-pr {
	  font-size: 0.6rem;  /* or 0.8rem, whichever you prefer */
	  display: block;      /* ensure each label is on its own line */
	  margin: 2px 0 0 0;   /* small spacing */
	}

	/* =========================================
	   15) HEVY WORKOUT STYLING
	   ========================================= */
	.hevy-workout {
	  margin-bottom: 2rem;
	  border-bottom: 1px solid #444;
	  padding-bottom: 1.5rem;
	}
	.hevy-workout:last-child {
	  margin-bottom: 0;
	  border-bottom: none;
	}
	.hevy-workout-title {
	  color: #FFDD77;
	  font-size: 1.2rem;
	  margin-bottom: 1.5rem;
	  font-weight: 700;
	}
	.hevy-exercise {
	  background: #393939;
	  border-radius: 8px;
	  padding: 1.2rem;
	  margin-bottom: 1rem;
	  box-shadow: 0 2px 8px rgba(0,0,0,0.2);
	  transition: all 0.2s;
	}
	.hevy-exercise:last-child {
	  margin-bottom: 0;
	}
	.hevy-exercise:hover {
	  transform: translateY(-2px);
	  background: #333;
	  box-shadow: 0 4px 8px rgba(0,0,0,0.4);
	}
	.hevy-exercise-title {
	  font-weight: bold;
	  color: #4DAAFF;
	  display: flex;
	  align-items: center;
	  font-size: 1.1rem;
	  margin-bottom: 1rem;
	  padding-bottom: 0.5rem;
	  border-bottom: 1px solid #444;
	  transition: color 0.2s;
	  cursor: pointer;
	}
	.hevy-exercise-title:hover {
	  color: #FFDD77;
	}
	.hevy-sets {
	  display: grid;
	  grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
	  gap: 0.75rem;
	  margin-bottom: 1rem;
	}
	.hevy-set {
	  background: #2D2D2D;
	  padding: 0.75rem;
	  border-radius: 6px;
	  text-align: center;
	  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
	  transition: all 0.2s;
	}
	.hevy-set:hover {
	  background: #333;
	  transform: translateY(-2px);
	  box-shadow: 0 4px 8px rgba(0,0,0,0.4);
	}
	.hevy-set-weight,
	.hevy-set-reps {
	  cursor: pointer;
	  transition: color 0.2s;
	}
	.hevy-total {
	  text-align: center;
	  color: #EAEAEA;
	  font-weight: bold;
	  font-size: 1.1rem;
	  margin-top: 1rem;
	  padding: 1rem;
	  background: #393939;
	  border-radius: 8px;
	  cursor: pointer;
	  transition: transform 0.2s;
	}
	.hevy-total:hover {
	  color: #FFDD77;
	  transform: translateY(-2px);
	}
	.hevy-orm {
	  margin-top: 0.25rem;
	  color: #FFFFFF;
	  font-weight: 400;
	  cursor: pointer;
	  transition: color 0.2s;
	  text-align: center;
	  font-size: 0.9rem;
	}
	.hevy-orm:hover {
	  color: #FFDD77;
	}
	.hevy-exercise-volume {
	  margin-top: 1.5rem;
	  color: #FFFFFF;
	  cursor: pointer;
	  transition: color 0.2s;
	  text-align: center;
	  font-size: 0.9rem;
	}
	.hevy-exercise-volume:hover {
	  color: #FFDD77;
	}

	/* =========================================
	   16) HEVY WORKOUT MODAL (#hevyModal)
	   ========================================= */
	#hevyOverlay .modal#hevyModal {
	  width: 500px;
	}
	#hevyModal.no-workout {
	  width: 350px;
	  text-align: center;
	  padding: 1rem;
	}
	.hevy-modal-content {
	  display: flex;
	  flex-direction: row;
	  gap: 1rem;
	  width: 100%;
	  align-items: flex-start;
	  justify-content: flex-start;
	  max-height: 450px;
	  overflow-y: hidden;
	}
	#hevyModalWorkoutDetails {
	  flex: 1;
	  overflow-y: auto;
	  padding-right: 4px;
	  max-height: 450px;
	}
	#hevyProgressChartContainer {
	  flex: 1;
	  max-width: 320px;
	  display: none;
	  overflow: hidden;
	}
	#hevyProgressChart {
	  width: 100%;
	  height: 300px;
	}
	#hevyModalWorkoutDetails p {
	  text-align: center;
	  color: #888;
	  font-style: italic;
	  padding: 2rem;
	}
	/* Centered date with line above it (like before) */
	#hevyModal .modal-subtitle {
	  text-align: center;
	  color: #888;
	  font-size: 0.9rem;
	  margin-top: 0.5rem;
	  margin-bottom: 0.5rem;
	  border-top: 1px solid #444;
	  padding-top: 0.5rem;
	}

	/* =========================================
	   17) EXERCISE VOLUME OVER TIME MODAL
		   (#exerciseVolumeOverlay)
	   ========================================= */
	#exerciseVolumeOverlay {
	}
	#exerciseVolumeModal {
	  width: 500px;
	}
	#exerciseVolumeChart {
	  width: 100%;
	  height: 300px;
	}
	#exerciseVolumeModal .modal-date {
	  display: none;
	}
	.date-range-btn {
	  background: #444;
	  border: 1px solid #555;
	  color: #EAEAEA;
	  padding: 0.4rem 0.8rem;
	  border-radius: 4px;
	  cursor: pointer;
	  transition: all 0.2s;
	}
	.date-range-btn:hover {
	  background: #555;
	}
	.date-range-btn.active {
	  background: #4DAAFF;
	  border-color: #4DAAFF;
	  color: #FFF;
	}

	/* =========================================
	   18) WEIGHT & REP PROGRESSION MODAL
		   (#exerciseProgressOverlay)
	   ========================================= */
	#exerciseProgressOverlay {
	}
	#exerciseProgressionModal {
	  width: 500px;
	}
	#exerciseWeightProgressionChart,
	#exerciseRepProgressionChart {
	  width: 100%;
	  height: 250px;
	}

	/* =========================================
	   19) VOLUME OVER TIME (DAY-LEVEL) MODAL
		   (#volumeOverlay)
	   ========================================= */
	#volumeOverlay {
	}
	#volumeModal {
	  width: 600px;
	}
	#volumeChart {
	  width: 100%;
	  height: 400px;
	}
	#volumeModalDate {}

	/* =========================================
	   20) ORM PROGRESSION MODAL
		   (#ormProgressOverlay)
	   ========================================= */
	#ormProgressOverlay {
	}
	#exerciseOrmProgressModal {
	  width: 500px;
	}
	#exerciseOrmProgressChart {
	  width: 100%;
	  height: 300px;
	}

	/* =========================================
	   21) CUSTOM ALERT OVERLAY & MODAL
	   ========================================= */
	#customAlertOverlay {
	}
	.custom-alert-modal {
	  background: #2D2D2D;
	  padding: 1.5rem;
	  border-radius: 6px;
	  width: 300px;
	  box-shadow: 0 2px 10px rgba(0,0,0,0.7);
	  display: flex;
	  flex-direction: column;
	  gap: 1rem;
	  text-align: center;
	  justify-content: center;
	  align-items: center;
	  transform: translateY(-20px);
	  animation: slideDownFade 0.3s forwards;
	}
	.custom-alert-modal p {
	  font-size: 1rem;
	  color: #EAEAEA;
	}
	#customAlertInput {
	  padding: 0.5rem;
	  border: 1px solid #555;
	  border-radius: 4px;
	  background: #444;
	  color: #EAEAEA;
	  font-size: 1rem;
	}
	.custom-alert-modal button {
	  padding: 0.5rem;
	  font-size: 0.9rem;
	  border: 1px solid #555;
	  border-radius: 4px;
	  background: #444;
	  color: #EAEAEA;
	  cursor: pointer;
	  transition: background-color 0.2s;
	  flex: 1;
	}
	.custom-alert-modal button:hover {
	  background: #555;
	}
	.custom-alert-modal .confirm-buttons {
	  display: flex;
	  gap: 1rem;
	}
	.default-button {
	  display: block;
	}
	#customDefaultButton button {
	  width: 100%;
	  margin-top: 0.5rem;
	}

	/* =========================================
	   22) LOADING OVERLAY & SPINNER
	   ========================================= */
	.loading-overlay {
	  display: none;
	  position: fixed;
	  top: 0;
	  left: 0;
	  width: 100%;
	  height: 100%;
	  background-color: rgba(0,0,0,0.6);
	  justify-content: center;
	  align-items: center;
	}
	.loading-overlay.active {
	  display: flex;
	}
	.spinner {
	  border: 6px solid rgba(255, 255, 255, 0.3);
	  border-top: 6px solid #fff;
	  border-radius: 50%;
	  width: 50px;
	  height: 50px;
	  animation: spin 1s linear infinite;
	}
	@keyframes spin {
	  0% { transform: rotate(0deg);}
	  100% { transform: rotate(360deg);}
	}

	/* =========================================
	   23) EXERCISE SUMMARY MODAL
	   ========================================= */
	#exerciseSummaryOverlay .modal#exerciseSummaryModal {
	  width: 500px;
	}
	.exercise-summary-header {
	  margin-bottom: 1.5rem;
	  padding-bottom: 0.5rem;
	  border-bottom: 1px solid #555;
	  color: #4DAAFF;
	  font-size: 1.2rem;
	  display: flex;
	  align-items: center;
	  gap: 1rem;
	  padding: 0.5rem 0;
	  font-weight: bold;
	}
	.key-stats-grid {
	  display: grid;
	  grid-template-columns: 1fr 1fr;
	  gap: 1rem;
	  margin-bottom: 1.5rem;
	}
	.key-stat {
	  background: #393939;
	  padding: 1rem;
	  border-radius: 6px;
	  text-align: center;
	  transition: all 0.2s;
	  cursor: pointer;
	}
	.key-stat:hover {
	  transform: translateY(-2px);
	  background: #505050;
	}
	.key-stat-label {
	  font-size: 0.9rem;
	  color: #aaa;
	  margin-bottom: 0.5rem;
	}
	.key-stat-value {
	  font-size: 1.3rem;
	  font-weight: bold;
	  color: #FFDD77;
	}
	.exercise-stat-block {
	  background: #2D2D2D;
	  border-radius: 6px;
	  padding: 1rem;
	  margin-bottom: 1rem;
	}
	.exercise-stat-title {
	  font-size: 1.1rem;
	  font-weight: bold;
	  color: #fff;
	  margin-bottom: 0.5rem;
	}
	.rep-range-list {
	  background: #393939;
	  border-radius: 6px;
	  padding: 1rem;
	}
	.rep-range-row {
	  display: flex;
	  justify-content: space-between;
	  align-items: center;
	  padding: 0.5rem;
	  border-bottom: 1px solid #444;
	}
	.rep-range-row:last-child {
	  border-bottom: none;
	}
	.rep-range-row:hover {
	  background: #505050;
	}
	.rep-range {
	  font-size: 1.1rem;
	  font-weight: bold;
	  color: #FFD700;
	  margin-bottom: 0.25rem;
	}
	.rep-range-count {
	  color: #4DAAFF;
	  font-weight: bold;
	}
	.rep-range-weight {
	  color: #FFDD77;
	}
	#exerciseSummaryContent {
	  max-height: 70vh;
	  overflow-y: auto;
	  padding-right: 10px;
	}
	.exercise-frequency-container {
	  display: flex;
	  align-items: center;
	  gap: 1rem;
	}
	.compare-button {
	  background: #444;
	  border: 1px solid #555;
	  color: #EAEAEA;
	  padding: 0.4rem 0.8rem;
	  border-radius: 4px;
	  cursor: pointer;
	  transition: all 0.2s;
	  font-size: 0.9rem; /* Slightly smaller font */
	  order: 2; /* Ensures it stays on the right in flex container */
	}
	.compare-button:hover {
	  background: #555;
	  transform: translateY(-1px);
	  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
	}
	@keyframes glowPulse {
	  0% { text-shadow: 0 0 5px rgba(255, 215, 0, 0.3);}
	  50% { text-shadow: 0 0 15px rgba(255, 215, 0, 0.6);}
	  100% { text-shadow: 0 0 5px rgba(255, 215, 0, 0.3);}
	}
	.glowing-orm {
	  animation: glowPulse 2s infinite;
	}

	/* =========================================
	   24) EXERCISE FREQUENCY MODAL
	   ========================================= */
	#exerciseFrequencyModal {
	  width: 800px;
	}
	#exerciseFrequencyChart {
	  width: 100%;
	  height: 400px;
	}

	/* =========================================
	   25) TOTAL VOLUME DISTRIBUTION MODAL
	   ========================================= */
	#totalVolumeDistributionModal {
	  width: 800px;
	}
	#totalVolumeDistributionChart {
	  width: 100%;
	  height: 400px;
	}
	#totalVolumeDistributionModal {
	  background: linear-gradient(140deg, #2D2D2D, #333333 70%);
	  border: 1px solid #444;
	  border-radius: 10px;
	  position: relative;
	  padding: 1.5rem;
	  box-shadow: 0 4px 20px rgba(0,0,0,0.5);
	  color: #EAEAEA;
	}
	#totalVolumeDistributionModal .modal-row {
	  background: rgba(0, 0, 0, 0.2);
	  border-radius: 8px;
	  margin-bottom: 1rem;
	  padding: 1rem;
	}
	#grandTotalWeight {
	  font-size: 1rem;
	  text-align: center;
	  color: #FFDD77;
	  margin-bottom: 0.75rem;
	  font-weight: 600;
	}

	/* =========================================
	   26) CUSTOM SCROLLBARS FOR MODALS
	   ========================================= */
	#hevyModalWorkoutDetails::-webkit-scrollbar,
	#exerciseSummaryContent::-webkit-scrollbar {
	  width: 8px;
	}
	#hevyModalWorkoutDetails::-webkit-scrollbar-track,
	#exerciseSummaryContent::-webkit-scrollbar-track {
	  background: #2D2D2D;
	  border-radius: 4px;
	}
	#hevyModalWorkoutDetails::-webkit-scrollbar-thumb,
	#exerciseSummaryContent::-webkit-scrollbar-thumb {
	  background: #555;
	  border-radius: 4px;
	}
	#hevyModalWorkoutDetails::-webkit-scrollbar-thumb:hover,
	#exerciseSummaryContent::-webkit-scrollbar-thumb:hover {
	  background: #666;
	}
	#singleModal,
	#multiModal {
	  max-height: 90vh;
	  overflow-y: auto;
	}
	#singleModal::-webkit-scrollbar,
	#multiModal::-webkit-scrollbar {
	  width: 10px;
	  height: 10px;
	}
	#singleModal::-webkit-scrollbar-track,
	#multiModal::-webkit-scrollbar-track {
	  background: #2D2D2D;
	  border-radius: 4px;
	}
	#singleModal::-webkit-scrollbar-thumb,
	#multiModal::-webkit-scrollbar-thumb {
	  background: #555;
	  border-radius: 4px;
	  border: 2px solid #2D2D2D;
	}
	#singleModal::-webkit-scrollbar-thumb:hover,
	#multiModal::-webkit-scrollbar-thumb:hover {
	  background: #666;
	}
	
	/* =========================================
	   27) EXERCISE HISTORY MODAL
	   ========================================= */	
	#exerciseHistoryOverlay {
	}
	#exerciseHistoryModal {
	  width: 500px; /* Match exercise summary width */
	  max-height: 80vh;
	}
	#exerciseHistoryContent {
	  max-height: 70vh;
	  overflow-y: auto;
	  padding-right: 10px;
	}
	/* Add scrollbar styling to match exercise summary */
	#exerciseHistoryContent::-webkit-scrollbar {
	  width: 8px;
	}
	#exerciseHistoryContent::-webkit-scrollbar-track {
	  background: #2D2D2D;
	  border-radius: 4px;
	}
	#exerciseHistoryContent::-webkit-scrollbar-thumb {
	  background: #555;
	  border-radius: 4px;
	}
	#exerciseHistoryContent::-webkit-scrollbar-thumb:hover {
	  background: #666;
	}
	.exercise-history-entry {
	  background: #393939;
	  border-radius: 8px;
	  padding: 1.2rem;
	  margin-bottom: 1rem;
	  box-shadow: 0 2px 8px rgba(0,0,0,0.2);
	}
	.exercise-history-date {
	  font-size: 0.95rem;
	  color: #4DAAFF;
	  margin-bottom: 1rem;
	  padding-bottom: 0.5rem;
	  border-bottom: 1px solid #444;
	}
	.exercise-history-sets {
	  display: grid;
	  grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
	  gap: 0.75rem;
	}
	#exerciseProgressOverlay {
	}
	#volumeOverlay {
	}
	#ormProgressOverlay {
	}
	#exerciseHistoryOverlay {
	}
	.exercise-history-header {
	  margin-bottom: 1rem;
	}
	.exercise-history-subheader {
	  color: #4DAAFF;
	  font-size: 1.2rem;
	  font-weight: 700;
	  margin-top: 0.5rem;
	  text-align: left;
	}
	
	/* =========================================
	  28) PRESET CREATION RELATED
	  ========================================= */	
	.preset-separator {
	 width: 100%;
	 height: 1px;
	 background: #444;
	 margin: 0.5rem 0;
	 grid-column: 1 / -1;
	}

	#singleColorSwatchesContainer,
	#multiColorSwatchesContainer {
	 display: grid;
	 grid-template-columns: repeat(auto-fit, minmax(32px, 1fr));
	 gap: 0.5rem;
	 margin-top: 0.5rem;
	}

	#singleColorSwatchesContainer .add-preset-emoji {
	 grid-column: 1 / -1;
	 text-align: center;
	 margin-top: 0rem;
	 padding: 0.3rem;
	 border: 1px solid #444;
	 border-radius: 4px;
	}

	#singleColorSwatchesContainer .add-preset-emoji:hover {
	 background-color: rgba(255, 255, 255, 0.4);
	}

	#presetCreationModal {
	 width: 420px;
	 max-height: 80vh;
	 overflow-y: auto;
	 display: flex;
	 flex-direction: column;
	 padding: 1rem;
	}

	#presetCreationModal h2 {
	 font-size: 1.1rem;
	 color: #EAEAEA;
	 margin-bottom: 0rem;
	 text-align: center;
	 padding-bottom: 0.4rem;
	 border-bottom: 1px solid #444;
	}

	#presetCreationModal .modal-row {
	 display: flex;
	 flex-direction: column;
	 gap: 0.25rem;
	 background: #393939;
	 padding: 0.5rem;
	 border-radius: 6px;
	 margin-bottom: 0.35rem;
	 transition: background-color 0.2s;
	}

	#presetCreationModal .modal-row:hover {
	 background: #424242;
	}

	#presetCreationModal .modal-row label {
	 font-size: 0.9rem;
	 display: flex;
	 align-items: center;
	 gap: 0.5rem;
	 justify-content: space-between;
	}

	#presetCreationModal input[type="text"],
	#presetCreationModal input[type="color"],
	#presetCreationModal select {
	 width: 100%;
	 padding: 0.35rem;
	 background: #2D2D2D;
	 border: 1px solid #555;
	 border-radius: 4px;
	 color: #EAEAEA;
	 font-size: 0.8rem;
	 transition: all 0.2s;
	 height: 28px;
	}

	#presetCreationModal input[type="color"] {
	 height: 40px;
	 padding: 0;
	 cursor: pointer;
	}

	#presetCreationModal input:hover,
	#presetCreationModal select:hover {
	 border-color: #666;
	}

	#presetCreationModal input:focus,
	#presetCreationModal select:focus {
	 border-color: #4DAAFF;
	 outline: none;
	 box-shadow: 0 0 0 2px rgba(77, 170, 255, 0.2);
	}

	#presetCreationModal .modal-buttons {
	 display: grid;
	 grid-template-columns: 1fr 1fr;
	 gap: 0.5rem;
	 padding-top: 0.5rem;
	 border-top: 1px solid #444;
	 margin-top: auto;
	}

	#presetCreationModal button {
	 padding: 0.5rem;
	 border: 1px solid #555;
	 border-radius: 4px;
	 cursor: pointer;
	 transition: all 0.2s;
	}

	#presetCreationModal #savePresetBtn {
	 background: #4DAAFF;
	 color: white;
	}

	#presetCreationModal #savePresetBtn:hover {
	 background: #82c3ff;
	}

	#presetCreationModal #cancelPresetBtn {
	 background: #444;
	 color: #EEE;
	}

	#presetCreationModal #cancelPresetBtn:hover {
	 background: #555;
	}

	.delete-preset-emoji:hover {
	 background: rgba(255, 0, 0, 0.2);
	 border-color: #ff4444;
	}

	.delete-preset-emoji[disabled] {
	 opacity: 0.5;
	 cursor: not-allowed;
	 pointer-events: none;
	}
	
	/* ===============================
	  29) CREATE NEW WORKOUT MODAL
	  =============================== */		
	
	/* Create Workout Modal Specific Styles */
	#createWorkoutModal {
	  width: 600px;
	  max-height: 85vh;
	  overflow-y: auto;
	  padding: 0;
	  display: flex;
	  flex-direction: column;
	}

	.workout-header {
	  background: linear-gradient(180deg, rgba(77, 170, 255, 0.1) 0%, rgba(77, 170, 255, 0.05) 50%, transparent 100%);
	  padding: 1.5rem 1.5rem 0rem 1.5rem;
	  margin-bottom: 0.2rem;
	}

	.workout-date {
	  color: #4DAAFF;
	  font-size: 1.2rem;
	  font-weight: 500;
	  margin-bottom: 1.5rem;
	}

	.title-input {
	  width: 100%;
	  padding: 0.75rem 1rem;
	  font-size: 1.2rem;
	  background: rgba(45, 45, 45, 0.7);
	  border: 1px solid #555;
	  border-radius: 8px;
	  color: #EAEAEA;
	  margin-bottom: 1.5rem;
	  transition: all 0.2s;
	}

	.title-input:focus {
	  background: rgba(45, 45, 45, 0.9);
	  border-color: #4DAAFF;
	  box-shadow: 0 0 0 2px rgba(77, 170, 255, 0.2);
	}

	.workout-times {
	  display: flex;
	  align-items: center;
	  gap: 1.5rem;
	  background: rgba(45, 45, 45, 0.5);
	  padding: 1rem;
	  border-radius: 8px;
	}

	.time-group {
	  flex: 1;
	  display: flex;
	  flex-direction: column;
	  gap: 0.5rem;
	}

	.time-label {
	  color: #888;
	  font-size: 0.9rem;
	  font-weight: 500;
	}

	.time-group input {
	  padding: 0.5rem;
	  background: rgba(45, 45, 45, 0.8);
	  border: 1px solid #555;
	  border-radius: 6px;
	  color: #EAEAEA;
	  font-size: 0.95rem;
	  transition: all 0.2s;
	}

	.time-group input:focus {
	  border-color: #4DAAFF;
	  box-shadow: 0 0 0 2px rgba(77, 170, 255, 0.2);
	}

	.time-divider {
	  width: 1px;
	  height: 40px;
	  background: #444;
	  margin: 0 0.5rem;
	}

	/* Exercise Section */
	.exercises-section {
	  flex-grow: 1;
	  padding: 0.5rem 1.5rem 0.5rem 1.5rem;
	  display: flex;
	  flex-direction: column;
	  gap: 1rem;
	}

	.exercise-block {
	  background: #393939;
	  border-radius: 8px;
	  padding: 0.5rem 1rem 0.5rem 1rem;
	  margin-bottom: 0.5rem;
	}

	.exercise-header {
	  display: flex;
	  justify-content: space-between;
	  align-items: center;
	  margin-bottom: 1.5rem;
	}

	.exercise-title {
	  font-size: 1.1rem;
	  color: #4DAAFF;
	  font-weight: 500;
	}

	.remove-exercise-btn {
	  background: rgba(255, 255, 255, 0.1);
	  color: #EEE;
	  border: none;
	  width: 2rem;
	  height: 2rem;
	  border-radius: 6px;
	  cursor: pointer;
	  font-size: 1.2rem;
	  display: flex;
	  align-items: center;
	  justify-content: center;
	  transition: all 0.2s;
	}

	.remove-exercise-btn:hover {
	  background: rgba(255, 77, 77, 0.2);
	  color: #ff4d4d;
	}

	/* Sets Section */
	.sets-section {
	  display: flex;
	  flex-direction: column;
	  gap: 0.75rem;
	}

	.set-row {
	  display: grid;
	  grid-template-columns: 3rem 1fr auto;
	  gap: 1rem;
	  align-items: center;
	  background: #2D2D2D;
	  padding: 0.5rem;
	  margin-bottom: 0.1rem;
	  border-radius: 3px;
	}

	.set-number {
	  color: #888;
	  font-size: 0.9rem;
	  text-align: center;
	}

	.set-inputs {
	  display: flex;
	  align-items: center;
	  gap: 0.75rem;
	}

	.set-inputs input {
	  width: 5rem;
	  padding: 0.5rem;
	  background: #393939;
	  border: 1px solid #555;
	  border-radius: 4px;
	  color: #EAEAEA;
	  text-align: center;
	}

	.separator {
	  color: #666;
	  font-weight: 500;
	}

	.remove-set-btn {
	  background: transparent;
	  color: #666;
	  border: none;
	  padding: 0.5rem;
	  cursor: pointer;
	  display: flex;
	  align-items: center;
	  justify-content: center;
	  border-radius: 4px;
	  transition: all 0.2s;
	}

	.remove-set-btn:hover {
	  background: rgba(255, 77, 77, 0.1);
	  color: #ff4d4d;
	}

	/* Add Exercise Button */
	#addExerciseBtn {
	  width: 100%;
	  padding: 1rem;
	  background: #4DAAFF;
	  color: white;
	  border: none;
	  border-radius: 6px;
	  cursor: pointer;
	  font-size: 1rem;
	  display: flex;
	  align-items: center;
	  justify-content: center;
	  gap: 0.5rem;
	  transition: background-color 0.2s;
	  margin-top: auto;
	}

	#addExerciseBtn:hover {
	  background: #82c3ff;
	}

	/* Exercise Selection Modal */
	#exerciseSelectionModal {
	  width: 500px;
	  max-height: 80vh;
	  display: flex;
	  flex-direction: column;
	  padding: 0;
	}

	.modal-header {
	  background: linear-gradient(to bottom, rgba(77, 170, 255, 0.1), transparent);
	  padding: 1.5rem;
	  border-bottom: 1px solid #444;
	}

	.search-box {
	  margin-top: 1rem;
	}

	.search-box input {
	  width: 100%;
	  padding: 0.75rem;
	  background: #2D2D2D;
	  border: 1px solid #555;
	  border-radius: 6px;
	  color: #EAEAEA;
	}

	.exercises-list {
	  flex-grow: 1;
	  overflow-y: auto;
	  padding: 1rem;
	}

	.exercise-option {
	  padding: 1rem;
	  background: #393939;
	  border-radius: 6px;
	  margin-bottom: 0.5rem;
	  cursor: pointer;
	  transition: all 0.2s;
	  border: 2px solid transparent;
	}

	.exercise-option:hover {
	  background: #444;
	}

	.exercise-option.selected {
	  background: #2D2D2D;
	  border-color: #4DAAFF;
	}

	.exercise-option .title {
	  color: #4DAAFF;
	  margin-bottom: 0.25rem;
	}

	.exercise-option .details {
	  color: #888;
	  font-size: 0.9rem;
	}

	/* Modal Buttons */
	.modal-buttons {
	  padding: 1rem;
	  border-top: 1px solid #444;
	  display: flex;
	  justify-content: center;
	  gap: 1rem;
	  background: #2D2D2D;
	}

	.modal-buttons .primary-btn,
	.modal-buttons .secondary-btn {
	  padding: 0.75rem 2rem;
	  border: none;
	  border-radius: 6px;
	  cursor: pointer;
	  font-size: 1rem;
	  transition: all 0.2s;
	  min-width: 120px;
	}

	.modal-buttons .primary-btn {
	  background: #4DAAFF;
	  color: white;
	}

	.modal-buttons .primary-btn:hover {
	  background: #82c3ff;
	}

	.modal-buttons .secondary-btn {
	  background: #444;
	  color: #EEE;
	}

	.modal-buttons .secondary-btn:hover {
	  background: #555;
	}

	/* Add Set Button Styling */
	.add-set-btn {
	  background: rgba(77, 170, 255, 0.1);
	  color: #4DAAFF;
	  border: 1px solid rgba(77, 170, 255, 0.2);
	  padding: 0.5rem 1rem;
	  border-radius: 6px;
	  cursor: pointer;
	  font-size: 0.9rem;
	  display: inline-flex;
	  align-items: center;
	  gap: 0.5rem;
	  transition: all 0.2s;
	  margin: 0.5rem 0rem 0.5rem 0rem;
	}

	.add-set-btn:hover {
	  background: rgba(77, 170, 255, 0.15);
	  border-color: rgba(77, 170, 255, 0.3);
	}

	#createWorkoutSaveBtn {
	  background: #4DAAFF;
	  color: white;
	}

	#createWorkoutSaveBtn:hover {
	  background: #82c3ff;
	}

	#createWorkoutCancelBtn,
	#exerciseSelectionCancelBtn {
	  background: #444;
	  color: #EEE;
	}

	#createWorkoutCancelBtn:hover,
	#exerciseSelectionCancelBtn:hover {
	  background: #555;
	}
	
	#createWorkoutModal,
	#exerciseSelectionModal {
	  max-height: 90vh;
	  overflow-y: auto;
	}

	#createWorkoutModal::-webkit-scrollbar,
	#exerciseSelectionModal::-webkit-scrollbar,
	#exerciseSelectionList::-webkit-scrollbar {
	  width: 8px;
	}

	#createWorkoutModal::-webkit-scrollbar-track,
	#exerciseSelectionModal::-webkit-scrollbar-track,
	#exerciseSelectionList::-webkit-scrollbar-track {
	  background: #2D2D2D;
	  border-radius: 4px;
	}

	#createWorkoutModal::-webkit-scrollbar-thumb,
	#exerciseSelectionModal::-webkit-scrollbar-thumb,
	#exerciseSelectionList::-webkit-scrollbar-thumb {
	  background: #555;
	  border-radius: 4px;
	}

	#createWorkoutModal::-webkit-scrollbar-thumb:hover,
	#exerciseSelectionModal::-webkit-scrollbar-thumb:hover,
	#exerciseSelectionList::-webkit-scrollbar-thumb:hover {
	  background: #666;
	}

  </style>
</head>

<body>
  <div class="main-wrapper">
    <!-- Month/Navigation/Buttons Bar -->
    <div class="month-bar">
      <div id="monthLabel" class="month-title">Month / Year</div>
      <div class="arrow-buttons">
        <div class="month-nav-buttons">
          <button class="arrow-button" onclick="prevMonth()" title="Previous Month">‚ñ≤</button>
          <button class="arrow-button" onclick="nextMonth()" title="Next Month">‚ñº</button>
        </div>
        <div class="data-buttons">
          <!-- Save Button -->
          <button class="arrow-button" id="saveDataBtn" title="Save Data">üíæ</button>
          <!-- Load Button -->
          <button class="arrow-button" id="loadDataBtn" title="Load Data">üìÅ</button>
          <!-- Import Hevy Button -->
          <button class="arrow-button" id="hevyImportBtn" title="Import workouts from Hevy">
            <img src="https://play-lh.googleusercontent.com/_HgX2ELOeBOIS6H-99ymHkNcEOlqoEncbt0x-D1MSgXx0ao8sTd7GRe16u-v70EgaAI"
                 alt="Hevy" style="width:18px;height:18px;">
          </button>
          <!-- Populate Calendar Button -->
          <button class="arrow-button" id="populateCalendarBtn" title="Populate Calendar" disabled style="opacity: 0.5; border: 2px solid #555;">
            üìÖ
          </button>
          <!-- Stats Button -->
          <button class="arrow-button" id="statsBtn" title="View Statistics">üìâ</button>
          <!-- Clear Calendar Button -->
          <button class="arrow-button" id="clearCalendarBtn" title="Clear Calendar">üóã</button>
          <!-- Help Button -->
          <button class="arrow-button" id="helpBtn" title="Help">‚ùî</button>
        </div>
      </div>
      <input type="file" id="importFileInput" accept=".json" style="display: none;">
    </div>
    <!-- Calendar -->
    <div class="calendar-container" id="calendar"></div>
  </div>

  <!-- Single-Cell Edit Overlay -->
  <div class="overlay" id="singleOverlay">
    <div class="modal" id="singleModal">
        <h2>Edit Cell</h2>
		<div class="modal-date" id="singleModalDate">2 January</div>
      <!-- SHIFT Presets -->
      <div class="modal-row">
        <label>
          <span id="singleShiftMainLabel">Shift Presets:</span>
          <span class="shift-label-text" id="singleShiftLabelText">(none)</span>
          <span class="reset-emoji" data-field="shiftClass" title="Reset Shift">‚ü≥</span>
		  
        </label>
        <div class="color-swatches" id="singleColorSwatchesContainer"></div>
      </div>
      <!-- GYM -->
      <div class="modal-row">
        <label>Workout Type
          <span class="reset-emoji" data-field="gym" title="Reset Workout Type">‚ü≥</span>
        </label>
        <select id="singleWorkoutTypeSelect">
          <option value="Push">Push</option>
          <option value="Pull">Pull</option>
          <option value="Rest">Rest</option>
          <option value="Upper">Upper</option>
          <option value="Lower">Lower</option>
          <option value="Chest">Chest</option>
          <option value="Arms">Arms</option>
          <option value="Shoulders">Shoulders</option>
          <option value="Back">Back</option>
          <option value="Legs">Legs</option>
          <option value="Cardio">Cardio</option>
          <option value="None">None</option>
        </select>
      </div>
      <!-- Gym Time -->
      <div class="modal-row">
        <label>Gym Time (HHMM)
          <span class="reset-emoji" data-field="gymTime" title="Reset Gym Time">‚ü≥</span>
        </label>
        <input type="text" id="singleGymTimeInput" placeholder="e.g. 2100">
      </div>
      <!-- Work Time ‚Äì Dropdown -->
      <div class="modal-row">
		  <label>Work Time (HHMM)
			<span class="reset-emoji" data-field="workTime" title="Reset Work Time">‚ü≥</span>
		  </label>
		  <input type="text" id="singleWorkTimeSelect" placeholder="e.g. 2100">
		</div>
      <!-- Weight -->
      <div class="modal-row">
        <label>Weight (kg)
          <span class="reset-emoji" data-field="weight" title="Reset Weight">‚ü≥</span>
        </label>
        <input type="text" id="singleWeightInput" placeholder="e.g. 88.0">
      </div>
      <!-- Alert Type -->
      <div class="modal-row">
        <label>Alert Type
          <span class="reset-emoji" data-field="alertType" title="Reset Alert Type">‚ü≥</span>
        </label>
        <select id="singleAlertTypeSelect">
          <option value="None">‚ö™ None</option>
          <option value="Generic">üü¢ Generic</option>
          <option value="Birthday">üü£ Birthday</option>
          <option value="Work">üîµ Work</option>
          <option value="PublicHoliday">üü° Public Holiday</option>
		  <option value="Deadline">üî¥ Deadline</option>
		  <option value="School">üü† School</option>
        </select>
      </div>
      <!-- Alert Text -->
      <div class="modal-row">
        <label>Alert Text
          <span class="reset-emoji" data-field="alertText" title="Reset Alert Text">‚ü≥</span>
        </label>
        <input type="text" id="singleAlertTextInput" placeholder="e.g. My birthday!">
      </div>

      <div class="modal-buttons">
        <button id="singleSaveBtn" title="Save Changes">Save</button>
        <button id="singleRevertBtn" style="font-size:1.5rem;" title="Revert Changes">
			<span class="rotate-emoji">‚ü≥</span>
		</button>
        <button id="singleCancelBtn" title="Cancel">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Multi-Cell Edit Overlay -->
  <div class="overlay" id="multiOverlay">
    <div class="modal" id="multiModal">
      <h2>Edit Cells</h2>
      <!-- Key to Change -->
      <div class="modal-row">
        <label>Select Key to Change</label>
        <select id="multiKeySelect">
          <option value="">(select key)</option>
          <option value="shiftClass">Shift Presets</option>
          <option value="gym">Workout Type</option>
          <option value="gymTime">Gym Time</option>
          <option value="workTime">Work Time</option>
          <option value="weight">Weight</option>
          <option value="alertType">Alert Type</option>
          <option value="alertText">Alert Text</option>
        </select>
      </div>
      <!-- SHIFT Presets Swatches Row -->
      <div class="modal-row" id="multiShiftSwatchesRow" style="display:none;">
        <label>
          Choose Shift Preset:
          <span class="shift-label-text" id="multiShiftLabelText">(none)</span>
        </label>
        <div class="color-swatches" id="multiColorSwatchesContainer"></div>
      </div>
      <!-- Alert Type Row -->
      <div class="modal-row" id="multiAlertTypeRow" style="display:none;">
        <label>Alert Type</label>
        <select id="multiAlertTypeSelect">
          <option value="None">‚ö™ None</option>
          <option value="Generic">üü¢ Generic</option>
          <option value="Birthday">üü£ Birthday</option>
          <option value="Work">üîµ Work</option>
          <option value="PublicHoliday">üü° Public Holiday</option>
		  <option value="Deadline">üî¥ Deadline</option>
		  <option value="School">üü† School</option>
        </select>
      </div>
      <!-- Work Time Row -->
      <div class="modal-row" id="multiWorkTimeRow" style="display: none;">
        <label>Work Time (HHMM)</label>
        <input type="text" id="multiWorkTimeInput" placeholder="e.g. 0900">
      </div>
      <!-- Value Row for other keys -->
      <div class="modal-row" id="multiValueRow" style="display:none;">
        <label>New Value</label>
        <input type="text" id="multiValueInput" placeholder="">
      </div>
      <!-- Value Row for Workout Type -->
      <div class="modal-row" id="multiWorkoutTypeRow" style="display:none;">
        <label>New Workout Type</label>
        <select id="multiWorkoutTypeSelect">
          <option value="Push">Push</option>
          <option value="Pull">Pull</option>
          <option value="Rest">Rest</option>
          <option value="Upper">Upper</option>
          <option value="Lower">Lower</option>
          <option value="Chest">Chest</option>
          <option value="Arms">Arms</option>
          <option value="Shoulders">Shoulders</option>
          <option value="Back">Back</option>
          <option value="Legs">Legs</option>
          <option value="Cardio">Cardio</option>
          <option value="None">None</option>
        </select>
      </div>
      <div class="modal-buttons">
        <button id="multiSaveBtn" title="Save Changes">Save</button>
        <button id="multiRevertBtn" style="font-size:1.5rem;" title="Revert Changes">
			<span class="rotate-emoji">‚ü≥</span>
		</button>
        <button id="multiCancelBtn" title="Cancel">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Stats Overlay -->
  <div class="overlay" id="statsOverlay">
    <div class="modal" id="statsModal">
      <h2>Statistics</h2>
      <div class="stats-summary">
        <div class="stat-item">
          Sessions Completed: <span class="counter-value" id="sessionCounter">0</span>
        </div>
        <div class="stat-item">
          Days Trained: <span class="counter-value" id="daysTrainedCounter">0</span>
        </div>
        <div class="stat-item">
          Percentage Trained: <span class="counter-value" id="percentageCounter">0.00%</span>
        </div>
      </div>
      <div class="modal-row" style="height:300px;">
        <canvas id="weightChart"></canvas>
      </div>
      <div class="modal-buttons">
        <button id="statsCloseBtn" title="Close Statistics">Close</button>
      </div>
    </div>
  </div>

  <!-- Hevy Workout Summary Overlay -->
  <div class="overlay" id="hevyOverlay">
    <div class="modal" id="hevyModal">
      <h2>Workout Summary</h2>
      <div class="hevy-modal-content">
        <div id="hevyModalWorkoutDetails"></div>
        <!-- Optional chart container if you want to show a set-based progression in the same modal -->
        <div id="hevyProgressChartContainer">
          <canvas id="hevyProgressChart"></canvas>
        </div>
      </div>
      <div class="modal-buttons">
        <button id="hevyCloseBtn" title="Close Hevy Summary">Close</button>
      </div>
    </div>
  </div>

  <!-- Volume Over Time Overlay -->
  <div class="overlay" id="volumeOverlay">
    <div class="modal" id="volumeModal">
      <div class="modal-date" id="volumeModalDate"></div>
      <h2>Volume Over Time</h2>
	  <div class="modal-row" style="margin-bottom: 1rem;">
      <div style="display: flex; gap: 0.5rem; justify-content: center;">
        <button class="date-range-btn active" data-range="year">Year</button>
        <button class="date-range-btn" data-range="month">Month</button>
        <button class="date-range-btn" data-range="week">Week</button>
        <button class="date-range-btn" data-range="all">All Time</button>
      </div>
    </div>
      <div class="modal-row" style="height:300px;">
        <canvas id="volumeChart"></canvas>
      </div>
      <div class="modal-buttons">
        <button id="volumeCloseBtn" title="Close Volume Chart">Close</button>
      </div>
    </div>
  </div>

  <!-- Exercise Volume Over Time Overlay -->
  <div class="overlay" id="exerciseVolumeOverlay">
    <div class="modal" id="exerciseVolumeModal">
      <h2>Exercise Volume Over Time</h2>
	  <div class="modal-row" style="margin-bottom: 1rem;">
	      <div style="display: flex; gap: 0.5rem; justify-content: center;">
			  <button class="date-range-btn active" data-range="year">Year</button>
			  <button class="date-range-btn" data-range="month">Month</button>
			  <button class="date-range-btn" data-range="week">Week</button>
			  <button class="date-range-btn" data-range="all">All Time</button>
		  </div>
	  </div>
      <div class="modal-row" style="height:300px;">
        <canvas id="exerciseVolumeChart"></canvas>
      </div>
      <div class="modal-buttons">
        <button id="exerciseVolumeCloseBtn" title="Close Exercise Volume Chart">Close</button>
      </div>
    </div>
  </div>

  <!-- Combined Weight & Rep Progression Modal -->
  <div class="overlay" id="exerciseProgressOverlay">
    <div class="modal" id="exerciseProgressionModal">
      <div class="modal-date" id="exerciseProgressionModalDate"></div>
      <h2>Exercise: Weight & Rep Progression</h2>
	  
	  <!-- Date Range Controls -->
      <div class="modal-row" style="margin-bottom: 1rem;">
        <div style="display: flex; gap: 0.5rem; justify-content: center;">
          <button class="date-range-btn active" data-range="year">Year</button>
          <button class="date-range-btn" data-range="month">Month</button>
          <button class="date-range-btn" data-range="week">Week</button>
          <button class="date-range-btn" data-range="all">All Time</button>
        </div>
      </div>

      <!-- First row: Weight Progression Chart -->
      <div class="modal-row" style="height:320px;">
        <canvas id="exerciseWeightProgressionChart"></canvas>
      </div>

      <!-- Second row: Rep Progression Chart -->
      <div class="modal-row" style="height:320px;">
        <canvas id="exerciseRepProgressionChart"></canvas>
      </div>

      <div class="modal-buttons">
        <button id="exerciseProgressCloseBtn" title="Close Progression">Close</button>
      </div>
    </div>
  </div>

  <!-- ORM Progress Modal -->
  <div class="overlay" id="ormProgressOverlay">
    <div class="modal" id="exerciseOrmProgressModal">
      <h2>Exercise: ORM Progression</h2>
	  <!-- Date Range Controls -->
      <div class="modal-row" style="margin-bottom: 1rem;">
        <div style="display: flex; gap: 0.5rem; justify-content: center;">
          <button class="date-range-btn active" data-range="year">Year</button>
          <button class="date-range-btn" data-range="month">Month</button>
          <button class="date-range-btn" data-range="week">Week</button>
          <button class="date-range-btn" data-range="all">All Time</button>
        </div>
      </div>
      <div class="modal-row" style="height:300px;">
        <canvas id="exerciseOrmProgressChart"></canvas>
      </div>
      <div class="modal-buttons">
        <button id="ormProgressCloseBtn" title="Close ORM Progression">Close</button>
      </div>
    </div>
  </div>

  <!-- Custom Alert Overlay -->
  <div class="overlay" id="customAlertOverlay">
    <div class="custom-alert-modal" id="customAlertModal">
      <p id="customAlertMessage"></p>
      <input type="text" id="customAlertInput" style="display: none;" placeholder="">
      <div class="confirm-buttons" id="customConfirmButtons" style="display: none;"></div>
      <div class="default-button" id="customDefaultButton" style="display: block;">
        <button onclick="closeCustomAlert()" title="OK">OK</button>
      </div>
    </div>
  </div>
  
  <div class="overlay" id="exerciseSummaryOverlay">
  <div class="modal" id="exerciseSummaryModal">
    <h2>Exercise Summary</h2>
    <div id="exerciseSummaryContent">
      <!-- Content will be populated dynamically -->
    </div>
    <div class="modal-buttons">
      <button id="exerciseSummaryCloseBtn" title="Close Exercise Summary">Close</button>
    </div>
  </div>
</div>

  <!-- Loading Overlay -->
  <div class="overlay loading-overlay" id="loadingOverlay">
    <div class="custom-alert-modal">
      <p>Loading...</p>
      <div class="spinner"></div>
    </div>
  </div>
  
  <!-- Exercise Frequency Comparison Modal -->
	<div class="overlay" id="exerciseFrequencyOverlay">
	  <div class="modal" id="exerciseFrequencyModal">
		<h2>Exercise Frequency Comparison</h2>
		<div class="modal-row" style="height:400px;">
		  <canvas id="exerciseFrequencyChart"></canvas>
		</div>
		<div class="modal-buttons">
		  <button id="exerciseFrequencyCloseBtn" title="Close Frequency Comparison">Close</button>
		</div>
	  </div>
	</div>

	<!-- Total Volume Distribution Modal -->
	<div class="overlay" id="totalVolumeDistributionOverlay">
	  <div class="modal" id="totalVolumeDistributionModal">
		<h2>Total Volume Distribution</h2>
		<div class="modal-row" style="height:400px;">
		  <canvas id="totalVolumeDistributionChart"></canvas>
		</div>
		<div class="modal-buttons">
		  <button id="totalVolumeDistributionCloseBtn" title="Close Volume Distribution">Close</button>
		</div>
	  </div>
	</div>
	
	<div class="overlay" id="exerciseHistoryOverlay">
	  <div class="modal" id="exerciseHistoryModal">
		<h2>Exercise History</h2>
		<div class="exercise-history-subheader" id="exerciseHistorySubheader"></div>
		<div id="exerciseHistoryContent" class="exercise-summary-scroll">
		  <!-- Content will be populated dynamically -->
		</div>
		<div class="modal-buttons">
		  <button id="exerciseHistoryCloseBtn" title="Close Exercise History">Close</button>
		</div>
	  </div>
	</div>
		
	<!-- Custom Preset Creation Modal -->
	<div class="overlay" id="presetCreationOverlay">
	  <div class="modal" id="presetCreationModal">
		<h2>Create Custom Preset</h2>
		
		<div class="modal-row">
		  <label>Preset Name</label>
		  <input type="text" id="presetNameInput" placeholder="Morning Routine" required>
		</div>
		
		<div class="modal-row">
		  <label>Preset Color</label>
		  <input type="color" id="presetColorInput" value="#4daaff">
		</div>

		<div class="modal-row">
		  <label>Workout Type</label>
		  <select id="presetWorkoutSelect">
			<option value="Push">Push</option>
			<option value="Pull">Pull</option>
			<option value="Rest">Rest</option>
			<option value="Upper">Upper</option>
			<option value="Lower">Lower</option>
			<option value="Chest">Chest</option>
			<option value="Arms">Arms</option>
			<option value="Shoulders">Shoulders</option>
			<option value="Back">Back</option>
			<option value="Legs">Legs</option>
			<option value="Cardio">Cardio</option>
			<option value="None">None</option>
		  </select>
		</div>

		<div class="modal-row">
		  <label>Gym Time (HHMM)</label>
		  <input type="text" id="presetGymTime" placeholder="0900">
		</div>

		<div class="modal-row">
		  <label>Work Time (HHMM)</label>
		  <input type="text" id="presetWorkTime" placeholder="0900">
		</div>

		<div class="modal-row">
		  <label>Alert Type</label>
		  <select id="presetAlertType">
			<option value="None">None</option>
			<option value="Generic">Generic</option>
			<option value="Birthday">Birthday</option>
			<option value="Work">Work</option>
			<option value="PublicHoliday">PublicHoliday</option>
			<option value="Deadline">Deadline</option>
			<option value="School">School</option>
		  </select>
		</div>

		<div class="modal-row">
		  <label>Alert Text</label>
		  <input type="text" id="presetAlertText" placeholder="Special event">
		</div>

		<div class="modal-buttons">
		  <button id="savePresetBtn">Save Preset</button>
		  <button id="cancelPresetBtn">Cancel</button>
		</div>
	  </div>
	</div>
	
	<!-- Create Workout Modal -->
	<div class="overlay" id="createWorkoutOverlay">
	  <div class="modal" id="createWorkoutModal">
		<!-- Header Section -->
		<div class="workout-header">
		  <div class="workout-date"></div>
		  <input type="text" id="workoutTitleInput" placeholder="Enter workout title..." class="title-input">
		  <div class="workout-times">
			<div class="time-group">
			  <span class="time-label">Start</span>
			  <input type="datetime-local" id="workoutStartTime">
			</div>
			<div class="time-divider"></div>
			<div class="time-group">
			  <span class="time-label">End</span>
			  <input type="datetime-local" id="workoutEndTime">
			</div>
		  </div>
		</div>

		<!-- Exercises Section -->
		<div class="exercises-section">
		  <div id="exercisesList">
			<!-- Exercise blocks will be inserted here -->
		  </div>
		  <button id="addExerciseBtn" class="action-button">
			<span class="plus-icon">+</span> Add Exercise
		  </button>
		</div>

		<div class="modal-buttons">
		  <button id="createWorkoutSaveBtn" title="Save Workout">Save</button>
		  <button id="createWorkoutCancelBtn" title="Cancel">Cancel</button>
		</div>
	  </div>
	</div>

	<!-- Exercise Selection Modal -->
	<div class="overlay" id="exerciseSelectionOverlay">
	  <div class="modal" id="exerciseSelectionModal">
		<div class="modal-header">
		  <h2>Select Exercises</h2>
		  <div class="search-box">
			<input type="text" id="exerciseSearchInput" placeholder="Search exercises...">
		  </div>
		</div>
		
		<div class="exercises-list" id="exerciseSelectionList">
		  <!-- Exercise options will be populated here -->
		</div>

		<div class="modal-buttons">
		  <button id="exerciseSelectionSaveBtn" class="primary-btn">Add Selected</button>
		  <button id="exerciseSelectionCancelBtn" class="secondary-btn">Cancel</button>
		</div>
	  </div>
	</div>

	<!-- Exercise Block Template -->
	<template id="exerciseTemplate">
	  <div class="exercise-block">
		<div class="exercise-header">
		  <div class="exercise-title"></div>
		  <button class="remove-exercise-btn" title="Remove Exercise">√ó</button>
		</div>
		
		<div class="sets-section">
		  <div class="sets-list">
			<!-- Sets will be inserted here -->
		  </div>
		  <button class="add-set-btn">
			<span class="plus-icon">+</span> Add Set
		  </button>
		</div>
	  </div>
	</template>

	<!-- Set Template -->
	<template id="setTemplate">
	  <div class="set-row">
		<div class="set-number"></div>
		<div class="set-inputs">
		  <input type="number" class="weight-input" placeholder="kg" min="0" step="0.5">
		  <span class="separator">√ó</span>
		  <input type="number" class="reps-input" placeholder="reps" min="1" step="1">
		  <span class="separator">@</span>
		  <input type="number" class="rpe-input" placeholder="RPE" min="1" max="10" step="0.5">
		</div>
		<button class="remove-set-btn" title="Remove Set">
		  <svg viewBox="0 0 24 24" width="18" height="18" stroke="currentColor" stroke-width="2" fill="none">
			<path d="M18 6L6 18M6 6l12 12"/>
		  </svg>
		</button>
	  </div>
	</template>
  <script>
    /*
      =======================================
      =      1) Data, Constants, Config     =
      =======================================
    */

    const START_YEAR = 2020;
    const END_YEAR = 2030;
	const LS_PRESETS_KEY = "customPresets";
	
	let customPresets = JSON.parse(localStorage.getItem(LS_PRESETS_KEY)) || [];
	let modalZIndexCounter = 2000;
	
	const baseColorOptions = [
	  { className: "off-bg", label: "Off (Weekly Leave)" },
	  { className: "al-bg", label: "Annual Leave" },
	  { 
		className: "shift-0000",
		label: "00:00",
		data: {
		  workTime: "0000",
		  color: "#926E8E"
		}
	  },
	  { 
		className: "shift-0100",
		label: "01:00",
		data: {
		  workTime: "0100",
		  color: "#A47887"
		}
	  },
	  { 
		className: "shift-0200",
		label: "02:00",
		data: {
		  workTime: "0200",
		  color: "#B78381"
		}
	  },
	  { 
		className: "shift-0300",
		label: "03:00",
		data: {
		  workTime: "0300",
		  color: "#C8917A"
		}
	  },
	  { 
		className: "shift-0400",
		label: "04:00",
		data: {
		  workTime: "0400",
		  color: "#DB9C73"
		}
	  },
	  { 
		className: "shift-0500",
		label: "05:00",
		data: {
		  workTime: "0500",
		  color: "#EDA76D"
		}
	  },
	  { 
		className: "shift-0600",
		label: "06:00",
		data: {
		  workTime: "0600",
		  color: "#FFAD66"
		}
	  },
	  { 
		className: "shift-0700",
		label: "07:00",
		data: {
		  workTime: "0700",
		  color: "#EEAE74"
		}
	  },
	  { 
		className: "shift-0800",
		label: "08:00",
		data: {
		  workTime: "0800",
		  color: "#DEAF83"
		}
	  },
	  { 
		className: "shift-0900",
		label: "09:00",
		data: {
		  workTime: "0900",
		  color: "#D0A77D"
		}
	  },
	  { 
		className: "shift-1000",
		label: "10:00",
		data: {
		  workTime: "1000",
		  color: "#BDB2A0"
		}
	  },
	  { 
		className: "shift-1100",
		label: "11:00",
		data: {
		  workTime: "1100",
		  color: "#ACB3AE"
		}
	  },
	  { 
		className: "shift-1200",
		label: "12:00",
		data: {
		  workTime: "1200",
		  color: "#9CB4BC"
		}
	  },
	  { 
		className: "shift-1300",
		label: "13:00",
		data: {
		  workTime: "1300",
		  color: "#8CB4CA"
		}
	  },
	  { 
		className: "shift-1400",
		label: "14:00",
		data: {
		  workTime: "1400",
		  color: "#7AB6D9"
		}
	  },
	  { 
		className: "shift-1500",
		label: "15:00",
		data: {
		  workTime: "1500",
		  color: "#76A7D1"
		}
	  },
	  { 
		className: "shift-1600",
		label: "16:00",
		data: {
		  workTime: "1600",
		  color: "#7198C9"
		}
	  },
	  { 
		className: "shift-1700",
		label: "17:00",
		data: {
		  workTime: "1700",
		  color: "#6D8BC2"
		}
	  },
	  { 
		className: "shift-1800",
		label: "18:00",
		data: {
		  workTime: "1800",
		  color: "#697DBA"
		}
	  },
	  { 
		className: "shift-1900",
		label: "19:00",
		data: {
		  workTime: "1900",
		  color: "#627AA3"
		}
	  },
	  { 
		className: "shift-2000",
		label: "20:00",
		data: {
		  workTime: "2000",
		  color: "#6060AA"
		}
	  },
	  { 
		className: "shift-2100",
		label: "21:00",
		data: {
		  workTime: "2100",
		  color: "#5C4EA2"
		}
	  },
	  { 
		className: "shift-2200",
		label: "22:00",
		data: {
		  workTime: "2200",
		  color: "#6E599B"
		}
	  },
	  { 
		className: "shift-2300",
		label: "23:00",
		data: {
		  workTime: "2300",
		  color: "#806395"
		}
	  }
	];
	
	let colorOptions = [
      { className: "off-bg",       label: "Off (Weekly Leave)" },
      { className: "al-bg",        label: "Annual Leave" }
    ];
	colorOptions = [...baseColorOptions, ...customPresets];

    const monthNames = [
      "January","February","March","April","May","June",
      "July","August","September","October","November","December"
    ];
    const dayNames = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];

    const LS_CALENDAR_DATA_KEY = "multiYearCalendarData";
    const LS_DEFAULT_CYCLE_KEY = "defaultCycleMultiYear";

    const MS_IN_DAY = 86400000;

    // Load or initialize global calendar data
    let calendarData = JSON.parse(localStorage.getItem(LS_CALENDAR_DATA_KEY)) || {};

    // If no default cycle stored yet
    let defaultCycleData = JSON.parse(localStorage.getItem(LS_DEFAULT_CYCLE_KEY)) || {
      pattern: [],
      startDate: null
    };

    // We default to the current month/year (clamped to 2020‚Äì2030)
    const now = new Date();
    let currentYear = now.getFullYear();
    if (currentYear < START_YEAR) currentYear = START_YEAR;
    if (currentYear > END_YEAR)   currentYear = END_YEAR;
    let currentMonth = now.getMonth(); // 0-11

    const selectedDates = new Set();
    let isDragging = false;

    // For charts
    let weightChart = null;
    let hevyProgressChart = null;
    let exerciseWeightProgressionChart = null;
    let exerciseRepProgressionChart = null;
    let volumeChart = null;
	let exerciseFrequencyChart = null;
    let exerciseVolumeChart = null;
    let exerciseOrmProgressChart = null;
	let currentVolumeDateKey = null;
	let totalVolumeDistributionChart = null;
	
	// Preset creation related
	let presetCreationModal;
	let savePresetBtn;
	let cancelPresetBtn;
	
	// Workout editing
	let isEditingWorkout = false;
	let editingWorkoutId = null;

    /*
      =======================================
      =       2) Helper Functions           =
      =======================================
    */
	
	function addExistingSet(block, setData) {
	  if (!block || !setData) return;

	  const exerciseType = block.getAttribute('data-exercise-type');
	  const template = getSetTemplate(exerciseType);
	  const clone = template.content.cloneNode(true);
	  const setsList = block.querySelector('.sets-list');
	  const newSetRow = clone.querySelector('.set-row');
	  
	  if (!setsList || !newSetRow) return;
	  
	  // Helper function to safely set input values
	  const setInputValue = (selector, value) => {
		const input = newSetRow.querySelector(selector);
		if (input) {
		  input.value = value;
		}
	  };
	  
	  // Populate the set data based on exercise type
	  if (exerciseType === 'distance_duration') {
		const distanceKm = setData.distance_meters / 1000;
		setInputValue('.distance-input', distanceKm.toFixed(2));
		
		const hours = Math.floor(setData.duration_seconds / 3600);
		const minutes = Math.floor((setData.duration_seconds % 3600) / 60);
		const seconds = setData.duration_seconds % 60;
		
		setInputValue('.duration-hours', hours.toString().padStart(2, '0'));
		setInputValue('.duration-minutes', minutes.toString().padStart(2, '0'));
		setInputValue('.duration-seconds', seconds.toString().padStart(2, '0'));
		
	  } else if (exerciseType === 'duration') {
		const hours = Math.floor(setData.duration_seconds / 3600);
		const minutes = Math.floor((setData.duration_seconds % 3600) / 60);
		const seconds = setData.duration_seconds % 60;
		
		setInputValue('.duration-hours', hours.toString().padStart(2, '0'));
		setInputValue('.duration-minutes', minutes.toString().padStart(2, '0'));
		setInputValue('.duration-seconds', seconds.toString().padStart(2, '0'));
		
	  } else if (exerciseType === 'bodyweight_weighted' || exerciseType === 'bodyweight_assisted') {
		setInputValue('.assistance-input', setData.weight_kg || 0);
		setInputValue('.reps-input', setData.reps);
		
	  } else if (exerciseType === 'reps_only') {
		setInputValue('.reps-input', setData.reps);
		
	  } else {
		setInputValue('.weight-input', setData.weight_kg);
		setInputValue('.reps-input', setData.reps);
		const rpeInput = newSetRow.querySelector('.rpe-input');
		if (rpeInput && setData.rpe) {
		  rpeInput.value = setData.rpe;
		}
	  }
	  
	  setsList.appendChild(newSetRow);
	  
	  // Initialize time inputs if needed
	  if (exerciseType === 'distance_duration' || exerciseType === 'duration') {
		initTimeInputs(newSetRow);
	  }
	  
	  renumberSets(block);
	}
	
	function openTotalDurationModal(exerciseName, dateKey) {
	  openModalOnTop("exerciseVolumeOverlay");
	  
	  // Set the header text so that the chart always shows "Total Duration Over Time"
	  document.getElementById("exerciseVolumeModal")
		.querySelector("h2").textContent = "Total Duration Over Time";
	  
	  // Store these for later use (for date-range button updates)
	  currentExerciseVolumeName = exerciseName;
	  currentExerciseVolumeDateKey = dateKey;
	  
	  // Build the chart using the function that converts seconds to minutes and sets the title
	  buildDurationTimeChart(exerciseName, dateKey);
	}
	
	function buildDurationProgressionChart(exerciseName, highlightDateKey) {
	  // Get date range from active button
	  const selectedRange = document.querySelector('#exerciseVolumeModal .date-range-btn.active').getAttribute('data-range');
	  const refDate = parseDateKey(highlightDateKey);
	  const { start, end } = getDateRangeBounds(selectedRange, refDate);
	  
	  const dateKeys = Object.keys(calendarData)
		.filter(key => {
		  const date = parseDateKey(key);
		  return date >= start && date <= end;
		})
		.sort();

	  const dataMap = {};

	  // Calculate total duration for each day
	  dateKeys.forEach(k => {
		const dayObj = calendarData[k];
		if (!dayObj.hevyWorkouts || dayObj.hevyWorkouts.length === 0) return;

		let totalDurationForDay = 0;
		dayObj.hevyWorkouts.forEach(workout => {
		  workout.exercises.forEach(ex => {
			if (ex.title === exerciseName) {
			  ex.sets.forEach(set => {
				if (set.duration_seconds) {
				  totalDurationForDay += set.duration_seconds;
				}
			  });
			}
		  });
		});
		
		if (totalDurationForDay > 0) {
		  dataMap[k] = totalDurationForDay;
		}
	  });

	  const chartKeys = Object.keys(dataMap).sort();
	  if (chartKeys.length < 1) {
		destroyExerciseVolumeChart();
		showCustomAlert("No duration data found for this time period.");
		return;
	  }

	  const dataPoints = chartKeys.map(k => ({
		x: k,
		y: dataMap[k]
	  }));
	  
	  const labels = chartKeys.map(k => {
		const d = parseDateKey(k);
		return d.toLocaleDateString('en-US', {
		  month: 'short',
		  day: 'numeric',
		  year: 'numeric'
		});
	  });

	  const durations = dataPoints.map(dp => dp.y);
	  const minDuration = Math.min(...durations);
	  const maxDuration = Math.max(...durations);
	  const range = maxDuration - minDuration;
	  const padding = range * 0.1;
	  const suggestedMin = Math.max(0, minDuration - padding);
	  const suggestedMax = maxDuration + padding;

	  destroyExerciseVolumeChart();
	  const ctx = document.getElementById('exerciseVolumeChart').getContext('2d');

	  const { bgColors, borderColors, pointRadii } = buildHighlightArrays(
		dataPoints,
		highlightDateKey,
		'#4DAAFF',
		'#FFDD77',
		2.5,
		5
	  );

	  exerciseVolumeChart = new Chart(ctx, {
		type: 'line',
		data: {
		  labels: labels,
		  datasets: [{
			label: `Duration: ${exerciseName}`,
			data: dataPoints.map(dp => dp.y),
			borderColor: '#4DAAFF',
			backgroundColor: 'rgba(77, 170, 255,0.2)',
			fill: true,
			tension: 0.1,
			pointRadius: pointRadii,
			pointBackgroundColor: bgColors,
			pointBorderColor: borderColors,
			pointHoverRadius: 6
		  }]
		},
		options: {
		  responsive: true,
		  maintainAspectRatio: false,
		  scales: {
			x: {
			  title: { display: true, text: 'Date' },
			  ticks: { color: '#ccc' },
			  grid: { color: '#555' }
			},
			y: {
			  suggestedMin,
			  suggestedMax,
			  title: { display: true, text: 'Duration (seconds)' },
			  ticks: { 
				color: '#ccc',
				callback: function(value) {
				  return formatDuration(value);
				}
			  },
			  grid: { color: '#555' }
			}
		  },
		  plugins: {
			legend: { labels: { color: '#eee' } },
			tooltip: {
			  callbacks: {
				label: function(context) {
				  const duration = context.raw;
				  return `Duration: ${formatDuration(duration)}`;
				}
			  }
			}
		  }
		}
	  });
	}
	
	function getDurationStats(exerciseName) {
	  let totalOccurrences = 0;
	  let longestSetDuration = 0;
	  let longestSetDate = null;
	  let longestSessionDuration = 0;
	  let longestSessionDate = null;
	  let totalDuration = 0;

	  Object.entries(calendarData).forEach(([dateKey, dayData]) => {
		if (!dayData.hevyWorkouts) return;

		dayData.hevyWorkouts.forEach(workout => {
		  let sessionDuration = 0;

		  workout.exercises.forEach(exercise => {
			if (exercise.title === exerciseName) {
			  totalOccurrences++;

			  exercise.sets.forEach(set => {
				if (!set.duration_seconds) return;

				const dur = set.duration_seconds;
				totalDuration += dur;
				sessionDuration += dur;

				// Longest single-set duration
				if (dur > longestSetDuration) {
				  longestSetDuration = dur;
				  longestSetDate = workout.start_time;
				}
			  });
			}
		  });

		  // After processing all sets in this workout
		  if (sessionDuration > longestSessionDuration) {
			longestSessionDuration = sessionDuration;
			longestSessionDate = workout.start_time;
		  }
		});
	  });

	  return {
		totalOccurrences,
		longestSetDuration,
		longestSetDate,
		longestSessionDuration,
		longestSessionDate,
		totalDuration
	  };
	}
	
	function openModalOnTop(overlayId) {
	  const overlayEl = document.getElementById(overlayId);
	  if (!overlayEl) return;

	  // 1) Mark it active so it becomes visible (CSS .overlay.active { display: flex; ...})
	  overlayEl.classList.add("active");

	  // 2) Bump our counter and apply it
	  modalZIndexCounter++;
	  overlayEl.style.zIndex = modalZIndexCounter;
	}
	
	function formatDuration(seconds) {
	  const hours = Math.floor(seconds / 3600);
	  const minutes = Math.floor((seconds % 3600) / 60);
	  const secs = seconds % 60;
	  
	  if (hours > 0) {
		return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
	  }
	  return `${minutes}:${secs.toString().padStart(2, '0')}`;
	}

	// Helper function to format pace (min/km)
	function formatPace(meters, seconds) {
	  if (!meters || !seconds || meters <= 0) return "-:--";
	  const km = meters / 1000;
	  const minutes = seconds / 60;
	  const pace = minutes / km;
	  
	  const paceMinutes = Math.floor(pace);
	  const paceSeconds = Math.floor((pace - paceMinutes) * 60);
	  return `${paceMinutes}:${paceSeconds.toString().padStart(2, '0')}`;
	}

	// Get exercise template info including type
	function getExerciseTemplate(exerciseTitle) {
	  return exerciseTemplates.find(t => t.title === exerciseTitle);
	}
	
	// Function to get set template based on exercise type
	function getSetTemplate(exerciseType) {
	  const baseTemplate = document.getElementById('setTemplate');
	  const newTemplate = document.createElement('template');
	  
	  switch(exerciseType) {
		case 'distance_duration':
		  newTemplate.innerHTML = `
			<div class="set-row">
			  <div class="set-number"></div>
			  <div class="set-inputs">
				<input type="number" class="distance-input" placeholder="km" min="0" step="0.01" style="width: 80px;">
				<span class="separator">for</span>
				<!-- Time inputs -->
				<div style="display: inline-flex; gap: 4px; align-items: center;">
				  <input type="number" class="duration-hours" placeholder="HH" min="0" max="99" style="width: 50px;">
				  <span style="color: #888;">:</span>
				  <input type="number" class="duration-minutes" placeholder="MM" min="0" max="59" style="width: 50px;">
				  <span style="color: #888;">:</span>
				  <input type="number" class="duration-seconds" placeholder="SS" min="0" max="59" style="width: 50px;">
				</div>
				<div class="pace-display" style="margin-left: 10px; color: #888;">-:-- /km</div>
			  </div>
			  <button class="remove-set-btn" title="Remove Set">
				<svg viewBox="0 0 24 24" width="18" height="18" stroke="currentColor" stroke-width="2" fill="none">
				  <path d="M18 6L6 18M6 6l12 12"/>
				</svg>
			  </button>
			</div>
		  `;
		  break;
		  
		case 'duration':
		  newTemplate.innerHTML = `
			<div class="set-row">
			  <div class="set-number"></div>
			  <div class="set-inputs">
				<div style="display: inline-flex; gap: 4px; align-items: center;">
				  <input type="number" class="duration-hours" placeholder="HH" min="0" max="99" style="width: 50px;">
				  <span style="color: #888;">:</span>
				  <input type="number" class="duration-minutes" placeholder="MM" min="0" max="59" style="width: 50px;">
				  <span style="color: #888;">:</span>
				  <input type="number" class="duration-seconds" placeholder="SS" min="0" max="59" style="width: 50px;">
				</div>
			  </div>
			  <button class="remove-set-btn" title="Remove Set">
				<svg viewBox="0 0 24 24" width="18" height="18" stroke="currentColor" stroke-width="2" fill="none">
				  <path d="M18 6L6 18M6 6l12 12"/>
				</svg>
			  </button>
			</div>
		  `;
		  break;
		  
		case 'bodyweight_weighted':
		  newTemplate.innerHTML = `
			<div class="set-row">
			  <div class="set-number"></div>
			  <div class="set-inputs">
				<span class="fixed-label" style="margin-right: 4px;">Bodyweight +</span>
				<input type="number" class="assistance-input" placeholder="Added weight" min="0" step="0.5" style="width: 130px;">
				<span class="separator" style="padding: 0 4px;">√ó</span>
				<input type="number" class="reps-input" placeholder="reps" min="1" step="1">
			  </div>
			  <button class="remove-set-btn" title="Remove Set">
				<svg viewBox="0 0 24 24" width="18" height="18" stroke="currentColor" stroke-width="2" fill="none">
				  <path d="M18 6L6 18M6 6l12 12"/>
				</svg>
			  </button>
			</div>
		  `;
		  break;
		  
		case 'bodyweight_assisted':
		  newTemplate.innerHTML = `
			<div class="set-row">
			  <div class="set-number"></div>
			  <div class="set-inputs">
				<span class="fixed-label" style="margin-right: 4px;">Bodyweight ‚àí</span>
				<input type="number" class="assistance-input" placeholder="Assist weight" min="0" step="0.5" style="width: 130px;">
				<span class="separator" style="padding: 0 4px;">√ó</span>
				<input type="number" class="reps-input" placeholder="reps" min="1" step="1">
			  </div>
			  <button class="remove-set-btn" title="Remove Set">
				<svg viewBox="0 0 24 24" width="18" height="18" stroke="currentColor" stroke-width="2" fill="none">
				  <path d="M18 6L6 18M6 6l12 12"/>
				</svg>
			  </button>
			</div>
		  `;
		  break;

		case 'reps_only':
		  newTemplate.innerHTML = `
			<div class="set-row">
			  <div class="set-number"></div>
			  <div class="set-inputs">
				<span class="fixed-label" style="margin-right: 4px;">Bodyweight x</span>
				<input type="number" class="reps-input" placeholder="reps" min="1" step="1">
			  </div>
			  <button class="remove-set-btn" title="Remove Set">
				<svg viewBox="0 0 24 24" width="18" height="18" stroke="currentColor" stroke-width="2" fill="none">
				  <path d="M18 6L6 18M6 6l12 12"/>
				</svg>
			  </button>
			</div>
		  `;
		  break;
		  
		default:
		  newTemplate.innerHTML = baseTemplate.innerHTML;
		  break;
	  }
	  
	  return newTemplate;
	}

	
	function initializePresetCreation() {
	    presetCreationModal = document.getElementById('presetCreationOverlay');
	    savePresetBtn = document.getElementById('savePresetBtn');
	    cancelPresetBtn = document.getElementById('cancelPresetBtn');

	    // Save preset handler
		savePresetBtn.addEventListener("click", function() {
		  const presetName = document.getElementById("presetNameInput").value.trim();
		  const presetColor = document.getElementById("presetColorInput").value;
		  const gymTime = document.getElementById("presetGymTime").value.trim();
		  const workTime = document.getElementById("presetWorkTime").value.trim();

		  // Validation
		  if (!presetName) {
			showCustomAlert("Preset name is required!");
			document.getElementById("presetNameInput").focus();
			return;
		  }
		  
		  if (gymTime && !validateTimeHHMM(gymTime)) {
			showCustomAlert("Invalid Gym Time format! Use HHMM (e.g. 0900)");
			return;
		  }

		  if (workTime && !validateTimeHHMM(workTime)) {
			showCustomAlert("Invalid Work Time format! Use HHMM (e.g. 0900)");
			return;
		  }

		  // Create new preset object
		  const newPreset = {
			className: `custom-${presetName.toLowerCase().replace(/[^a-z0-9]/gi, '-')}`,
			label: presetName,
			custom: true,
			data: {
			  color: presetColor,
			  gym: document.getElementById('presetWorkoutSelect').value,
			  gymTime: gymTime,
			  workTime: workTime,
			  alert: {
				type: document.getElementById('presetAlertType').value,
				text: document.getElementById('presetAlertText').value.trim()
			  }
			}
		  };

		  // Add to storage
		  customPresets.push(newPreset);
		  localStorage.setItem(LS_PRESETS_KEY, JSON.stringify(customPresets));

		  // Update UI
		  colorOptions = [...baseColorOptions, ...customPresets];
		  buildColorSwatches();

		  // Add dynamic CSS
		  const style = document.createElement('style');
		  style.textContent = `.${newPreset.className} { background-color: ${newPreset.data.color}; }`;
		  document.head.appendChild(style);

		  // Close modal
		  presetCreationModal.classList.remove('active');
		  showCustomAlert(`"${presetName}" preset created successfully!`);
		});

		  // Cancel handler
		  cancelPresetBtn.addEventListener('click', function() {
			presetCreationModal.classList.remove('active');
		  });
	}

	// Initialize when DOM loads
	document.addEventListener('DOMContentLoaded', initializePresetCreation);
	
	function addNewPreset() {
	  // Reset form
	  document.getElementById('presetNameInput').value = '';
	  document.getElementById('presetColorInput').value = '#4daaff';
	  document.getElementById('presetWorkoutSelect').value = 'None';
	  document.getElementById('presetGymTime').value = '';
	  document.getElementById('presetWorkTime').value = '';
	  document.getElementById('presetAlertType').value = 'None';
	  document.getElementById('presetAlertText').value = '';

	  
	  // Show modal
	  presetCreationModal.classList.add('active');
	}
	
	// Useful for Exercise History Modal
	function getAllSessionsForExercise(exerciseName) {
	  const sessions = [];
	  
	  Object.keys(calendarData).forEach(dateKey => {
		const dayObj = calendarData[dateKey];
		if (dayObj.hevyWorkouts) {
		  dayObj.hevyWorkouts.forEach(workout => {
			workout.exercises.forEach(exercise => {
			  if (exercise.title === exerciseName) {
				sessions.push({
				  date: parseDateKey(dateKey),
				  dateKey,
				  workout,
				  exercise: exercise
				});
			  }
			});
		  });
		}
	  });
	  
	  // Sort by date descending (newest first)
	  return sessions.sort((a, b) => b.date - a.date);
	}
	
	// Assists with fixing 'null' weight values for bodyweight exercises like pull ups
	const bodyweightExercises = new Set();
	function findNearestWeight(dateKey) {
	  const targetDate = parseDateKey(dateKey);
	  
	  const datesWithWeights = Object.keys(calendarData)
		.filter(key => calendarData[key].weight)
		.map(key => ({
		  key,
		  date: parseDateKey(key),
		  weight: calendarData[key].weight
		}))
		.sort((a, b) => a.date - b.date);

	  if (datesWithWeights.length === 0) return 0;

	  let nearestDate = datesWithWeights[0];
	  let minDiff = Math.abs(targetDate - nearestDate.date);

	  for (const dateObj of datesWithWeights) {
		const diff = Math.abs(targetDate - dateObj.date);
		if (diff < minDiff) {
		  minDiff = diff;
		  nearestDate = dateObj;
		}
	  }
	  return nearestDate.weight;
	}

	function fixNullWeights() {
	  bodyweightExercises.clear();
	  Object.keys(calendarData).forEach(dateKey => {
		const dayData = calendarData[dateKey];
		if (!dayData.hevyWorkouts) return;
		dayData.hevyWorkouts.forEach(workout => {
		  workout.exercises.forEach(exercise => {
			exercise.sets.forEach((set, setIndex) => {
			  // Previously: if (set.weight_kg === null || set.weight_kg === undefined) { 
			  //               set.weight_kg = findNearestWeight(dateKey);
			  //             }
			  // Now: do nothing so that a null weight_kg remains null.
			});
		  });
		});
		calendarData[dateKey] = dayData;
	  });
	  localStorage.setItem(LS_CALENDAR_DATA_KEY, JSON.stringify(calendarData));
	}

	// Hook into weight updates
	const originalSetDayData = window.setDayData;
	window.setDayData = function(dateKey, newData) {
	  // Call original function
	  originalSetDayData(dateKey, newData);
	  
	  // If weight was updated, update bodyweight exercises
	  if (newData.weight !== undefined) {
		updateBodyweightExercises();
	  }
	};

	function updateBodyweightExercises() {
	  // Automatic update removed.
	  // Previously, this function updated each bodyweight exercise‚Äôs set.weight_kg
	}
	
	// 1) Preload images
	const monthImagesToPreload = monthNames.map((month) => {
		return month.toLowerCase() + '.jpg';
	});
	monthImagesToPreload.forEach((imgSrc) => {
		const img = new Image();
		img.src = imgSrc;
	});
	
	function updateBackgroundForMonth(month) {
	  // monthNames is already defined in your code.
	  // Convert the month name to lowercase and append the extension.
	  const imageFile = monthNames[month].toLowerCase() + '.jpg';
	  document.body.style.backgroundImage = `url('${imageFile}')`;
	  document.body.style.backgroundSize = 'cover';
	  document.body.style.backgroundPosition = 'center center';
	}
	
	function hasAnyPR(dateKey) {
	  // Grab the day data
	  const dayObj = getDayData(dateKey);
	  if (!dayObj.hevyWorkouts || dayObj.hevyWorkouts.length === 0) return false;

	  // For each workout‚Äôs exercises, check for:
	  //  - Set-based PR (exceeding previous best weight/reps)
	  //  - Volume PR
	  //  - 1RM PR
	  for (const workout of dayObj.hevyWorkouts) {
		for (const ex of workout.exercises) {
		  // 1) Compare with prior best (weight + reps)
		  const { bestWeight, bestRepsForWeight } = getBestWeightAndRepsBeforeDate(ex.title, dateKey);

		  // 2) Calculate this day‚Äôs total volume + highest 1RM for this exercise
		  let dayVolume = 0;
		  let highestOrmForThisEx = 0;
		  ex.sets.forEach(set => {
			const vol = set.weight_kg * set.reps;
			dayVolume += vol;
			const oneRepMax = computeOrm(set.weight_kg, set.reps);
			if (oneRepMax > highestOrmForThisEx) highestOrmForThisEx = oneRepMax;
		  });

		  // 3) Compare volume / 1RM with prior best
		  const prevMaxVolume = getMaxVolumeForExerciseBeforeDate(ex.title, dateKey);
		  const prevMaxOrm    = getMaxOrmForExerciseBeforeDate(ex.title, dateKey);
		  if (dayVolume > prevMaxVolume) return true; // Volume PR
		  if (highestOrmForThisEx > prevMaxOrm) return true; // 1RM PR

		  // 4) Check if any set is a ‚Äúweight PR‚Äù or ‚Äúweight+reps PR‚Äù
		  for (const set of ex.sets) {
			// If this set's weight is above the old best weight,
			// or same weight but more reps, it's a new PR
			if (
			  set.weight_kg > bestWeight ||
			  (set.weight_kg === bestWeight && set.reps > bestRepsForWeight)
			) {
			  return true;
			}
		  }
		}
	  }
	  // If no PR found in all workouts, return false
	  return false;
	}

	function hasAnyPR(dateKey) {
	  // Grab the day data
	  const dayObj = getDayData(dateKey);
	  if (!dayObj.hevyWorkouts || dayObj.hevyWorkouts.length === 0) return false;

	  // For each workout‚Äôs exercises, check for:
	  //  - Set-based PR (exceeding previous best weight/reps)
	  //  - Volume PR
	  //  - ORM PR
	  for (const workout of dayObj.hevyWorkouts) {
		for (const ex of workout.exercises) {
		  // 1) Compare with prior best (weight)
		  const { bestWeight, bestRepsForWeight } = getBestWeightAndRepsBeforeDate(ex.title, dateKey);

		  // 2) Calculate day‚Äôs total volume + highest ORM for this exercise
		  let dayVolume = 0;
		  let highestOrmThisEx = 0;
		  ex.sets.forEach(set => {
			const vol = set.weight_kg * set.reps;
			dayVolume += vol;
			const oneRepMax = computeOrm(set.weight_kg, set.reps);
			if (oneRepMax > highestOrmThisEx) {
			  highestOrmThisEx = oneRepMax;
			}
		  });

		  // 3) Compare volume, ORM with prior best
		  const prevMaxVolume = getMaxVolumeForExerciseBeforeDate(ex.title, dateKey);
		  const prevMaxOrm    = getMaxOrmForExerciseBeforeDate(ex.title, dateKey);
		  if (dayVolume > prevMaxVolume) return true;          // Volume PR
		  if (highestOrmThisEx > prevMaxOrm) return true;      // ORM PR

		  // 4) Check if any set is a ‚Äúweight PR‚Äù or ‚Äúweight+reps PR‚Äù
		  for (const set of ex.sets) {
			if (
			  set.weight_kg > bestWeight ||
			  (set.weight_kg === bestWeight && set.reps > bestRepsForWeight)
			) {
			  return true;
			}
		  }
		}
	  }
	  // If we never returned true, no PR found
	  return false;
	}
	
	function getDateRangeBounds(rangeType, referenceDate) {
	  const refDate = new Date(referenceDate);
	  let start, end;

	  switch(rangeType) {
		case 'year':
		  start = new Date(refDate.getFullYear(), 0, 1);
		  end = new Date(refDate.getFullYear(), 11, 31);
		  break;
		case 'month':
		  start = new Date(refDate.getFullYear(), refDate.getMonth(), 1);
		  end = new Date(refDate.getFullYear(), refDate.getMonth() + 1, 0);
		  break;
		case 'week':
		  // Get Monday of current week
		  const day = refDate.getDay();
		  const diff = refDate.getDate() - day + (day === 0 ? -6 : 1);
		  start = new Date(refDate.setDate(diff));
		  end = new Date(start);
		  end.setDate(end.getDate() + 6);
		  break;
		case 'all':
		default:
		  start = new Date(START_YEAR, 0, 1);
		  end = new Date(END_YEAR, 11, 31);
	  }
	  return { start, end };
	}
	
    function getDateKey(dateObj) {
      const y = dateObj.getFullYear();
      const m = String(dateObj.getMonth() + 1).padStart(2,"0");
      const d = String(dateObj.getDate()).padStart(2,"0");
      return `${y}-${m}-${d}`;
    }
    function parseDateKey(dateKey) {
      const [y,m,d] = dateKey.split("-").map(Number);
      return new Date(y, m - 1, d);
    }
    function isToday(dateObj) {
      const nowLocal = new Date();
      return (
        dateObj.getFullYear() === nowLocal.getFullYear() &&
        dateObj.getMonth() === nowLocal.getMonth() &&
        dateObj.getDate() === nowLocal.getDate()
      );
    }
    function isOffDayShift(shiftClass) {
      return (shiftClass === "off-bg" || shiftClass === "al-bg");
    }
    function isTrainingDay(dayObj) {
      return (dayObj.gym !== "Rest" && dayObj.gym !== "None");
    }
    function validateTimeHHMM(value) {
      if (!value) return true;
      return !!value.match(/^([01]\d|2[0-3])[0-5]\d$/);
    }
    function formatTimeForDisplay(time24) {
      if(!time24) return "";
      const hour = parseInt(time24.substring(0,2),10);
      const minute = time24.substring(2,4);
      let period = "am";
      let displayHour = hour;
      if(hour >= 12){
        period = "pm";
        if(hour > 12) displayHour = hour - 12;
      }
      if(hour === 0){
        displayHour = 12;
        period = "am";
      }
      return `${displayHour}:${minute}${period}`;
    }
	function getDayData(dateKey) {
	  if(!calendarData[dateKey]) {
		calendarData[dateKey] = {
		  shiftClass: "off-bg",
		  gym: "None",
		  gymTime: "",
		  workTime: "",
		  completed: false,
		  weight: null,
		  alert: null,
		  hevyWorkouts: [],
		  customColor: null // Add this new field
		};
	  }
	  return calendarData[dateKey];
	}
	
    function setDayData(dateKey, newData) {
      if(!calendarData[dateKey]) {
        calendarData[dateKey] = {};
      }
      Object.assign(calendarData[dateKey], newData);
      localStorage.setItem(LS_CALENDAR_DATA_KEY, JSON.stringify(calendarData));
    }
    function getLastRecordedWeightBefore(dateKey) {
      const dateObj = parseDateKey(dateKey);
      const d = new Date(dateObj.getTime());
      d.setDate(d.getDate() - 1);

      // We'll stop if we go before START_YEAR
      const earliestBoundary = new Date(START_YEAR, 0, 1);

      while(d >= earliestBoundary) {
        const prevKey = getDateKey(d);
        if (calendarData[prevKey] && calendarData[prevKey].weight > 0) {
          return calendarData[prevKey].weight;
        }
        d.setDate(d.getDate() - 1);
      }
      return null;
    }
    function getWeightArrow(dateKey) {
      const dayObj = getDayData(dateKey);
      if(!dayObj.weight || parseFloat(dayObj.weight) <= 0) return "";
      const lastWeight = getLastRecordedWeightBefore(dateKey);
      if(!lastWeight) return "";
      if(dayObj.weight > lastWeight)  return "‚Üë";
      if(dayObj.weight < lastWeight)  return "‚Üì";
      return "";
    }
    function computeFreeTime(dateKey) {
      const dayObj = getDayData(dateKey);
      if(!dayObj.workTime || isOffDayShift(dayObj.shiftClass)){
        return null;
      }
      const curStartHour = parseInt(dayObj.workTime.substring(0,2),10);
      const curStartMin = parseInt(dayObj.workTime.substring(2,4),10);
      let currentShiftDate = parseDateKey(dateKey);
      currentShiftDate.setHours(curStartHour, curStartMin, 0, 0);

      let currentShiftEnd = new Date(currentShiftDate.getTime() + 10 * 3600000);

      // Next day that has a valid workTime (within 2020-2030)
      let nextDate = new Date(parseDateKey(dateKey).getTime());
      nextDate.setDate(nextDate.getDate() + 1);
      let nextWorkShiftDate = null;

      while(nextDate.getFullYear() >= START_YEAR && nextDate.getFullYear() <= END_YEAR) {
        const nextKey = getDateKey(nextDate);
        const nextDay = getDayData(nextKey);
        if(nextDay.workTime && !isOffDayShift(nextDay.shiftClass)) {
          nextWorkShiftDate = new Date(nextDate.getTime());
          const nxHr = parseInt(nextDay.workTime.substring(0,2),10);
          const nxMin = parseInt(nextDay.workTime.substring(2,4),10);
          nextWorkShiftDate.setHours(nxHr, nxMin, 0, 0);
          break;
        }
        nextDate.setDate(nextDate.getDate() + 1);
      }
      if(!nextWorkShiftDate) return null;

      let nextPrepTime = new Date(nextWorkShiftDate.getTime() - 3600000); 
      let gapHours = (nextPrepTime - currentShiftEnd) / 3600000;

      // Subtract 8 hours sleep
      gapHours -= 8;

      return Math.max(0, Math.floor(gapHours));
    }
    function computeCurrentDayFreeTimeFull() {
      const nowLocal = new Date();
      let nextDate = new Date(nowLocal.getFullYear(), nowLocal.getMonth(), nowLocal.getDate() + 1);
      let nextWorkShiftDate = null;

      while(nextDate.getFullYear() >= START_YEAR && nextDate.getFullYear() <= END_YEAR) {
        const nextKey = getDateKey(nextDate);
        const nextDay = getDayData(nextKey);
        if(nextDay.workTime && !isOffDayShift(nextDay.shiftClass)) {
          nextWorkShiftDate = new Date(nextDate.getTime());
          const nxHr = parseInt(nextDay.workTime.substring(0,2),10);
          const nxMin = parseInt(nextDay.workTime.substring(2,4),10);
          nextWorkShiftDate.setHours(nxHr, nxMin, 0, 0);
          break;
        }
        nextDate.setDate(nextDate.getDate() + 1);
      }
      if(!nextWorkShiftDate) return "N/A";

      const diffMs = nextWorkShiftDate - nowLocal - 8 * 3600000; // Subtract 8 hours sleep
      if (diffMs < 0) return "N/A";
      const totalMinutes = Math.floor(diffMs / 60000);
      const hours = Math.floor(totalMinutes / 60);
      const minutes = totalMinutes % 60;
      return `${hours.toString().padStart(2,"0")}:${minutes.toString().padStart(2,"0")}`;
    }
    function getDefaultDataForDate(dateKey){
      if(!defaultCycleData.pattern.length || !defaultCycleData.startDate){
        return {
          shiftClass: "off-bg",
          gym: "None",
          gymTime: "",
          workTime: "",
          completed: false,
          weight: null,
          alert: null,
          hevyWorkouts: []
        };
      }
      const startDate = parseDateKey(defaultCycleData.startDate);
      const currentDate = parseDateKey(dateKey);
      const diffDays = Math.floor((currentDate - startDate) / MS_IN_DAY);
      const patternLength = defaultCycleData.pattern.length;
      const patternIndex = ((diffDays % patternLength) + patternLength) % patternLength;
      return defaultCycleData.pattern[patternIndex];
    }
    function escapeHtml(str) {
      return str.replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }

    // Compute approximate 1RM (Brzycki/Epley)
    function computeOrm(weightKg, reps) {
      if(reps <= 0 || weightKg <= 0) return 0;
      if(reps <= 10) {
        // Brzycki
        return weightKg / (1.0278 - 0.0278 * reps);
      } else {
        // Epley
        return weightKg * (1 + (reps / 30));
      }
    }

    // Return best historical (weight, reps) for an exercise (before a date)
    function getBestWeightAndRepsBeforeDate(exerciseName, dateKey) {
      let bestWeight = 0;
      let bestRepsForWeight = 0;

      const targetDate = parseDateKey(dateKey);

      for (const k of Object.keys(calendarData)) {
        const d = parseDateKey(k);
        if (d < targetDate) {
          const dayObj = calendarData[k];
          if (dayObj.hevyWorkouts) {
            dayObj.hevyWorkouts.forEach(workout => {
              workout.exercises.forEach(ex => {
                if (ex.title === exerciseName) {
                  ex.sets.forEach(s => {
                    if (s.weight_kg > bestWeight) {
                      bestWeight = s.weight_kg;
                      bestRepsForWeight = s.reps;
                    }
                    else if (s.weight_kg === bestWeight && s.reps > bestRepsForWeight) {
                      bestRepsForWeight = s.reps;
                    }
                  });
                }
              });
            });
          }
        }
      }
      return { bestWeight, bestRepsForWeight };
    }
    function getMaxVolumeForExerciseBeforeDate(exerciseName, dateKey) {
      const targetDate = parseDateKey(dateKey);
      let maxVolume = 0;
      for(const k of Object.keys(calendarData)) {
        const d = parseDateKey(k);
        if(d < targetDate) {
          let dayVolume = 0;
          const dayObj = calendarData[k];
          if(dayObj.hevyWorkouts) {
            dayObj.hevyWorkouts.forEach(workout => {
              workout.exercises.forEach(ex => {
                if(ex.title === exerciseName) {
                  ex.sets.forEach(s => {
                    dayVolume += (s.weight_kg * s.reps);
                  });
                }
              });
            });
          }
          if(dayVolume > maxVolume) {
            maxVolume = dayVolume;
          }
        }
      }
      return maxVolume;
    }
    function getMaxOrmForExerciseBeforeDate(exerciseName, dateKey) {
      const targetDate = parseDateKey(dateKey);
      let maxOrm = 0;
      for(const k of Object.keys(calendarData)) {
        const d = parseDateKey(k);
        if(d < targetDate) {
          const dayObj = calendarData[k];
          if(dayObj.hevyWorkouts) {
            dayObj.hevyWorkouts.forEach(workout => {
              workout.exercises.forEach(ex => {
                if(ex.title === exerciseName) {
                  ex.sets.forEach(s => {
                    const thisOrm = computeOrm(s.weight_kg, s.reps);
                    if(thisOrm > maxOrm) {
                      maxOrm = thisOrm;
                    }
                  });
                }
              });
            });
          }
        }
      }
      return maxOrm;
    }

    /*
      =======================================
      =       3) Calendar Rendering         =
      =======================================
    */
    function renderCalendar(year, month) {
      document.getElementById("monthLabel").textContent = `${monthNames[month]} ${year}`;
	  updateBackgroundForMonth(month);
      const calendar = document.getElementById("calendar");
      calendar.innerHTML = "";

      const headerEl = renderCalendarHeader();
      const gridEl = renderCalendarGrid(year, month);

      calendar.appendChild(headerEl);
      calendar.appendChild(gridEl);

      updateCounters();
      updatePopulateCalendarButtonState();
    }
    function renderCalendarHeader() {
      const headerGrid = document.createElement("div");
      headerGrid.classList.add("calendar-header");
      dayNames.forEach(d => {
        const hd = document.createElement("div");
        hd.textContent = d;
        headerGrid.appendChild(hd);
      });
      return headerGrid;
    }
    function renderCalendarGrid(year, month) {
      const grid = document.createElement("div");
      grid.classList.add("calendar-grid");

      const daysInMonth = new Date(year, month + 1, 0).getDate();
      const firstDay = new Date(year, month, 1);
      const startWeekday = firstDay.getDay();
      let rowIndex = 0, colIndex = 0;

      // Blank cells before the first day
      for(let i = 0; i < startWeekday; i++){
        grid.appendChild(blankCell(rowIndex, colIndex++));
      }

      // Days of the current month
      for(let dayNum = 1; dayNum <= daysInMonth; dayNum++){
        const dateObj = new Date(year, month, dayNum);
        const cell = renderDayCell(dateObj, dayNum);
        cell.setAttribute("data-row", rowIndex);
        cell.setAttribute("data-col", colIndex);
        grid.appendChild(cell);

        colIndex++;
        if(colIndex > 6){
          colIndex = 0;
          rowIndex++;
        }
      }

      // Fill remaining cells to make up to 6 rows (42 cells total)
      const totalCellsUsed = startWeekday + daysInMonth;
      const remainingCells = 42 - totalCellsUsed;
      for(let i = 0; i < remainingCells; i++){
        grid.appendChild(blankCell(rowIndex, colIndex++));
        if(colIndex > 6){
          colIndex = 0;
          rowIndex++;
        }
      }
      return grid;
    }
	
    function blankCell(row, col) {
      const blank = document.createElement("div");
      blank.classList.add("day-cell", "faded");
      blank.setAttribute("data-row", row);
      blank.setAttribute("data-col", col);
      return blank;
    }
	
	function renderDayCell(dateObj, dayNum) {
	  const dateKey = getDateKey(dateObj);
	  const dayData = getDayData(dateKey);

	  const cell = document.createElement("div");
	  cell.classList.add("day-cell");

	  // Modified color handling
	  if (dayData.shiftClass === "custom-color" && dayData.customColor) {
		cell.style.backgroundColor = dayData.customColor;
	  } else {
		cell.classList.add(dayData.shiftClass);
	  }

	  cell.setAttribute("data-date-key", dateKey);

	  if (isToday(dateObj)) cell.classList.add("today");
	  if (dayData.completed) cell.classList.add("completed");
	  if (selectedDates.has(dateKey)) cell.classList.add("selected");

	  // Date number
	  const dateDiv = document.createElement("div");
	  dateDiv.classList.add("date-num");
	  dateDiv.textContent = dayNum;
	  cell.appendChild(dateDiv);

	  // Free time
	  if (isToday(dateObj)) {
		if (isOffDayShift(dayData.shiftClass)) {
		  const currentFreeTime = computeCurrentDayFreeTimeFull();
		  appendFreeTime(cell, currentFreeTime, true);
		} else {
		  const freeTime = computeFreeTime(dateKey);
		  if (freeTime) appendFreeTime(cell, freeTime);
		}
	  } else {
		const freeTime = computeFreeTime(dateKey);
		if (freeTime) appendFreeTime(cell, freeTime);
	  }

	  // Refresh icon
	  const refreshDiv = document.createElement("div");
	  refreshDiv.classList.add("refresh-emoji");
	  refreshDiv.textContent = "‚ü≥";
	  refreshDiv.addEventListener("mousedown", e => e.stopPropagation());
	  refreshDiv.addEventListener("click", e => {
		e.stopPropagation();
		if (!selectedDates.has(dateKey)) {
		  selectedDates.clear();
		  selectedDates.add(dateKey);
		}
		openCustomizationPopup();
	  });
	  cell.appendChild(refreshDiv);

	  // Alerts
	  if (dayData.alert && dayData.alert.type && dayData.alert.type !== "None") {
		const color = alertColors[dayData.alert.type] || "#32CD32";
		const overlay = document.createElement("div");
		overlay.classList.add("alert-overlay");
		overlay.style.background = `linear-gradient(to bottom, ${color}CC, transparent 100%)`;
		cell.appendChild(overlay);

		const alertSpan = document.createElement("div");
		alertSpan.classList.add("alert-text");
		alertSpan.textContent = dayData.alert.text || "";
		cell.appendChild(alertSpan);
	  }

	  // Weight display
	  const weightDiv = document.createElement("div");
	  weightDiv.classList.add("weight-display");
	  if (dayData.weight && parseFloat(dayData.weight) > 0) {
		const arrow = getWeightArrow(dateKey);
		let arrowColor = "#FFF";
		if (arrow === "‚Üë") arrowColor = "#FF4444";
		if (arrow === "‚Üì") arrowColor = "#66CC66";

		const textSpan = `${dayData.weight}kg`;
		if (arrow) {
		  if (arrow === "‚Üë") {
			weightDiv.innerHTML = `<span style="font-size:120%; color:${arrowColor}; margin-right:0.3em;">${arrow}</span> ${textSpan}`;
			weightDiv.style.color = arrowColor;
		  } else {
			weightDiv.innerHTML = `${textSpan} <span style="font-size:120%; color:${arrowColor}; margin-left:0.3em;">${arrow}</span>`;
			weightDiv.style.color = arrowColor;
		  }
		} else {
		  weightDiv.textContent = textSpan;
		}
	  }
	  cell.appendChild(weightDiv);

	  // Shift time
	  const shiftTimeDiv = document.createElement("div");
	  shiftTimeDiv.classList.add("shift-time-text");
	  if (dayData.shiftClass === "al-bg") {
		shiftTimeDiv.textContent = "AL";
	  } else if (dayData.workTime && !isOffDayShift(dayData.shiftClass)) {
		shiftTimeDiv.textContent = dayData.workTime;
	  }
	  cell.appendChild(shiftTimeDiv);

	  // Workout info
	  const wDiv = document.createElement("div");
	  wDiv.classList.add("workout-info");
	  if (dayData.gym === "Rest") {
		wDiv.textContent = "üò¥";
		wDiv.style.opacity = "1.0";
	  } else if (dayData.gym === "None") {
		wDiv.textContent = "";
	  } else {
		wDiv.innerHTML = `${dayData.gym}: ${formatTimeForDisplay(dayData.gymTime || "")}`;
	  }
	  cell.appendChild(wDiv);

	  // Completed badge
	  const badgeDiv = document.createElement("div");
	  badgeDiv.classList.add("completed-badge");
	  if (dayData.completed) badgeDiv.classList.add("enabled");
	  badgeDiv.addEventListener("mousedown", e => e.stopPropagation());
	  badgeDiv.addEventListener("click", (e) => {
		e.stopPropagation();
		setDayData(dateKey, { completed: !dayData.completed });
		renderCalendar(currentYear, currentMonth);
	  });
	  badgeDiv.innerHTML = `
		<svg width="16" height="16" fill="none" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor">
		  <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" />
		</svg>
	  `;
	  cell.appendChild(badgeDiv);

	  return cell;
	}
    function appendFreeTime(cell, freeTimeValue, isTodayOffShift) {
      const freeTimeDiv = document.createElement("div");
      freeTimeDiv.classList.add("free-time-text");
      freeTimeDiv.textContent = freeTimeValue;
      if(isTodayOffShift) {
        freeTimeDiv.style.color = "gold";
        freeTimeDiv.style.opacity = "0.7";
      }
      cell.appendChild(freeTimeDiv);
    }

    /*
      =======================================
      =    4) Single vs Multi Popup Flow    =
      =======================================
    */
    function openCustomizationPopup() {
      if(selectedDates.size === 0){
        showCustomAlert("No days selected. Please select a cell first.");
        return;
      }
      if(selectedDates.size === 1){
        openSingleModal();
      } else {
        openMultiModal();
      }
    }

    // 4a) Single-Cell Modal
    let currentSingleDayKey = null;

    function populateWorkTimeSelect(selectId, selectedValue){
      const selectElem = document.getElementById(selectId);
      selectElem.innerHTML = "";
      Object.keys(workTimeColors).sort().forEach(time => {
        const option = document.createElement("option");
        option.value = time;
        option.textContent = time;
        option.style.backgroundColor = workTimeColors[time] || "#444";
        option.style.color = "#fff";
        if(time === selectedValue) { option.selected = true; }
        selectElem.appendChild(option);
      });
    }
    function updateSingleWorkTimeState(){
      const active = document.querySelector("#singleColorSwatchesContainer .swatch.active");
      if(active){
        const preset = active.id.replace("swatch-single-", "");
        document.getElementById("singleWorkTimeSelect").disabled =
          (preset === "off-bg" || preset === "al-bg");
      }
    }
	function openSingleModal() {
	  document.getElementById("singleOverlay").classList.add("active");
	  document.querySelectorAll("#singleColorSwatchesContainer .swatch").forEach(s => s.classList.remove("active"));

	  const [dKey] = [...selectedDates];
	  currentSingleDayKey = dKey;
	  const dayData = getDayData(dKey);

	  // Date
	  const dateObj = parseDateKey(currentSingleDayKey);
	  const formattedDate = `${dateObj.getDate()} ${monthNames[dateObj.getMonth()]}, ${dateObj.getFullYear()}`;
	  document.getElementById("singleModalDate").textContent = formattedDate;

	  // Shift Preset
	  document.querySelectorAll("#singleColorSwatchesContainer .swatch").forEach(swatch => {
		if(swatch.id === `swatch-single-${dayData.shiftClass}`){
		  swatch.classList.add("active");
		} else {
		  swatch.classList.remove("active");
		}
	  });
	  const preset = colorOptions.find(opt => opt.className === dayData.shiftClass);
	  document.getElementById("singleShiftLabelText").textContent = preset ? preset.label : "Custom Shift";

	  // Form values
	  document.getElementById("singleWorkoutTypeSelect").value = dayData.gym || "None";
	  document.getElementById("singleGymTimeInput").value = dayData.gymTime || "";
	  document.getElementById("singleWorkTimeSelect").value = dayData.workTime || ""; // Fixed
	  document.getElementById("singleWeightInput").value = dayData.weight || "";

	  if(isOffDayShift(dayData.shiftClass)) {
		document.getElementById("singleWorkTimeSelect").disabled = true;
	  } else {
		document.getElementById("singleWorkTimeSelect").disabled = false;
	  }

	  // Alerts
	  let alertVal = "None";
	  if(dayData.alert && dayData.alert.type && dayData.alert.type !== "None") {
		alertVal = dayData.alert.type;
	  }
	  document.getElementById("singleAlertTypeSelect").value = alertVal;
	  document.getElementById("singleAlertTextInput").value =
		(dayData.alert && dayData.alert.text) ? dayData.alert.text : "";

	  // Scroll to top
	  document.getElementById("singleModal").scrollTop = 0;
	}
	
    function closeSingleModal() {
      document.getElementById("singleOverlay").classList.remove("active");
    }
	function resetSingleField(fieldName) {
	  if(!currentSingleDayKey) return;
	  const defaultData = getDefaultDataForDate(currentSingleDayKey);
	  if(!defaultData) return;

	  if(fieldName === "shiftClass"){
		document.querySelectorAll("#singleColorSwatchesContainer .swatch").forEach(s => s.classList.remove("active"));
		const sw = document.getElementById("swatch-single-" + defaultData.shiftClass);
		if(sw) sw.classList.add("active");
		const preset = colorOptions.find(o => o.className === defaultData.shiftClass);
		document.getElementById("singleShiftLabelText").textContent = preset ? preset.label : "(none)";

		if(isOffDayShift(defaultData.shiftClass)) {
		  document.getElementById("singleWorkTimeSelect").disabled = true;
		} else {
		  document.getElementById("singleWorkTimeSelect").disabled = false;
		}
	  } else if(fieldName === "gym"){
		document.getElementById("singleWorkoutTypeSelect").value = defaultData.gym;
	  } else if(fieldName === "gymTime"){
		document.getElementById("singleGymTimeInput").value = defaultData.gymTime || "";
	  } else if(fieldName === "workTime"){
		document.getElementById("singleWorkTimeSelect").value = defaultData.workTime || "";
	  } else if(fieldName === "weight"){
		document.getElementById("singleWeightInput").value = defaultData.weight || "";
	  } else if(fieldName === "alertType"){
		if(defaultData.alert && defaultData.alert.type){
		  document.getElementById("singleAlertTypeSelect").value = defaultData.alert.type;
		} else {
		  document.getElementById("singleAlertTypeSelect").value = "None";
		}
	  } else if(fieldName === "alertText"){
		if(defaultData.alert && defaultData.alert.text){
		  document.getElementById("singleAlertTextInput").value = defaultData.alert.text;
		} else {
		  document.getElementById("singleAlertTextInput").value = "";
		}
	  }
	}
	function saveSingleModal() {
	  if(!currentSingleDayKey) return;
	  const updates = {};
	  const activeSwatch = document.querySelector("#singleColorSwatchesContainer .swatch.active");
	  
	  if(activeSwatch) {
		updates.shiftClass = activeSwatch.id.replace("swatch-single-", "");
	  }
	  
	  updates.gym = document.getElementById("singleWorkoutTypeSelect").value.trim();
	  
	  // Work time
	  updates.workTime = document.getElementById("singleWorkTimeSelect").value.trim();
	  if(updates.workTime) {
		if(!validateTimeHHMM(updates.workTime)) {
		  showCustomAlert("Invalid Work Time. Use HHMM format (e.g. 2100).");
		  return;
		}
	  }
	  
	  // Gym time
	  const newGymTime = document.getElementById("singleGymTimeInput").value.trim();
	  if(newGymTime) {
		if(!validateTimeHHMM(newGymTime)) {
		  showCustomAlert("Invalid Gym Time. Use HHMM format (e.g. 2100).");
		  return;
		}
		updates.gymTime = newGymTime;
	  } else {
		updates.gymTime = "";
	  }

	  // Preset color
	  if(activeSwatch && activeSwatch.id.includes('custom-')) {
		const preset = colorOptions.find(p => p.className === activeSwatch.id.replace("swatch-single-", ""));
		if(preset && preset.data) {
		  updates.presetColor = preset.data.color;
		}
	  }

	  // Weight
	  const weightVal = document.getElementById("singleWeightInput").value.trim();
	  if(weightVal) {
		let wf = parseFloat(weightVal);
		if(isNaN(wf) || wf <= 0) {
		  showCustomAlert("Invalid weight.");
		  return;
		}
		updates.weight = wf.toFixed(1);
	  } else {
		updates.weight = null;
	  }

	  // Alert
	  const alertType = document.getElementById("singleAlertTypeSelect").value;
	  const alertText = document.getElementById("singleAlertTextInput").value.trim();
	  if(alertType && alertType !== "None") {
		updates.alert = { type: alertType, text: alertText || "" };
	  } else {
		updates.alert = null;
	  }

	  setDayData(currentSingleDayKey, updates);
	  closeSingleModal();
	  renderCalendar(currentYear, currentMonth);

	  // Pulse highlight
	  setTimeout(() => {
		const cellElement = document.querySelector(`[data-date-key="${currentSingleDayKey}"]`);
		if(cellElement) {
		  cellElement.classList.add("cell-pulse");
		  cellElement.addEventListener("animationend", function handler() {
			cellElement.classList.remove("cell-pulse");
			cellElement.removeEventListener("animationend", handler);
		  });
		}
	  }, 100);
	}
    function revertSingleModal() {
      if(!currentSingleDayKey) return;
      const defaultData = getDefaultDataForDate(currentSingleDayKey);
      if(defaultData){
        setDayData(currentSingleDayKey, {
          shiftClass: defaultData.shiftClass,
          gym: defaultData.gym,
          gymTime: defaultData.gymTime || "",
          workTime: defaultData.workTime || "",
          completed: defaultData.completed || false,
          weight: defaultData.weight || null,
          alert: defaultData.alert || null,
          hevyWorkouts: defaultData.hevyWorkouts ? [...defaultData.hevyWorkouts] : []
        });
      }
      closeSingleModal();
      renderCalendar(currentYear, currentMonth);
    }

    // 4b) Multi-Cell Modal
    function openMultiModal() {
      document.getElementById("multiOverlay").classList.add("active");
      document.getElementById("multiKeySelect").value = "";
      document.getElementById("multiValueInput").value = "";
      document.getElementById("multiValueInput").placeholder = "";
      document.getElementById("multiShiftSwatchesRow").style.display = "none";
      document.getElementById("multiAlertTypeRow").style.display = "none";
      document.getElementById("multiWorkTimeRow").style.display = "none";
      document.getElementById("multiWorkoutTypeRow").style.display = "none";
      document.getElementById("multiAlertTypeSelect").value = "None";
      document.querySelectorAll("#multiColorSwatchesContainer .swatch").forEach(s => s.classList.remove("active"));
      document.getElementById("multiShiftLabelText").textContent = "(none)";
    }
    function closeMultiModal() {
      document.getElementById("multiOverlay").classList.remove("active");
    }
    function handleMultiKeyChange() {
      const key = document.getElementById("multiKeySelect").value;
      const valRow = document.getElementById("multiValueRow");
      const shiftRow = document.getElementById("multiShiftSwatchesRow");
      const alertRow = document.getElementById("multiAlertTypeRow");
      const workTimeRow = document.getElementById("multiWorkTimeRow");
      const workoutTypeRow = document.getElementById("multiWorkoutTypeRow");

      shiftRow.style.display = "none";
      valRow.style.display = "none";
      alertRow.style.display = "none";
      workTimeRow.style.display = "none";
      workoutTypeRow.style.display = "none";

      if(key === "shiftClass"){
        shiftRow.style.display = "flex";
      } else if(key === "alertType"){
        alertRow.style.display = "flex";
      } else if(key === "workTime"){
        workTimeRow.style.display = "flex";
        populateWorkTimeSelect("multiWorkTimeSelect", "");
      } else if(key === "gym"){
        workoutTypeRow.style.display = "flex";
      } else if(key){
        valRow.style.display = "flex";
        document.getElementById("multiValueInput").placeholder = multiPlaceholderMap[key] || "";
      }
    }
	function saveMultiModal() {
	  const key = document.getElementById("multiKeySelect").value;
	  if (!key) {
		showCustomAlert("Please select a key to change.");
		return;
	  }

	  let newValue;
	  if (key === "shiftClass") {
		const swatch = document.querySelector("#multiColorSwatchesContainer .swatch.active");
		if (!swatch) {
		  showCustomAlert("Please choose a shift preset.");
		  return;
		}
		newValue = swatch.id.replace("swatch-multi-", "");
		
		// Find preset data
		const preset = colorOptions.find(opt => opt.className === newValue);
		
		selectedDates.forEach(dKey => {
		  const updated = {
			shiftClass: newValue
		  };
		  
		  // Apply all preset data if available
		  if (preset && preset.data) {
			updated.workTime = preset.data.workTime || "";
			updated.gymTime = preset.data.gymTime || "";
			updated.gym = preset.data.gym || "None";
			updated.alert = preset.data.alert || null;
		  } else if (newValue === "off-bg" || newValue === "al-bg") {
			updated.workTime = "";
		  }
		  
		  setDayData(dKey, updated);
		});
	  } else {
		if (key === "alertType") {
		  newValue = document.getElementById("multiAlertTypeSelect").value;
		} else if (key === "workTime") {
		  newValue = document.getElementById("multiWorkTimeInput").value.trim();
		  if (newValue && !validateTimeHHMM(newValue)) {
			showCustomAlert("Invalid time. Use HHMM format (e.g. 0900).");
			return;
		  }
		} else if (key === "gym") {
		  newValue = document.getElementById("multiWorkoutTypeSelect").value;
		} else {
		  newValue = document.getElementById("multiValueInput").value.trim();
		}

		if (key === "gymTime" && newValue) {
		  if (!validateTimeHHMM(newValue)) {
			showCustomAlert("Invalid time. Use HHMM format (e.g. 0600).");
			return;
		  }
		}
		if (key === "weight") {
		  if (newValue) {
			let wf = parseFloat(newValue);
			if (isNaN(wf) || wf <= 0) {
			  showCustomAlert("Invalid weight.");
			  return;
			}
			newValue = wf.toFixed(1);
		  } else {
			newValue = null;
		  }
		}

		selectedDates.forEach(dKey => {
		  const updated = {};

		  if (key === "gym") {
			updated.gym = newValue || "";
		  } else if (key === "gymTime") {
			updated.gymTime = newValue || "";
		  } else if (key === "workTime") {
			updated.workTime = newValue || "";
		  } else if (key === "weight") {
			updated.weight = newValue ? newValue : null;
		  } else if (key === "alertType") {
			if (newValue === "None") {
			  updated.alert = null;
			} else {
			  updated.alert = { type: newValue, text: "" };
			}
		  } else if (key === "alertText") {
			if (newValue) {
			  if (calendarData[dKey].alert && calendarData[dKey].alert.type && calendarData[dKey].alert.type !== "None") {
				updated.alert = { type: calendarData[dKey].alert.type, text: newValue };
			  } else {
				updated.alert = { type: "Generic", text: newValue };
			  }
			} else {
			  updated.alert = null;
			}
		  }

		  setDayData(dKey, updated);
		});
	  }

	  closeMultiModal();
	  renderCalendar(currentYear, currentMonth);

	  setTimeout(() => {
		selectedDates.forEach(dKey => {
		  const cellElement = document.querySelector(`[data-date-key="${dKey}"]`);
		  if (cellElement) {
			cellElement.classList.add("cell-pulse");
			cellElement.addEventListener("animationend", function handler() {
			  cellElement.classList.remove("cell-pulse");
			  cellElement.removeEventListener("animationend", handler);
			});
		  }
		});
	  }, 100);
	}
    function revertMultiModal() {
      selectedDates.forEach(dKey => {
        const defaultData = getDefaultDataForDate(dKey);
        if(defaultData){
          setDayData(dKey, {
            shiftClass: defaultData.shiftClass,
            gym: defaultData.gym,
            gymTime: defaultData.gymTime || "",
            workTime: defaultData.workTime || "",
            completed: defaultData.completed || false,
            weight: defaultData.weight || null,
            alert: defaultData.alert || null,
            hevyWorkouts: defaultData.hevyWorkouts ? [...defaultData.hevyWorkouts] : []
          });
        }
      });
      closeMultiModal();
      renderCalendar(currentYear, currentMonth);
    }

    /*
      =======================================
      =          5) Counters (Stats)        =
      =======================================
    */
    function updateCounters() {
      let completedCount = 0;
      let earliestDateKey = null;

      Object.keys(calendarData).forEach(key => {
        const dayObj = calendarData[key];
        if(dayObj.completed && isTrainingDay(dayObj)){
          completedCount++;
          if(!earliestDateKey || key < earliestDateKey){
            earliestDateKey = key;
          }
        }
      });

      let daysTrained = 0;
      if(earliestDateKey){
        const earliestDate = parseDateKey(earliestDateKey);
        const nowLocal = new Date();
        // We'll only do day difference if earliest is <= now
        if(earliestDate <= nowLocal){
          let diff = nowLocal - earliestDate;
          let rawDays = Math.floor(diff / MS_IN_DAY);
          if(rawDays < 0) rawDays = 0;
          daysTrained = rawDays + 1;
        }
      }
      let percentage = 0;
      if(daysTrained > 0){
        percentage = (completedCount / daysTrained) * 100;
      }

      document.getElementById("sessionCounter").textContent = completedCount;
      document.getElementById("daysTrainedCounter").textContent = daysTrained;
      document.getElementById("percentageCounter").textContent = percentage.toFixed(2) + '%';
    }

    /*
      =======================================
      =         6) Navigation               =
      =======================================
    */
    function prevMonth() {
      currentMonth--;
      if(currentMonth < 0){
        currentMonth = 11;
        currentYear--;
      }
      if(currentYear < START_YEAR){
        currentYear = START_YEAR;
        currentMonth = 0;
      }
      selectedDates.clear();
      renderCalendar(currentYear, currentMonth);
    }
    function nextMonth() {
      currentMonth++;
      if(currentMonth > 11){
        currentMonth = 0;
        currentYear++;
      }
      if(currentYear > END_YEAR){
        currentYear = END_YEAR;
        currentMonth = 11;
      }
      selectedDates.clear();
      renderCalendar(currentYear, currentMonth);
    }

    /*
      =======================================
      =   7) Shift Preset & Color Swatches  =
      =======================================
    */
    const workTimeColors = {
      "0000": "#926E8E","0100": "#A47887","0200": "#B78381","0300": "#C8917A",
      "0400": "#DB9C73","0500": "#EDA76D","0600": "#FFAD66","0700": "#EEAE74",
      "0800": "#DEAF83","0900": "#D0A77D","1000": "#BDB2A0","1100": "#ACB3AE",
      "1200": "#9CB4BC","1300": "#8CB4CA","1400": "#7AB6D9","1500": "#76A7D1",
      "1600": "#7198C9","1700": "#6D8BC2","1800": "#697DBA","1900": "#627AA3",
      "2000": "#6060AA","2100": "#5C4EA2","2200": "#6E599B","2300": "#806395"
    };
    const alertColors = {
      "Generic": "#32CD32",
      "Birthday": "#FF69B4",
      "Work": "#1E90FF",
      "PublicHoliday": "#FFD700",
	  "Deadline": "#C41E3A",
	  "School": "#FF6600"
    };
    const presetWorkTimeMapping = {
      "morning-bg": "0600",
      "late-day-bg": "0900",
      "afternoon-bg": "1400",
      "evening-bg": "1900",
      "night-bg": "2100"
    };
    const multiPlaceholderMap = {
      shiftClass: "Use swatches below",
      gym: "Select Workout Type",
      gymTime: "HHMM e.g. 2100",
      workTime: "Choose work time",
      weight: "e.g. 88.0",
      alertType: "",
      alertText: "e.g. My special event"
    };

	function buildColorSwatches() {
	  function buildSet(containerId, prefix, labelTextId) {
		const container = document.getElementById(containerId);
		container.innerHTML = '';

		// Add base color options
		baseColorOptions.forEach(opt => {
		  const div = document.createElement("div");
		  div.id = `swatch-${prefix}-${opt.className}`;
		  div.className = `swatch ${opt.className}`;
		  div.title = opt.label;

		  div.addEventListener("mouseover", () => {
			document.getElementById(labelTextId).textContent = opt.label;
		  });

		  div.addEventListener("mouseout", () => {
			const activeSw = container.querySelector(".swatch.active");
			if (activeSw) {
			  const className = activeSw.id.replace(`swatch-${prefix}-`, "");
			  const found = colorOptions.find(o => o.className === className);
			  document.getElementById(labelTextId).textContent = found ? found.label : "(none)";
			} else {
			  document.getElementById(labelTextId).textContent = "(none)";
			}
		  });

		  div.addEventListener("click", () => {
			container.querySelectorAll(".swatch").forEach(s => s.classList.remove("active"));
			div.classList.add("active");

			// Handle delete button state
			if (prefix === "single") {
			  const deleteBtn = container.parentNode.querySelector(".delete-preset-emoji");
			  const className = div.id.replace("swatch-single-", "");
			  const preset = colorOptions.find(o => o.className === className);
			  
			  if (preset?.custom) {
				deleteBtn.style.opacity = "1";
				deleteBtn.style.pointerEvents = "auto";
			  } else {
				deleteBtn.style.opacity = "0.5";
				deleteBtn.style.pointerEvents = "none";
			  }
			}

			// Existing preset application logic
			if (prefix === "single") {
			  updateSingleWorkTimeState();
			  const className = div.id.replace("swatch-single-", "");
			  const preset = colorOptions.find(o => o.className === className);
			  
			  if (preset && preset.data) {
				document.getElementById("singleWorkTimeSelect").value = preset.data.workTime || "";
				document.getElementById("singleGymTimeInput").value = preset.data.gymTime || "";
				document.getElementById("singleWorkoutTypeSelect").value = preset.data.gym || "None";
				document.getElementById("singleAlertTypeSelect").value = preset.data.alert?.type || "None";
				document.getElementById("singleAlertTextInput").value = preset.data.alert?.text || "";
			  }
			}
		  });

		  container.appendChild(div);
		});

		// Add separator if custom presets exist
		if (customPresets.length > 0) {
		  const separator = document.createElement("div");
		  separator.className = "preset-separator";
		  container.appendChild(separator);
		}

		// Add custom presets
		customPresets.forEach(opt => {
		  const div = document.createElement("div");
		  div.id = `swatch-${prefix}-${opt.className}`;
		  div.className = `swatch ${opt.className}`;
		  div.title = opt.label;

		  div.addEventListener("mouseover", () => {
			document.getElementById(labelTextId).textContent = opt.label;
		  });

		  div.addEventListener("mouseout", () => {
			const activeSw = container.querySelector(".swatch.active");
			if (activeSw) {
			  const className = activeSw.id.replace(`swatch-${prefix}-`, "");
			  const found = colorOptions.find(o => o.className === className);
			  document.getElementById(labelTextId).textContent = found ? found.label : "(none)";
			} else {
			  document.getElementById(labelTextId).textContent = "(none)";
			}
		  });

		  div.addEventListener("click", () => {
			container.querySelectorAll(".swatch").forEach(s => s.classList.remove("active"));
			div.classList.add("active");

			// Handle delete button state
			if (prefix === "single") {
			  const deleteBtn = container.parentNode.querySelector(".delete-preset-emoji");
			  deleteBtn.style.opacity = "1";
			  deleteBtn.style.pointerEvents = "auto";
			}

			// Existing preset application logic
			if (prefix === "single") {
			  updateSingleWorkTimeState();
			  const className = div.id.replace("swatch-single-", "");
			  const preset = colorOptions.find(o => o.className === className);
			  
			  if (preset && preset.data) {
				document.getElementById("singleWorkTimeSelect").value = preset.data.workTime || "";
				document.getElementById("singleGymTimeInput").value = preset.data.gymTime || "";
				document.getElementById("singleWorkoutTypeSelect").value = preset.data.gym || "None";
				document.getElementById("singleAlertTypeSelect").value = preset.data.alert?.type || "None";
				document.getElementById("singleAlertTextInput").value = preset.data.alert?.text || "";
			  }
			}
		  });

		  container.appendChild(div);
		});

		// Add buttons only to single modal
		if (prefix === "single") {
		  const buttonContainer = document.createElement("div");
		  buttonContainer.style.cssText = `
			grid-column: 1 / -1;
			display: flex;
			gap: 0.5rem;
			justify-content: center;
			margin-top: 0.5rem;
		  `;

		  // Add Preset Button
		  const addBtn = document.createElement("div");
		  addBtn.className = "add-preset-emoji";
		  addBtn.innerHTML = `<span>‚ûï</span><span>Add Preset</span>`;
		  addBtn.style.cssText = `
			display: flex;
			align-items: center;
			gap: 0.5rem;
			padding: 0.75rem;
			border: 1px solid #444;
			border-radius: 6px;
			cursor: pointer;
			transition: all 0.2s;
			background: rgba(255, 255, 255, 0.05);
		  `;
		  addBtn.addEventListener("mouseenter", () => {
			addBtn.style.background = "rgba(255, 255, 255, 0.1)";
			addBtn.style.borderColor = "#666";
		  });
		  addBtn.addEventListener("mouseleave", () => {
			addBtn.style.background = "rgba(255, 255, 255, 0.05)";
			addBtn.style.borderColor = "#444";
		  });
		  addBtn.addEventListener("click", addNewPreset);

		  // Delete Preset Button
		  const deleteBtn = document.createElement("div");
		  deleteBtn.className = "delete-preset-emoji";
		  deleteBtn.innerHTML = `<span>üóëÔ∏è</span><span>Delete Preset</span>`;
		  deleteBtn.style.cssText = `
			display: flex;
			align-items: center;
			gap: 0.5rem;
			padding: 0.75rem;
			border: 1px solid #444;
			border-radius: 6px;
			cursor: pointer;
			transition: all 0.2s;
			background: rgba(255, 255, 255, 0.05);
			opacity: 0.5;
			pointer-events: none;
		  `;
		  deleteBtn.addEventListener("mouseenter", () => {
			if (deleteBtn.style.pointerEvents !== "none") {
			  deleteBtn.style.background = "rgba(255, 255, 255, 0.1)";
			  deleteBtn.style.borderColor = "#666";
			}
		  });
		  deleteBtn.addEventListener("mouseleave", () => {
			deleteBtn.style.background = "rgba(255, 255, 255, 0.05)";
			deleteBtn.style.borderColor = "#444";
		  });
		  deleteBtn.addEventListener("click", handleDeletePreset);

		  buttonContainer.appendChild(addBtn);
		  buttonContainer.appendChild(deleteBtn);
		  container.appendChild(buttonContainer);
		}
	  }

	  buildSet("singleColorSwatchesContainer", "single", "singleShiftLabelText");
	  buildSet("multiColorSwatchesContainer", "multi", "multiShiftLabelText");
	}
	
	function handleDeletePreset() {
	  const activeSwatch = document.querySelector("#singleColorSwatchesContainer .swatch.active");
	  if (!activeSwatch) return;

	  const className = activeSwatch.id.replace("swatch-single-", "");
	  const preset = customPresets.find(p => p.className === className);
	  
	  if (preset) {
		showCustomConfirm(`Delete preset "${preset.label}"?`, () => {
		  // Store color before deletion
		  const deletedColor = preset.data.color;
		  
		  // Update all cells using this preset
		  Object.keys(calendarData).forEach(dateKey => {
			if (calendarData[dateKey].shiftClass === className) {
			  calendarData[dateKey].shiftClass = "custom-color";
			  calendarData[dateKey].customColor = deletedColor; // Add new field
			}
		  });

		  // Remove from presets
		  customPresets = customPresets.filter(p => p.className !== className);
		  localStorage.setItem(LS_PRESETS_KEY, JSON.stringify(customPresets));
		  
		  // Remove associated CSS
		  document.querySelector(`style[data-preset="${className}"]`)?.remove();
		  
		  // Update UI
		  colorOptions = [...baseColorOptions, ...customPresets];
		  buildColorSwatches();
		  renderCalendar(currentYear, currentMonth); // Refresh calendar
		  showCustomAlert("Preset deleted successfully");
		});
	  }
	}

    /*
      =======================================
      =   8) Data Backup (Load/Save JSON)   =
      =======================================
    */
	function saveData() {
	  const dataToSave = {
		calendarData: calendarData,
		defaultCycle: defaultCycleData,
		customPresets: customPresets
	  };
	  const dataStr = JSON.stringify(dataToSave, null, 2);
	  const blob = new Blob([dataStr], { type: "application/json" });
	  const url = URL.createObjectURL(blob);
	  const a = document.createElement("a");
	  a.href = url;
	  a.download = 'calendar-data-backup.json';
	  a.click();
	  URL.revokeObjectURL(url);
	}
	function loadData(file) {
	  const reader = new FileReader();
	  reader.onload = (e) => {
		try {
		  const importedData = JSON.parse(e.target.result);
		  if(!importedData || typeof importedData !== 'object') {
			showCustomAlert("Invalid JSON data.");
			return;
		  }
		  if(!importedData.calendarData || typeof importedData.calendarData !== 'object') {
			showCustomAlert("Invalid or missing calendarData in JSON.");
			return;
		  }
		  
		  calendarData = importedData.calendarData;
		  localStorage.setItem(LS_CALENDAR_DATA_KEY, JSON.stringify(calendarData));

		  if(importedData.defaultCycle && typeof importedData.defaultCycle === 'object') {
			defaultCycleData = importedData.defaultCycle;
			localStorage.setItem(LS_DEFAULT_CYCLE_KEY, JSON.stringify(defaultCycleData));
		  } else {
			defaultCycleData = {
			  pattern: [],
			  startDate: null
			};
			localStorage.setItem(LS_DEFAULT_CYCLE_KEY, JSON.stringify(defaultCycleData));
		  }

		  if(importedData.customPresets) {
			customPresets = importedData.customPresets;
			localStorage.setItem(LS_PRESETS_KEY, JSON.stringify(customPresets));
			colorOptions = [...baseColorOptions, ...customPresets];
			
			// Add CSS for custom preset colors
			customPresets.forEach(preset => {
			  if(preset.data && preset.data.color) {
				const style = document.createElement('style');
				style.textContent = `.${preset.className} { background-color: ${preset.data.color}; }`;
				document.head.appendChild(style);
			  }
			});
			
			buildColorSwatches();
		  }

		  selectedDates.clear();
		  renderCalendar(currentYear, currentMonth);
		  updateCounters();
		  showCustomAlert("Data loaded successfully!");
		} catch(err) {
		  showCustomAlert("Failed to parse JSON file. Please ensure it's valid.");
		}
	  };
	  reader.readAsText(file);
	}

    /*
      =======================================
      =    9) Import Hevy Data from API     =
      =======================================
    */
	async function importHevyData(userApiKey) {
	  try {
		document.getElementById("loadingOverlay").classList.add("active");

		// Get total workout count
		const countResponse = await fetch("https://api.hevyapp.com/v1/workouts/count", {
		  method: "GET",
		  headers: {
			"accept": "application/json",
			"api-key": userApiKey
		  }
		});
		if (!countResponse.ok) throw new Error("Failed to fetch workout count.");
		const countData = await countResponse.json();
		const totalWorkouts = countData.workout_count;

		const pageSize = 10;
		const totalPages = Math.ceil(totalWorkouts / pageSize);
		let allWorkouts = [];

		// Fetch all workouts page by page
		for (let page = 1; page <= totalPages; page++) {
		  const response = await fetch(`https://api.hevyapp.com/v1/workouts?page=${page}&pageSize=${pageSize}`, {
			method: "GET",
			headers: {
			  "accept": "application/json",
			  "api-key": userApiKey
			}
		  });
		  if (!response.ok) throw new Error("Failed to fetch workouts page " + page);
		  const data = await response.json();
		  if (data.workouts && Array.isArray(data.workouts)) {
			allWorkouts = allWorkouts.concat(data.workouts);
		  }
		}

		let importedCount = 0;
		let updatedCount = 0;

		allWorkouts.forEach(workout => {
		  let dateKey = null;

		  // If workout title is in dd/mm/yyyy format, try to parse
		  if (workout.title && /^(\d{1,2})\/(\d{1,2})\/(\d{4})$/.test(workout.title)) {
			const parts = workout.title.split("/");
			const dayNum = parseInt(parts[0], 10);
			const monthNum = parseInt(parts[1], 10);
			const yearNum = parseInt(parts[2], 10);
			if(yearNum >= START_YEAR && yearNum <= END_YEAR){
			  dateKey = `${yearNum}-${String(monthNum).padStart(2, "0")}-${String(dayNum).padStart(2,"0")}`;
			}
		  }

		  // If title format was off, fall back to the actual start_time
		  if(!dateKey && workout.start_time){
			const startTime = new Date(workout.start_time);
			const y = startTime.getFullYear();
			if(y >= START_YEAR && y <= END_YEAR){
			  dateKey = getDateKey(startTime);
			}
		  }

		  if(dateKey) {
			const dayData = getDayData(dateKey);
			if (!dayData.hevyWorkouts) {
			  dayData.hevyWorkouts = [];
			}

			// Check if workout already exists
			const existingWorkoutIndex = dayData.hevyWorkouts.findIndex(existing => existing.id === workout.id);
			
			if (existingWorkoutIndex === -1) {
			  // New workout - add it
			  dayData.hevyWorkouts.push(workout);
			  dayData.completed = true;
			  importedCount++;
			} else {
			  // Workout exists - check if it was updated
			  const existingWorkout = dayData.hevyWorkouts[existingWorkoutIndex];
			  const existingUpdateTime = new Date(existingWorkout.updated_at).getTime();
			  const newUpdateTime = new Date(workout.updated_at).getTime();
			  
			  if (newUpdateTime > existingUpdateTime) {
				// Workout was updated - replace it
				dayData.hevyWorkouts[existingWorkoutIndex] = workout;
				updatedCount++;
			  }
			}
			
			setDayData(dateKey, dayData);
		  }
		});

		fixNullWeights();

		let message = `Imported ${importedCount} new Hevy workouts`;
		if (updatedCount > 0) {
		  message += ` and updated ${updatedCount} existing workouts`;
		}
		message += " into calendar.";
		
		showCustomAlert(message);
		renderCalendar(currentYear, currentMonth);
	  } catch(err) {
		console.error(err);
		showCustomAlert("An error occurred while importing Hevy data: " + err.message);
	  } finally {
		document.getElementById("loadingOverlay").classList.remove("active");
	  }
	}

    /*
      =======================================
      = 10) Stats Modal & 'WeightChart'      =
      =======================================
    */
    function openStatsModal() {
      document.getElementById("statsOverlay").classList.add("active");
      buildWeightChart();
    }
    function closeStatsModal() {
      document.getElementById("statsOverlay").classList.remove("active");
      if(weightChart){
        weightChart.destroy();
        weightChart = null;
      }
    }
    function buildWeightChart(){
      // Gather all date keys that have a valid weight
      const weightKeys = Object.keys(calendarData)
        .filter(k => calendarData[k].weight && parseFloat(calendarData[k].weight) > 0)
        .sort();
      if(weightKeys.length < 1){
        if(weightChart){
          weightChart.destroy();
          weightChart = null;
        }
        return;
      }
      const dataPoints = weightKeys.map(k => ({ x: k, y: parseFloat(calendarData[k].weight) }));
      const labels = weightKeys.map(k => {
        const d = parseDateKey(k);
        return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
      });
      const weights = dataPoints.map(dp => dp.y);
      const minWeight = Math.min(...weights);
      const maxWeight = Math.max(...weights);
      const suggestedMin = Math.max(0, minWeight - 1);
      const suggestedMax = maxWeight + 1;

      if(weightChart){
        weightChart.destroy();
        weightChart = null;
      }
      const ctx = document.getElementById('weightChart').getContext('2d');

      // We highlight "today" if it's in data
      const todayKey = getDateKey(new Date());
      const { bgColors, borderColors, pointRadii } = buildHighlightArrays(
        dataPoints, todayKey, '#4DAAFF', '#FFDD77', 2.5, 5
      );

      weightChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Weight (kg)',
            data: dataPoints.map(dp => dp.y),
            borderColor: '#4DAAFF',
            backgroundColor: 'rgba(77, 169, 255,0.2)',
            fill: true,
            tension: 0.1,
            pointRadius: pointRadii,
            pointBackgroundColor: bgColors,
            pointBorderColor: borderColors,
            pointHoverRadius: 6
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: { 
              title: { display: true, text: 'Date' }, 
              ticks: { color: '#ccc' }, 
              grid: { color: '#555' }
            },
            y: { 
              suggestedMin, 
              suggestedMax, 
              title: { display: true, text: 'Weight (kg)' }, 
              ticks: { color: '#ccc' }, 
              grid: { color: '#555' } 
            }
          },
          plugins: {
            legend: { labels: { color: '#eee' } }
          }
        }
      });
    }
    function buildHighlightArrays(dataPoints, highlightDateKey, normalColor, highlightColor, normalRadius=4, highlightRadius=6) {
      const bgColors = [];
      const borderColors = [];
      const pointRadii = [];

      dataPoints.forEach(dp => {
        if(dp.x === highlightDateKey) {
          bgColors.push(highlightColor);
          borderColors.push("#fff");
          pointRadii.push(highlightRadius);
        } else {
          bgColors.push(normalColor);
          borderColors.push(normalColor);
          pointRadii.push(normalRadius);
        }
      });

      return { bgColors, borderColors, pointRadii };
    }

    /*
      =======================================
      = 11) Hevy Workout Summary Modal       =
      =======================================
    */
	function openHevyModal(dateKey) {
	  openModalOnTop("hevyOverlay");

	  const dateObj = parseDateKey(dateKey);
	  const formattedDate = `${dateObj.getDate()} ${monthNames[dateObj.getMonth()]}, ${dateObj.getFullYear()}`;

	  const dayData = getDayData(dateKey);
	  const container = document.getElementById("hevyModalWorkoutDetails");
	  const modalEl = document.getElementById("hevyModal");

	  // Remove .no-workout if it was set
	  modalEl.classList.remove("no-workout");

	  // Title + subtitle
	  document.querySelector("#hevyModal h2").textContent = "Workout Summary";
	  let subtitleDiv = document.querySelector("#hevyModal .modal-subtitle");
	  if (!subtitleDiv) {
		subtitleDiv = document.createElement("div");
		subtitleDiv.className = "modal-subtitle";
		const h2 = document.querySelector("#hevyModal h2");
		h2.parentNode.insertBefore(subtitleDiv, h2.nextSibling);
	  }
	  subtitleDiv.textContent = formattedDate;

	  // If no workouts
	  if (!dayData.hevyWorkouts || dayData.hevyWorkouts.length === 0) {
		modalEl.classList.add("no-workout");
		container.innerHTML = "<p>No Hevy workout data for this day.</p>";
		return;
	  }

	  renderHevyWorkoutsToContainer(dayData.hevyWorkouts, "hevyModalWorkoutDetails", dateKey);

	  modalEl.scrollTop = 0;
	  container.scrollTop = 0;
	}
	function closeHevyModal() {
	  document.getElementById("hevyOverlay").classList.remove("active");
	  destroyHevyProgressChart();  // or your existing chart logic
	}
    function destroyHevyProgressChart() {
      if(hevyProgressChart) {
        hevyProgressChart.destroy();
        hevyProgressChart = null;
      }
    }

    /*
      ================================================
      = 12) Rendering Hevy Workouts + PR Logic       =
      ================================================
    */
	function renderHevyWorkoutsToContainer(workouts, containerId, dateKey) {
	  const container = document.getElementById(containerId);
	  if (!workouts || workouts.length === 0) {
		container.innerHTML = "<p>No Hevy workout data for this day.</p>";
		return;
	  }

	  let html = "";

	  workouts.forEach(workout => {
		html += `<div class="hevy-workout">`;
		// Workout Title
		html += `<div class="hevy-workout-title">${escapeHtml(workout.title)}</div>`;

		// For each exercise in this workout
		workout.exercises.forEach(exercise => {
		  const template = getExerciseTemplate(exercise.title);
		  const exerciseType = template ? template.type : 'weighted_reps';

		  html += `<div class="hevy-exercise">`;
		  // Clickable Exercise Title
		  html += `
			<div class="hevy-exercise-title"
				 style="cursor:pointer;"
				 data-exercise="${escapeHtml(exercise.title)}">
			  ${escapeHtml(exercise.title)}
			</div>
		  `;

		  // Container for sets
		  html += `<div class="hevy-sets">`;

		  // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
		  //  DURATION EXERCISES
		  // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
		  if (exerciseType === 'duration') {
			let totalDuration = 0;

			exercise.sets.forEach((set, i) => {
			  const prInfo = getSetPRInfo(set, exercise.title, dateKey, workout.id, i);
			  let setClasses = "hevy-set";
			  let prLabelHtml = "";
			  if (prInfo.isPR) {
				setClasses += " pr-border";
				prLabelHtml = `<div class="pr-labels">`;
				prInfo.labels.forEach(label => {
				  prLabelHtml += `<div class="pr-text smaller-pr">${label}</div>`;
				});
				prLabelHtml += `</div>`;
			  }
			  const starHtml = prInfo.isPR ? buildStarsContainer() : "";
			  totalDuration += set.duration_seconds;

			  html += `
				<div class="${setClasses}"
					 data-exercise="${escapeHtml(exercise.title)}"
					 data-duration="${set.duration_seconds}"
					 data-date-key="${dateKey}">
				  ${formatDuration(set.duration_seconds)}
				  ${starHtml}
				  ${prLabelHtml}
				</div>
			  `;
			});

			// Close .hevy-sets
			html += `</div>`;

			// Show total duration
			html += `
			  <div class="hevy-exercise-volume"
				   data-exercise="${escapeHtml(exercise.title)}"
				   data-date-key="${dateKey}"
				   style="cursor: pointer;">
				Total Duration: ${formatDuration(totalDuration)}
			  </div>
			`;

		  // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
		  //  DISTANCE_DURATION EXERCISES
		  // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
		  } else if (exerciseType === 'distance_duration') {
			let totalDistance = 0;
			let totalDuration = 0;

			exercise.sets.forEach((set, i) => {
			  const prInfo = getSetPRInfo(set, exercise.title, dateKey, workout.id, i);
			  let setClasses = "hevy-set";
			  let prLabelHtml = "";
			  if (prInfo.isPR) {
				setClasses += " pr-border";
				prLabelHtml = `<div class="pr-labels">`;
				prInfo.labels.forEach(label => {
				  prLabelHtml += `<div class="pr-text smaller-pr">${label}</div>`;
				});
				prLabelHtml += `</div>`;
			  }
			  const starHtml = prInfo.isPR ? buildStarsContainer() : "";
			  totalDistance += set.distance_meters;
			  totalDuration += set.duration_seconds;
			  const pace = formatPace(set.distance_meters, set.duration_seconds);
			  html += `
				<div class="${setClasses}"
					 data-exercise="${escapeHtml(exercise.title)}"
					 data-distance="${set.distance_meters}"
					 data-duration="${set.duration_seconds}"
					 data-date-key="${dateKey}">
				  ${(set.distance_meters / 1000).toFixed(2)}km
				  <span style="color: #888;">in</span>
				  ${formatDuration(set.duration_seconds)}
				  <div style="font-size: 0.8em; color: #888; margin-top: 4px;">
					${pace}/km
				  </div>
				  ${starHtml}
				  ${prLabelHtml}
				</div>
			  `;
			});

			// Close .hevy-sets
			html += `</div>`;

			// Show total distance + total duration lines
			html += `
			  <div class="hevy-exercise-volume"
				   data-exercise="${escapeHtml(exercise.title)}"
				   data-date-key="${dateKey}"
				   style="cursor: pointer;">
				Total Distance: ${(totalDistance / 1000).toFixed(2)}km
			  </div>
			  <div class="hevy-orm"
				   data-exercise="${escapeHtml(exercise.title)}"
				   data-date-key="${dateKey}"
				   style="cursor: pointer;">
				Total Duration: ${formatDuration(totalDuration)}
			  </div>
			`;

		  // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
		  // WEIGHTED_REPS EXERCISES (Normal weighted_reps and bodyweight types)
		  // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
		  } else {
			let totalWeight = 0;
			exercise.sets.forEach((set, i) => {
			  let setClasses = "hevy-set";
			  let prLabelHtml = "";

			  const prInfo = getSetPRInfo(set, exercise.title, dateKey, workout.id, i);
			  if (prInfo.isPR) {
				setClasses += " pr-border";
				prLabelHtml = `<div class="pr-labels">`;
				prInfo.labels.forEach(label => {
				  prLabelHtml += `<div class="pr-text smaller-pr">${label}</div>`;
				});
				prLabelHtml += `</div>`;
			  }
			  const starHtml = prInfo.isPR ? buildStarsContainer() : "";

			  // Compute effective weight:
			  // For normal weighted_reps, effectiveWeight is simply set.weight_kg.
			  // For bodyweight_weighted or bodyweight_assisted, retrieve the day's bodyweight
			  // (from getDayData(dateKey).weight or findNearestWeight(dateKey)) and then add or subtract.
			  let effectiveWeight = set.weight_kg;
			  if (template && (template.type === 'bodyweight_weighted' || template.type === 'bodyweight_assisted' || template.type === 'reps_only')) {
				const dayData = getDayData(dateKey);
				// Ensure numeric conversion for both the bodyweight and extra weight.
				const bodyweight = parseFloat(dayData.weight) || parseFloat(findNearestWeight(dateKey)) || 0;
				const extra = parseFloat(set.weight_kg) || 0;
				if (template.type === 'bodyweight_weighted') {
				  effectiveWeight = bodyweight + extra;
				} else if (template.type === 'bodyweight_assisted') {
				  effectiveWeight = bodyweight - extra;
				} else {
				  effectiveWeight = bodyweight;
				}
			  }

			  html += `
				<div class="${setClasses}"
					 data-exercise="${escapeHtml(exercise.title)}"
					 data-reps="${set.reps}"
					 data-weight="${effectiveWeight}"
					 data-date-key="${dateKey}">
				  <span class="hevy-set-weight">${effectiveWeight}kg</span>
				  x
				  <span class="hevy-set-reps">${set.reps}</span>
				  ${starHtml}
				  ${prLabelHtml}
				</div>
			  `;
			  totalWeight += (effectiveWeight * set.reps);
			});
			html += `</div>`;

			// Weighted: Volume & 1RM lines
			html += `
			  <div class="hevy-exercise-volume"
				   data-exercise="${escapeHtml(exercise.title)}"
				   data-date-key="${dateKey}">
				Volume: ${totalWeight.toLocaleString()}kg
			  </div>
			`;

			let highestOrm = 0;
			exercise.sets.forEach(s => {
			  let effW = s.weight_kg;
			  if (template && (template.type === 'bodyweight_weighted' || template.type === 'bodyweight_assisted' || template.type === 'reps_only')) {
				const dayData = getDayData(dateKey);
				// Ensure numeric conversion for both the bodyweight and extra weight.
				const bodyweight = parseFloat(dayData.weight) || parseFloat(findNearestWeight(dateKey)) || 0;
				const extra = parseFloat(s.weight_kg) || 0;
				if (template.type === 'bodyweight_weighted') {
				  effW = bodyweight + extra;
				} else if (template.type === 'bodyweight_assisted') {
				  effW = bodyweight - extra;
				} else {
				  effW = bodyweight;
				}
			  }
			  if (effW && s.reps) {
				const thisOrm = computeOrm(effW, s.reps);
				if (thisOrm > highestOrm) highestOrm = thisOrm;
			  }
			});
			html += `
			  <div class="hevy-orm"
				   data-exercise="${escapeHtml(exercise.title)}"
				   data-date-key="${dateKey}">
				One Rep Max: ${highestOrm > 0 ? highestOrm.toFixed(1) + 'kg' : 'N/A'}
			  </div>
			`;
		  }

		  html += `</div>`; // close .hevy-exercise
		});

		// Optionally show total volume across entire workout (for weighted sets)
		let workoutVolume = 0;
		workout.exercises.forEach(ex => {
		  const exTemplate = getExerciseTemplate(ex.title);
		  if (exTemplate && exTemplate.type !== 'distance_duration' && exTemplate.type !== 'duration') {
			ex.sets.forEach(s => {
			  let effW = s.weight_kg;
			  if (exTemplate.type === 'bodyweight_weighted' || exTemplate.type === 'bodyweight_assisted') {
				const dayData = getDayData(dateKey);
				const bodyweight = parseFloat(dayData.weight) || parseFloat(findNearestWeight(dateKey)) || 0;
				const extra = parseFloat(s.weight_kg) || 0;
				if (exTemplate.type === 'bodyweight_weighted') {
				  effW = bodyweight + extra;
				} else {
				  effW = bodyweight - extra;
				}
			  }
			  workoutVolume += (effW * s.reps);
			});
		  }
		});
		if (workoutVolume > 0) {
		  html += `
			<div class="hevy-total" data-date-key="${dateKey}">
			  Total Volume: ${workoutVolume.toLocaleString()}kg
			</div>
		  `;
		}

		html += `</div>`; // close .hevy-workout
	  });

	  container.innerHTML = html;
	  setupWorkoutContainerHandlers(container);
	}
	
	function buildStarsContainer() {
		  // Single star path
		  const starSVG = `
			<svg viewBox="0 0 784.11 815.53">
			  <path 
				d="M392.05 0c-20.9,210.08 -184.06,378.41 
						  -392.05,407.78 207.96,29.37 371.12,197.68 392.05,407.74
						  20.93,-210.06 184.09,-378.37 392.05,-407.74
						  -207.98,-29.38 -371.16,-197.69 -392.06,-407.78z"
				class="fil0"/>
			</svg>
		  `;
		  
		  let html = `<div class="stars-container">`;
		  for (let i = 1; i <= 10; i++) {
			html += `
			  <div class="star-${i}">
				${starSVG}
			  </div>
			`;
		  }
		  html += `</div>`;
		  return html;
	}
	
	function getGlobalPRsForExercise(exerciseName) {
	  let weightPR = null;  // record for highest effective weight (with tie-breaker on reps)
	  let volumePR = null;
	  let ormPR = null;
	  const allWorkouts = [];

	  // Gather all workouts that include the exercise.
	  Object.keys(calendarData).forEach(dateKey => {
		const dayObj = calendarData[dateKey];
		if (dayObj.hevyWorkouts) {
		  dayObj.hevyWorkouts.forEach(workout => {
			workout.exercises.forEach(ex => {
			  if (ex.title === exerciseName) {
				allWorkouts.push({
				  dateKey,
				  workout,
				  exercise: ex,
				  date: new Date(workout.start_time)
				});
			  }
			});
		  });
		}
	  });
	  allWorkouts.sort((a, b) => a.date - b.date);

	  // Get the template to check the exercise type.
	  const template = getExerciseTemplate(exerciseName);

	  allWorkouts.forEach(({ dateKey, workout, exercise, date }) => {
		exercise.sets.forEach((set, i) => {
		  const reps = set.reps;
		  // Default: effectiveWeight equals the stored weight_kg.
		  let effectiveWeight = parseFloat(set.weight_kg);
		  if (template && (template.type === 'bodyweight_weighted' || template.type === 'bodyweight_assisted' || template.type === 'reps_only')) {
				const dayData = getDayData(dateKey);
				// Ensure numeric conversion for both the bodyweight and extra weight.
				const bodyweight = parseFloat(dayData.weight) || parseFloat(findNearestWeight(dateKey)) || 0;
				const extra = parseFloat(set.weight_kg) || 0;
				if (template.type === 'bodyweight_weighted') {
				  effectiveWeight = bodyweight + extra;
				} else if (template.type === 'bodyweight_assisted') {
				  effectiveWeight = bodyweight - extra;
				} else {
				  effectiveWeight = bodyweight;
				}
			  }
		  const setVolume = effectiveWeight * reps;
		  const setOrm = computeOrm(effectiveWeight, reps);
		  const record = {
			dateKey,
			workoutId: workout.id,
			setIndex: i,
			weight: effectiveWeight,
			reps,
			volume: setVolume,
			orm: setOrm,
			date
		  };

		  if (!weightPR || (effectiveWeight > weightPR.weight) || 
			  (effectiveWeight === weightPR.weight && reps > weightPR.reps)) {
			weightPR = record;
		  }
		  if (!volumePR || setVolume > volumePR.volume) {
			volumePR = record;
		  }
		  if (!ormPR || setOrm > ormPR.orm) {
			ormPR = record;
		  }
		});
	  });
	  return { weightPR, volumePR, ormPR };
	}


    /*
      ================================================
      = 13) Unified Weight & Rep Progress Modal      =
      ================================================
    */
	let currentProgressionExercise = null;
	let currentProgressionWeight = null;
	let currentProgressionReps = null;
	let currentProgressionDateKey = null;
	let currentExerciseVolumeName = null;
	let currentExerciseVolumeDateKey = null;
	
    function destroyExerciseWeightProgressChart() {
      if(exerciseWeightProgressionChart) {
        exerciseWeightProgressionChart.destroy();
        exerciseWeightProgressionChart = null;
      }
    }
    function destroyExerciseRepProgressChart() {
      if(exerciseRepProgressionChart) {
        exerciseRepProgressionChart.destroy();
        exerciseRepProgressionChart = null;
      }
    }

	function openExerciseProgressionModal(exerciseName, weight, reps, dateKey) {
	  openModalOnTop("exerciseProgressOverlay");
	  
	  // Update modal title based on exercise type
	  const template = getExerciseTemplate(exerciseName);
	  const exerciseType = template ? template.type : 'weighted_reps';
	  const modalTitle = document.getElementById("exerciseProgressionModal").querySelector("h2");
	  
	  if (exerciseType === 'distance_duration') {
		modalTitle.textContent = "Exercise: Distance & Pace Progression";
	  } else {
		modalTitle.textContent = "Exercise: Weight & Rep Progression";
	  }
	  
	  const dateObj = parseDateKey(dateKey);
	  const dateLabel = `${dateObj.getDate()} ${monthNames[dateObj.getMonth()]}, ${dateObj.getFullYear()}`;
	  document.getElementById("exerciseProgressionModalDate").textContent = dateLabel;

	  currentProgressionExercise = exerciseName;
	  currentProgressionWeight = weight;
	  currentProgressionReps = reps;
	  currentProgressionDateKey = dateKey;

	  buildExerciseWeightProgressChart(exerciseName, reps, dateKey);
	  buildExerciseRepProgressChart(exerciseName, weight, dateKey);
	}
	
    function closeExerciseProgressModal() {
      document.getElementById("exerciseProgressOverlay").classList.remove("active");
      destroyExerciseWeightProgressChart();
      destroyExerciseRepProgressChart();
    }

    // Weight progression at a fixed rep count
    function buildExerciseWeightProgressChart(exerciseName, repCount, highlightDateKey) {
	  // Determine the active date range from the progression modal‚Äôs date-range buttons.
	  const selectedRange = document.querySelector('#exerciseProgressionModal .date-range-btn.active').getAttribute('data-range');
	  const refDate = parseDateKey(highlightDateKey);
	  const { start, end } = getDateRangeBounds(selectedRange, refDate);

	  // Get all date keys in the range
	  const dateKeys = Object.keys(calendarData)
		.filter(key => {
		   const d = parseDateKey(key);
		   return d >= start && d <= end;
		})
		.sort();

	  const dataMap = {};
	  const template = getExerciseTemplate(exerciseName);

	  // For each day in the range, find the best (highest) effective weight among sets with rep count equal to repCount.
	  dateKeys.forEach(k => {
		const dayObj = calendarData[k];
		if (!dayObj.hevyWorkouts) return;
		let bestWeightForDay = 0;
		dayObj.hevyWorkouts.forEach(workout => {
		  workout.exercises.forEach(ex => {
			if (ex.title === exerciseName) {
			  ex.sets.forEach(set => {
				if (set.reps === repCount) {
				  let effW = parseFloat(set.weight_kg);
				  if (template && (template.type === 'bodyweight_weighted' || template.type === 'bodyweight_assisted' || template.type === 'reps_only')) {
				const dayData = getDayData(k);
				// Ensure numeric conversion for both the bodyweight and extra weight.
				const bodyweight = parseFloat(dayData.weight) || parseFloat(findNearestWeight(k)) || 0;
				const extra = parseFloat(set.weight_kg) || 0;
				if (template.type === 'bodyweight_weighted') {
				  effW = bodyweight + extra;
				} else if (template.type === 'bodyweight_assisted') {
				  effW = bodyweight - extra;
				} else {
				  effW = bodyweight;
				}
			  }
				  if (effW > bestWeightForDay) {
					bestWeightForDay = effW;
				  }
				}
			  });
			}
		  });
		});
		if (bestWeightForDay > 0) {
		   dataMap[k] = bestWeightForDay;
		}
	  });

	  const chartKeys = Object.keys(dataMap).sort();
	  if (chartKeys.length < 1) {
		destroyExerciseWeightProgressChart();
		showCustomAlert("No weight progression data found for that set.");
		return;
	  }

	  const dataPoints = chartKeys.map(k => ({ x: k, y: dataMap[k] }));
	  const labels = chartKeys.map(k => {
		 const d = parseDateKey(k);
		 return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
	  });
	  const weights = dataPoints.map(dp => dp.y);
	  const minWeight = Math.min(...weights);
	  const maxWeight = Math.max(...weights);
	  const pad = (maxWeight - minWeight) * 0.1;
	  const suggestedMin = Math.max(0, minWeight - pad);
	  const suggestedMax = maxWeight + pad;

	  destroyExerciseWeightProgressChart();
	  const ctx = document.getElementById('exerciseWeightProgressionChart').getContext('2d');
	  const { bgColors, borderColors, pointRadii } = buildHighlightArrays(
		   dataPoints, highlightDateKey, '#4DAAFF', '#FFDD77', 2.5, 5
	  );

	  exerciseWeightProgressionChart = new Chart(ctx, {
		type: 'line',
		data: {
		   labels: labels,
		   datasets: [{
			 label: `Weight progression at ${repCount} reps for ${exerciseName}`,
			 data: dataPoints.map(dp => dp.y),
			 borderColor: '#4DAAFF',
			 backgroundColor: 'rgba(77, 170, 255, 0.2)',
			 fill: true,
			 tension: 0.1,
			 pointRadius: pointRadii,
			 pointBackgroundColor: bgColors,
			 pointBorderColor: borderColors,
			 pointHoverRadius: 6
		   }]
		},
		options: {
		   responsive: true,
		   maintainAspectRatio: false,
		   scales: {
			  x: {
				 title: { display: true, text: 'Date' },
				 ticks: { color: '#ccc' },
				 grid: { color: '#555' }
			  },
			  y: {
				 suggestedMin,
				 suggestedMax,
				 title: { display: true, text: 'Effective Weight (kg)' },
				 ticks: { color: '#ccc' },
				 grid: { color: '#555' }
			  }
		   },
		   plugins: {
			  legend: { labels: { color: '#eee' } },
			  title: {
				 display: true,
				 text: `Weight progression at ${repCount} reps`,
				 color: '#fff',
				 font: { size: 16 }
			  }
		   }
		}
	  });
	}


    // Rep progression at a fixed weight
    function buildExerciseRepProgressChart(exerciseName, fixedWeight, dateKey) {
	  const selectedRange = document.querySelector('#exerciseProgressionModal .date-range-btn.active').getAttribute('data-range');
	  const refDate = parseDateKey(dateKey);
	  const { start, end } = getDateRangeBounds(selectedRange, refDate);
	  
	  const dateKeys = Object.keys(calendarData)
		.filter(key => {
		  const d = parseDateKey(key);
		  return d >= start && d <= end;
		})
		.sort();
	  const dataMap = {};
	  const template = getExerciseTemplate(exerciseName);

	  // For each day, look for sets that match the fixed effective weight.
	  dateKeys.forEach(k => {
		const dayObj = calendarData[k];
		if (!dayObj.hevyWorkouts) return;
		let bestRepsForDay = 0;
		dayObj.hevyWorkouts.forEach(workout => {
		  workout.exercises.forEach(ex => {
			if (ex.title === exerciseName) {
			  ex.sets.forEach(s => {
				let effW = parseFloat(s.weight_kg);
				if (template && (template.type === 'bodyweight_weighted' || template.type === 'bodyweight_assisted' || template.type === 'reps_only')) {
				const dayData = getDayData(k);
				// Ensure numeric conversion for both the bodyweight and extra weight.
				const bodyweight = parseFloat(dayData.weight) || parseFloat(findNearestWeight(k)) || 0;
				const extra = parseFloat(s.weight_kg) || 0;
				if (template.type === 'bodyweight_weighted') {
				  effW = bodyweight + extra;
				} else if (template.type === 'bodyweight_assisted') {
				  effW = bodyweight - extra;
				} else {
				  effW = bodyweight;
				}
			  }
				// Compare effective weight with the fixed weight parameter.
				if (Number(effW) === Number(fixedWeight) && s.reps > bestRepsForDay) {
				  bestRepsForDay = s.reps;
				}
			  });
			}
		  });
		});
		if (bestRepsForDay > 0) {
		  dataMap[k] = bestRepsForDay;
		}
	  });

	  const chartKeys = Object.keys(dataMap).sort();
	  if (chartKeys.length < 1) {
		destroyExerciseRepProgressChart();
		showCustomAlert("No rep progression data found for that set.");
		return;
	  }

	  const dataPoints = chartKeys.map(k => ({ x: k, y: dataMap[k] }));
	  const labels = chartKeys.map(k => {
		const d = parseDateKey(k);
		return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
	  });
	  const repsArray = dataPoints.map(dp => dp.y);
	  const minReps = Math.min(...repsArray);
	  const maxReps = Math.max(...repsArray);
	  const suggestedMin = Math.max(0, minReps - 1);
	  const suggestedMax = maxReps + 1;

	  destroyExerciseRepProgressChart();
	  const ctx = document.getElementById('exerciseRepProgressionChart').getContext('2d');

	  const { bgColors, borderColors, pointRadii } = buildHighlightArrays(
		dataPoints, dateKey, '#FFDD77', '#4DAAFF', 2.5, 5
	  );

	  exerciseRepProgressionChart = new Chart(ctx, {
		type: 'line',
		data: {
		  labels: labels,
		  datasets: [{
			label: `Repetitions: ${exerciseName} (${fixedWeight}kg)`,
			data: dataPoints.map(dp => dp.y),
			borderColor: '#FFDD77',
			backgroundColor: 'rgba(255, 221, 119,0.2)',
			fill: true,
			tension: 0.1,
			pointRadius: pointRadii,
			pointBackgroundColor: bgColors,
			pointBorderColor: borderColors,
			pointHoverRadius: 6
		  }]
		},
		options: {
		  responsive: true,
		  maintainAspectRatio: false,
		  scales: {
			x: {
			  title: { display: true, text: 'Date' },
			  ticks: { color: '#ccc' },
			  grid: { color: '#555' }
			},
			y: {
			  suggestedMin,
			  suggestedMax,
			  title: { display: true, text: 'Repetitions' },
			  ticks: { color: '#ccc' },
			  grid: { color: '#555' }
			}
		  },
		  plugins: {
			legend: { labels: { color: '#eee' } },
			title: {
			  display: true,
			  text: `Rep progression at ${fixedWeight}kg`,
			  color: '#fff',
			  font: { size: 16 }
			}
		  }
		}
	  });
	}


    /*
      =======================================
      = 14) Volume Over Time (Day-Level)    =
      =======================================
    */
	function openVolumeModal(dateKey) {
	  // Default range = year
	  const modalRangeBtns = document.querySelectorAll('#volumeModal .date-range-btn');
	  modalRangeBtns.forEach(btn => {
		btn.classList.toggle('active', btn.getAttribute('data-range') === 'year');
	  });

	  currentVolumeDateKey = dateKey;
	  openModalOnTop("volumeOverlay");
	  buildVolumeChart(dateKey);
	}
    function closeVolumeModal() {
      document.getElementById("volumeOverlay").classList.remove("active");
      if(volumeChart){
        volumeChart.destroy();
        volumeChart = null;
      }
    }
	function buildVolumeChart(highlightDateKey) {
	  const selectedRange = document.querySelector('#volumeModal .date-range-btn.active').getAttribute('data-range');
	  const refDate = parseDateKey(highlightDateKey);
	  const { start, end } = getDateRangeBounds(selectedRange, refDate);
	  
	  const dateKeys = Object.keys(calendarData)
		.filter(key => {
		  const d = parseDateKey(key);
		  return d >= start && d <= end;
		})
		.sort();

	  const dataMap = {};
	  // For each day, if there is at least one Hevy workout, sum the volume.
	  dateKeys.forEach(k => {
		const dayObj = calendarData[k];
		if (!dayObj.hevyWorkouts || dayObj.hevyWorkouts.length === 0) return;
		let totalVolumeForDay = 0;
		dayObj.hevyWorkouts.forEach(workout => {
		  workout.exercises.forEach(ex => {
			// For weighted exercises (including bodyweight types)
			const exTemplate = getExerciseTemplate(ex.title);
			if (exTemplate && exTemplate.type !== 'distance_duration' && exTemplate.type !== 'duration') {
			  ex.sets.forEach(s => {
				let effW = parseFloat(s.weight_kg);
				if (exTemplate.type === 'bodyweight_weighted' || exTemplate.type === 'bodyweight_assisted') {
				  const dayData = getDayData(k);
				  const bodyweight = parseFloat(dayData.weight) || parseFloat(findNearestWeight(k)) || 0;
				  const extra = parseFloat(s.weight_kg) || 0;
				  effW = (exTemplate.type === 'bodyweight_weighted') ? (bodyweight + extra) : (bodyweight - extra);
				}
				totalVolumeForDay += (effW * s.reps);
			  });
			}
		  });
		});
		if (totalVolumeForDay > 0) {
		  dataMap[k] = totalVolumeForDay;
		}
	  });

	  const chartKeys = Object.keys(dataMap).sort();
	  if (chartKeys.length < 1) {
		destroyVolumeChart();
		showCustomAlert("No volume data found for this time period.");
		return;
	  }

	  const dataPoints = chartKeys.map(k => ({ x: k, y: dataMap[k] }));
	  const labels = chartKeys.map(k => {
		const d = parseDateKey(k);
		return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
	  });
	  const volumes = dataPoints.map(dp => dp.y);
	  const minVolume = Math.min(...volumes);
	  const maxVolume = Math.max(...volumes);
	  const range = maxVolume - minVolume;
	  const padding = range * 0.1;
	  const suggestedMin = Math.max(0, minVolume - padding);
	  const suggestedMax = maxVolume + padding;

	  if (volumeChart) {
		volumeChart.destroy();
		volumeChart = null;
	  }
	  const ctx = document.getElementById('volumeChart').getContext('2d');

	  const { bgColors, borderColors, pointRadii } = buildHighlightArrays(
		dataPoints, highlightDateKey, '#4DAAFF', '#FFDD77', 2.5, 5
	  );

	  volumeChart = new Chart(ctx, {
		type: 'line',
		data: {
		  labels: labels,
		  datasets: [{
			label: 'Volume (kg)',
			data: volumes,
			borderColor: '#4DAAFF',
			backgroundColor: 'rgba(77, 170, 255,0.2)',
			fill: true,
			tension: 0.1,
			pointRadius: pointRadii,
			pointBackgroundColor: bgColors,
			pointBorderColor: borderColors,
			pointHoverRadius: 4
		  }]
		},
		options: {
		  responsive: true,
		  maintainAspectRatio: false,
		  scales: {
			x: {
			  title: { display: true, text: 'Date' },
			  ticks: { color: '#ccc' },
			  grid: { color: '#555' }
			},
			y: {
			  suggestedMin,
			  suggestedMax,
			  title: { display: true, text: 'Volume (kg)' },
			  ticks: { color: '#ccc' },
			  grid: { color: '#555' }
			}
		  },
		  plugins: {
			legend: { labels: { color: '#eee' } }
		  }
		}
	  });
	}


    /*
      =======================================
      = 15) Per-Exercise Volume Chart       =
      =======================================
    */
	function openExerciseVolumeModal(exerciseName, dateKey) {
	  // Reset the date-range buttons so that "Year" is active
	  const modalRangeBtns = document.querySelectorAll('#exerciseVolumeModal .date-range-btn');
	  modalRangeBtns.forEach(btn => {
		btn.classList.toggle('active', btn.getAttribute('data-range') === 'year');
	  });

	  // Store exercise info for later range updates
	  currentExerciseVolumeName = exerciseName;
	  currentExerciseVolumeDateKey = dateKey;

	  // Open the overlay/modal
	  openModalOnTop("exerciseVolumeOverlay");

	  // Set the header text to the appropriate title for weighted (volume) exercises.
	  // This ensures that if the modal was previously used for a duration exercise,
	  // it no longer shows "Total Duration Over Time".
	  document.getElementById("exerciseVolumeModal")
		.querySelector("h2").textContent = "Total Volume Over Time";

	  // Build the chart for weighted exercise volume
	  buildExerciseVolumeProgressionChart(exerciseName, dateKey);
	}
    function closeExerciseVolumeModal() {
      document.getElementById("exerciseVolumeOverlay").classList.remove("active");
      destroyExerciseVolumeChart();
    }
    function destroyExerciseVolumeChart() {
      if(exerciseVolumeChart) {
        exerciseVolumeChart.destroy();
        exerciseVolumeChart = null;
      }
    }
	function buildExerciseVolumeProgressionChart(exerciseName, highlightDateKey) {
	  // Determine the active date range.
	  const selectedRange = document.querySelector('#exerciseVolumeModal .date-range-btn.active').getAttribute('data-range');
	  const refDate = parseDateKey(highlightDateKey);
	  const { start, end } = getDateRangeBounds(selectedRange, refDate);
	  
	  const dateKeys = Object.keys(calendarData)
		.filter(key => {
		  const d = parseDateKey(key);
		  return d >= start && d <= end;
		})
		.sort();

	  const dataMap = {};
	  const template = getExerciseTemplate(exerciseName);

	  // For each date, sum volume using effective weight.
	  dateKeys.forEach(k => {
		const dayObj = calendarData[k];
		if (!dayObj.hevyWorkouts || dayObj.hevyWorkouts.length === 0) return;
		let exerciseVolume = 0;
		dayObj.hevyWorkouts.forEach(workout => {
		  workout.exercises.forEach(ex => {
			if (ex.title === exerciseName) {
			  ex.sets.forEach(s => {
				let effW = parseFloat(s.weight_kg);
				if (template && (template.type === 'bodyweight_weighted' || template.type === 'bodyweight_assisted' || template.type === 'reps_only')) {
				const dayData = getDayData(k);
				// Ensure numeric conversion for both the bodyweight and extra weight.
				const bodyweight = parseFloat(dayData.weight) || parseFloat(findNearestWeight(k)) || 0;
				const extra = parseFloat(s.weight_kg) || 0;
				if (template.type === 'bodyweight_weighted') {
				  effW = bodyweight + extra;
				} else if (template.type === 'bodyweight_assisted') {
				  effW = bodyweight - extra;
				} else {
				  effW = bodyweight;
				}
			  }
				exerciseVolume += (effW * s.reps);
			  });
			}
		  });
		});
		if (exerciseVolume > 0) {
		  dataMap[k] = exerciseVolume;
		}
	  });

	  const chartKeys = Object.keys(dataMap).sort();
	  if (chartKeys.length < 1) {
		destroyExerciseVolumeChart();
		showCustomAlert(`No volume data found for '${exerciseName}'.`);
		return;
	  }

	  const dataPoints = chartKeys.map(k => ({ x: k, y: dataMap[k] }));
	  const labels = chartKeys.map(k => {
		const d = parseDateKey(k);
		return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
	  });
	  const volumes = dataPoints.map(dp => dp.y);
	  const minV = Math.min(...volumes);
	  const maxV = Math.max(...volumes);
	  const range = maxV - minV;
	  const pad = range * 0.1;
	  const suggestedMin = Math.max(0, minV - pad);
	  const suggestedMax = maxV + pad;

	  destroyExerciseVolumeChart();
	  const ctx = document.getElementById('exerciseVolumeChart').getContext('2d');

	  const { bgColors, borderColors, pointRadii } = buildHighlightArrays(
		dataPoints, highlightDateKey, '#4DAAFF', '#FFDD77', 2.5, 5
	  );

	  exerciseVolumeChart = new Chart(ctx, {
		type: 'line',
		data: {
		  labels: labels,
		  datasets: [{
			label: `Volume: ${exerciseName}`,
			data: volumes,
			borderColor: '#4DAAFF',
			backgroundColor: 'rgba(77, 170, 255,0.2)',
			fill: true,
			tension: 0.1,
			pointRadius: pointRadii,
			pointBackgroundColor: bgColors,
			pointBorderColor: borderColors,
			pointHoverRadius: 6
		  }]
		},
		options: {
		  responsive: true,
		  maintainAspectRatio: false,
		  scales: {
			x: {
			  title: { display: true, text: 'Date' },
			  ticks: { color: '#ccc' },
			  grid: { color: '#555' }
			},
			y: {
			  suggestedMin,
			  suggestedMax,
			  title: { display: true, text: 'Volume (kg)' },
			  ticks: { color: '#ccc' },
			  grid: { color: '#555' }
			}
		  },
		  plugins: {
			legend: { labels: { color: '#eee' } }
		  }
		}
	  });
	}


    /*
      =======================================
      = 16) ORM Progress Over Time Chart    =
      =======================================
    */
    function openOrmProgressModal(exerciseName, dateKey) {
	// Reset date range to "Year"
	document.querySelectorAll('#exerciseOrmProgressModal .date-range-btn').forEach(btn => {
		btn.classList.toggle('active', btn.getAttribute('data-range') === 'year');
    });
      currentOrmExercise = exerciseName;
      currentOrmDateKey = dateKey;
      openModalOnTop("ormProgressOverlay");
      buildExerciseOrmProgressChart(exerciseName, dateKey);
    }
    function closeOrmProgressModal() {
      document.getElementById("ormProgressOverlay").classList.remove("active");
      destroyOrmProgressChart();
    }
    function destroyOrmProgressChart() {
      if(exerciseOrmProgressChart) {
        exerciseOrmProgressChart.destroy();
        exerciseOrmProgressChart = null;
      }
    }
    // Variables to store current ORM exercise info
	let currentOrmExercise = null;
	let currentOrmDateKey = null;

	function buildExerciseOrmProgressChart(exerciseName, highlightDateKey) {
	  const selectedRange = document.querySelector('#exerciseOrmProgressModal .date-range-btn.active').getAttribute('data-range');
	  const refDate = parseDateKey(highlightDateKey);
	  const { start, end } = getDateRangeBounds(selectedRange, refDate);

	  const template = getExerciseTemplate(exerciseName);
	  const dataMap = {};

	  const dateKeys = Object.keys(calendarData)
		.filter(key => {
		  const d = parseDateKey(key);
		  return d >= start && d <= end;
		})
		.sort();

	  dateKeys.forEach(k => {
		let dayMaxOrm = 0;
		let bestSet = null;
		const dayObj = calendarData[k];
		if (dayObj.hevyWorkouts) {
		  dayObj.hevyWorkouts.forEach(workout => {
			workout.exercises.forEach(ex => {
			  if (ex.title === exerciseName) {
				ex.sets.forEach((s, i) => {
				  let effW = parseFloat(s.weight_kg);
				  if (template && (template.type === 'bodyweight_weighted' || template.type === 'bodyweight_assisted' || template.type === 'reps_only')) {
				const dayData = getDayData(k);
				// Ensure numeric conversion for both the bodyweight and extra weight.
				const bodyweight = parseFloat(dayData.weight) || parseFloat(findNearestWeight(k)) || 0;
				const extra = parseFloat(s.weight_kg) || 0;
				if (template.type === 'bodyweight_weighted') {
				  effW = bodyweight + extra;
				} else if (template.type === 'bodyweight_assisted') {
				  effW = bodyweight - extra;
				} else {
				  effW = bodyweight;
				}
			  }
				  const thisOrm = computeOrm(effW, s.reps);
				  if (thisOrm > dayMaxOrm) {
					dayMaxOrm = thisOrm;
					bestSet = { weight: effW, reps: s.reps };
				  }
				});
			  }
			});
		  });
		}
		if (dayMaxOrm > 0 && bestSet) {
		  dataMap[k] = {
			orm: dayMaxOrm,
			bestWeight: bestSet.weight,
			bestReps: bestSet.reps
		  };
		}
	  });

	  const chartKeys = Object.keys(dataMap).sort();
	  if (chartKeys.length < 1) {
		destroyOrmProgressChart();
		document.getElementById("ormProgressOverlay").classList.remove("active");
		showCustomAlert(`No ORM data found for '${exerciseName}'.`);
		return;
	  }

	  const dataPoints = chartKeys.map(k => dataMap[k].orm);
	  const labels = chartKeys.map(k => {
		const d = parseDateKey(k);
		return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
	  });
	  const minOrm = Math.min(...dataPoints);
	  const maxOrm = Math.max(...dataPoints);
	  const range = maxOrm - minOrm;
	  const pad = range * 0.1;
	  const suggestedMin = (minOrm - pad < 0) ? 0 : (minOrm - pad);
	  const suggestedMax = maxOrm + pad;

	  destroyOrmProgressChart();
	  const ctx = document.getElementById('exerciseOrmProgressChart').getContext('2d');

	  const { bgColors, borderColors, pointRadii } = buildHighlightArrays(
		chartKeys.map(k => ({ x: k, y: dataMap[k].orm })),
		highlightDateKey,
		'#4DAAFF',
		'#FFDD77',
		2.5,
		5
	  );

	  exerciseOrmProgressChart = new Chart(ctx, {
		type: 'line',
		data: {
		  labels: labels,
		  datasets: [{
			label: `ORM: ${exerciseName}`,
			data: dataPoints,
			borderColor: '#4DAAFF',
			backgroundColor: 'rgba(77, 170, 255,0.2)',
			fill: true,
			tension: 0.1,
			pointRadius: pointRadii,
			pointBackgroundColor: bgColors,
			pointBorderColor: borderColors,
			pointHoverRadius: 6
		  }]
		},
		options: {
		  responsive: true,
		  maintainAspectRatio: false,
		  scales: {
			x: {
			  title: { display: true, text: 'Date' },
			  ticks: { color: '#ccc' },
			  grid: { color: '#555' }
			},
			y: {
			  suggestedMin,
			  suggestedMax,
			  title: { display: true, text: 'Estimated 1RM (kg)' },
			  ticks: { color: '#ccc' },
			  grid: { color: '#555' }
			}
		  },
		  plugins: {
			legend: { labels: { color: '#eee' } },
			tooltip: {
			  callbacks: {
				title: function(tooltipItems) {
				  return tooltipItems[0].label;
				},
				label: function(context) {
				  const i = context.dataIndex;
				  const dateKey = chartKeys[i];
				  const info = dataMap[dateKey];
				  const ormText = `ORM: ${info.orm.toFixed(1)}kg`;
				  const setText = `(${info.bestWeight}kg x ${info.bestReps})`;
				  return [ormText, setText];
				}
			  }
			}
		  }
		}
	  });
	}


    /*
      =======================================
      = 17) Populate Calendar Button        =
      =======================================
      Only applies to the *currentYear*.
    */
	function populateEntireCalendar() {
	 // Turn the currently selectedDates into a cycle pattern
	 // We'll then fill out *only the current year* from Jan 1 to Dec 31
	 const cycleDataArray = Array.from(selectedDates).sort();
	 if(cycleDataArray.length < 2){
	   showCustomAlert("Select at least two days to create a cycle pattern.");
	   return;
	 }

	 // Check for consecutive days
	 const firstDate = parseDateKey(cycleDataArray[0]);
	 const lastDate = parseDateKey(cycleDataArray[cycleDataArray.length - 1]);
	 const daysBetween = Math.floor((lastDate - firstDate) / MS_IN_DAY) + 1;
	 
	 if(daysBetween !== cycleDataArray.length) {
	   showCustomAlert("Selected days must be consecutive with no gaps.");
	   return;
	 }

	 const sortedCycle = cycleDataArray.map(k => parseDateKey(k)).sort((a,b) => a - b);
	 const sortedCycleKeys = sortedCycle.map(d => getDateKey(d));
	 const cyclePattern = sortedCycleKeys.map(k => ({ ...getDayData(k) }));
	 const patternLength = cyclePattern.length;
	 const startDate = new Date(sortedCycle[0].getTime());

	 // We'll only overwrite the currentYear
	 const firstOfYear = new Date(currentYear, 0, 1);
	 const lastOfYear = new Date(currentYear, 11, 31);

	 // Step 1: Fill backwards within currentYear
	 let currentDate = new Date(startDate.getTime());
	 let cycleIndex = cyclePattern.length;
	 while(currentDate >= firstOfYear) {
	   currentDate.setDate(currentDate.getDate() -1);
	   cycleIndex = (cycleIndex -1 + patternLength) % patternLength;
	   if(currentDate < firstOfYear) break;
	   const dateKey = getDateKey(currentDate);
	   const cycleData = cyclePattern[cycleIndex];
	   calendarData[dateKey] = {
		 shiftClass: cycleData.shiftClass,
		 gym: cycleData.gym,
		 gymTime: cycleData.gymTime,
		 workTime: cycleData.workTime,
		 completed: cycleData.completed,
		 weight: cycleData.weight,
		 alert: cycleData.alert,
		 hevyWorkouts: cycleData.hevyWorkouts ? [...cycleData.hevyWorkouts] : []
	   };
	 }

	 // Step 2: Fill forwards within currentYear
	 currentDate = new Date(startDate.getTime());
	 cycleIndex = 0;
	 while(currentDate <= lastOfYear) {
	   const dateKey = getDateKey(currentDate);
	   const cycleData = cyclePattern[cycleIndex % cyclePattern.length];
	   calendarData[dateKey] = {
		 shiftClass: cycleData.shiftClass,
		 gym: cycleData.gym,
		 gymTime: cycleData.gymTime,
		 workTime: cycleData.workTime,
		 completed: cycleData.completed,
		 weight: cycleData.weight,
		 alert: cycleData.alert,
		 hevyWorkouts: cycleData.hevyWorkouts ? [...cycleData.hevyWorkouts] : []
	   };
	   cycleIndex++;
	   currentDate.setDate(currentDate.getDate() + 1);
	   if(currentDate > lastOfYear) break;
	 }

	 // We'll store that cycle as the default pattern
	 defaultCycleData = {
	   pattern: [...cyclePattern],
	   startDate: getDateKey(sortedCycle[0])
	 };
	 localStorage.setItem(LS_DEFAULT_CYCLE_KEY, JSON.stringify(defaultCycleData));
	 localStorage.setItem(LS_CALENDAR_DATA_KEY, JSON.stringify(calendarData));

	 selectedDates.clear();
	 renderCalendar(currentYear, currentMonth);
	 showCustomAlert("Current year's calendar has been populated with your custom cycle.");
	}
    function updatePopulateCalendarButtonState() {
      const btn = document.getElementById("populateCalendarBtn");
      if(selectedDates.size >=2){
        btn.disabled = false;
        btn.style.opacity = "1";
        btn.style.border = "2px solid gold";
      }
      else{
        btn.disabled = true;
        btn.style.opacity = "0.5";
        btn.style.border = "2px solid #555";
      }
    }

    /*
      =======================================
      =    Clear Calendar Function          =
      =======================================
    */
	function clearCalendar() {
	  showCustomConfirm("Are you sure you want to clear the entire calendar? This will remove all your data and set all days to 'None'. This action cannot be undone.", () => {
		// Clear calendar data
		for(let year = START_YEAR; year <= END_YEAR; year++) {
		  const startDate = new Date(year, 0, 1);
		  const endDate = new Date(year, 11, 31);
		  const totalDays = Math.floor((endDate - startDate) / MS_IN_DAY) + 1;

		  for(let i = 0; i < totalDays; i++) {
			const currentDate = new Date(startDate.getTime() + i * MS_IN_DAY);
			const dateKey = getDateKey(currentDate);
			calendarData[dateKey] = {
			  shiftClass: "off-bg",
			  gym: "None",
			  gymTime: "",
			  workTime: "",
			  completed: false,
			  weight: null,
			  alert: null,
			  hevyWorkouts: []
			};
		  }
		}

		// Clear presets
		customPresets = [];
		localStorage.setItem(LS_PRESETS_KEY, JSON.stringify(customPresets));
		colorOptions = [...baseColorOptions];

		localStorage.setItem(LS_CALENDAR_DATA_KEY, JSON.stringify(calendarData));
		defaultCycleData = { pattern: [], startDate: null };
		localStorage.setItem(LS_DEFAULT_CYCLE_KEY, JSON.stringify(defaultCycleData));

		selectedDates.clear();
		buildColorSwatches(); // Rebuild swatches to reflect cleared presets
		renderCalendar(currentYear, currentMonth);
		showCustomAlert("Calendar has been cleared. All days are now set to 'None'.");
	  });
	}

    /*
      =======================================
      =  Custom Alert/Prompt/Confirm        =
      =======================================
    */
    function showCustomAlert(message) {
      const overlay = document.getElementById("customAlertOverlay");
      const messageElem = document.getElementById("customAlertMessage");
      const inputElem = document.getElementById("customAlertInput");
      const confirmButtons = document.getElementById("customConfirmButtons");
      const defaultButton = document.getElementById("customDefaultButton");

      messageElem.textContent = message;
      inputElem.style.display = "none";
      confirmButtons.style.display = "none";
      defaultButton.style.display = "block";

      openModalOnTop("customAlertOverlay");
    }
    function showCustomConfirm(message, onConfirm) {
      const overlay = document.getElementById("customAlertOverlay");
      const messageElem = document.getElementById("customAlertMessage");
      const inputElem = document.getElementById("customAlertInput");
      const confirmButtons = document.getElementById("customConfirmButtons");
      const defaultButton = document.getElementById("customDefaultButton");

      messageElem.textContent = message;
      inputElem.style.display = "none";
      confirmButtons.style.display = "flex";
      defaultButton.style.display = "none";

      // Remove old buttons if any
      const existingYes = document.getElementById("customYesBtn");
      const existingNo = document.getElementById("customNoBtn");
      if(existingYes) existingYes.remove();
      if(existingNo) existingNo.remove();

      const yesButton = document.createElement("button");
      yesButton.id = "customYesBtn";
      yesButton.textContent = "Yes";
      yesButton.onclick = () => {
        overlay.classList.remove("active");
        onConfirm();
      };

      const noButton = document.createElement("button");
      noButton.id = "customNoBtn";
      noButton.textContent = "No";
      noButton.onclick = () => {
        overlay.classList.remove("active");
      };

      confirmButtons.appendChild(yesButton);
      confirmButtons.appendChild(noButton);
      overlay.classList.add("active");
    }
    function showCustomPrompt(message, placeholder, callback) {
      const overlay = document.getElementById("customAlertOverlay");
      const messageElem = document.getElementById("customAlertMessage");
      const inputElem = document.getElementById("customAlertInput");
      const confirmButtons = document.getElementById("customConfirmButtons");
      const defaultButton = document.getElementById("customDefaultButton");

      messageElem.textContent = message;
      inputElem.style.display = "block";
      inputElem.placeholder = placeholder || "";
      confirmButtons.style.display = "flex";
      defaultButton.style.display = "none";

      // Remove old buttons if any
      const existingYes = document.getElementById("customYesBtn");
      const existingNo = document.getElementById("customNoBtn");
      if(existingYes) existingYes.remove();
      if(existingNo) existingNo.remove();

      const yesButton = document.createElement("button");
      yesButton.id = "customYesBtn";
      yesButton.textContent = "OK";
      yesButton.onclick = () => {
        const inputVal = inputElem.value.trim();
        overlay.classList.remove("active");
        callback(inputVal);
      };

      const noButton = document.createElement("button");
      noButton.id = "customNoBtn";
      noButton.textContent = "Cancel";
      noButton.onclick = () => {
        overlay.classList.remove("active");
      };

      confirmButtons.appendChild(yesButton);
      confirmButtons.appendChild(noButton);

      inputElem.value = "";
      overlay.classList.add("active");
    }
    function closeCustomAlert() {
      const overlay = document.getElementById("customAlertOverlay");
      const messageElem = document.getElementById("customAlertMessage");
      const inputElem = document.getElementById("customAlertInput");
      const confirmButtons = document.getElementById("customConfirmButtons");
      const defaultButton = document.getElementById("customDefaultButton");

      const yesBtn = document.getElementById("customYesBtn");
      const noBtn = document.getElementById("customNoBtn");
      if(yesBtn) yesBtn.remove();
      if(noBtn) noBtn.remove();

      messageElem.textContent = "";
      inputElem.style.display = "none";
      confirmButtons.style.display = "none";
      defaultButton.style.display = "block";

      overlay.classList.remove("active");
    }
	/*
      =====================================
      = 19) Exercise Summary Modal        =
      =====================================
    */
	
	function openExerciseSummaryModal(exerciseName) {
	  // Bring the exercise summary overlay on top
	  openModalOnTop("exerciseSummaryOverlay"); 

	  const content = document.getElementById("exerciseSummaryContent");
	  const template = getExerciseTemplate(exerciseName);
	  const exerciseType = template ? template.type : "weighted_reps";

	  // Basic heading
	  let html = `
		<div class="exercise-summary-header">
		  ${escapeHtml(exerciseName)}
		  <button class="compare-button"
				  onclick="openExerciseHistoryModal('${escapeHtml(exerciseName)}')">
			Exercise History
		  </button>
		</div>
	  `;

	  if (exerciseType === "duration") {
		// Duration stats
		const stats = getDurationStats(exerciseName);

		html += `
		  <div class="key-stats-grid">
			<div class="key-stat" data-date="${stats.longestSetDate || ''}">
			  <div class="key-stat-label">Longest Duration (Set)</div>
			  <div class="key-stat-value">
				${formatDuration(stats.longestSetDuration)}
			  </div>
			</div>

			<div class="key-stat" data-date="${stats.longestSessionDate || ''}">
			  <div class="key-stat-label">Longest Duration (Session)</div>
			  <div class="key-stat-value">
				${formatDuration(stats.longestSessionDuration)}
			  </div>
			</div>

			<div class="key-stat" data-frequency="true">
			  <div class="key-stat-label">Exercise Frequency</div>
			  <div class="key-stat-value">${stats.totalOccurrences}</div>
			</div>

			<div class="key-stat">
			  <div class="key-stat-label">Total Duration</div>
			  <div class="key-stat-value">
				${formatDuration(stats.totalDuration)}
			  </div>
			</div>
		  </div>
		`;

	  } else if (exerciseType === "distance_duration") {
		const stats = getCardioStats(exerciseName);

		html += `
		  <div class="key-stats-grid">
			<div class="key-stat" data-date="${stats.longestSetDate || ''}">
			  <div class="key-stat-label">Longest Distance (Set)</div>
			  <div class="key-stat-value">
				${(stats.longestSetDistance / 1000).toFixed(2)}km
			  </div>
			</div>

			<div class="key-stat" data-date="${stats.longestSessionDate || ''}">
			  <div class="key-stat-label">Longest Distance (Session)</div>
			  <div class="key-stat-value">
				${(stats.longestSessionDistance / 1000).toFixed(2)}km
			  </div>
			</div>

			<div class="key-stat" data-date="${stats.bestPace5kDate || ''}">
			  <div class="key-stat-label">Best Pace (5km+)</div>
			  <div class="key-stat-value">
				${
				  stats.bestPace5kPlus
					? formatPace(5000, stats.bestPace5kPlus * 5) + "/km"
					: "N/A"
				}
			  </div>
			</div>

			<div class="key-stat" data-frequency="true">
			  <div class="key-stat-label">Exercise Frequency</div>
			  <div class="key-stat-value">${stats.totalOccurrences}</div>
			</div>

			<div class="key-stat" data-date="${stats.longestDurationDate || ''}">
			  <div class="key-stat-label">Longest Duration</div>
			  <div class="key-stat-value">
				${formatDuration(stats.longestSetDuration)}
			  </div>
			</div>

			<div class="key-stat">
			  <div class="key-stat-label">Total Distance</div>
			  <div class="key-stat-value">
				${(stats.totalDistance / 1000).toFixed(2)}km
			  </div>
			</div>
		  </div>

		  <div class="exercise-stat-block">
			<div class="exercise-stat-title">Best Pace by Distance</div>
			<div class="rep-range-list">
		`;

		const segmentsSorted = Object.keys(stats.bestPacesByDistance)
		  .map(d => parseInt(d, 10))
		  .sort((a, b) => a - b);

		segmentsSorted.forEach(dist => {
		  const paceObj = stats.bestPacesByDistance[dist];
		  let labelStr = dist + 'm+';
		  switch(dist) {
			case 60:    labelStr = "60m+";    break;
			case 100:   labelStr = "100m+";   break;
			case 400:   labelStr = "400m+";   break;
			case 800:   labelStr = "800m+";   break;
			case 1000:  labelStr = "1km+";    break;
			case 2000:  labelStr = "2km+";    break;
			case 3000:  labelStr = "3km+";    break;
			case 4000:  labelStr = "4km+";    break;
			case 5000:  labelStr = "5km+";    break;
			case 10000: labelStr = "10km+";   break;
			case 21100: labelStr = "21.1km+"; break;
			case 42195: labelStr = "42.195km+"; break;
		  }

		  if (paceObj.paceValue < Infinity) {
			const paceStr = formatPace(1000, paceObj.paceValue * 60) + "/km";
			html += `
			  <div class="rep-range-row" data-date="${paceObj.dateKey}">
				<span class="rep-range-count">${labelStr}</span>
				<span class="rep-range-weight">${paceStr}</span>
			  </div>
			`;
		  } else {
			html += `
			  <div class="rep-range-row">
				<span class="rep-range-count">${labelStr}</span>
				<span class="rep-range-weight">N/A</span>
			  </div>
			`;
		  }
		});

		html += `</div></div>`;

	  } else {
		const stats = getExerciseStats(exerciseName);

		html += `
		  <div class="key-stats-grid">
			<div class="key-stat" data-date="${stats.heaviestWeightDate}">
			  <div class="key-stat-label">Heaviest Weight</div>
			  <div class="key-stat-value">${stats.heaviestWeight}kg</div>
			</div>
			<div class="key-stat" data-date="${stats.bestOrmDate}">
			  <div class="key-stat-label">Estimated 1RM</div>
			  <div class="key-stat-value glowing-orm">
				${stats.bestOrm.toFixed(1)}kg
			  </div>
			</div>
			<div class="key-stat" data-frequency="true">
			  <div class="key-stat-label">Exercise Frequency</div>
			  <div class="key-stat-value">${stats.totalOccurrences}</div>
			</div>
			<div class="key-stat" data-date="${stats.bestSetVolumeDate}">
			  <div class="key-stat-label">Best Set Volume</div>
			  <div class="key-stat-value">
				${stats.bestSetDetails.weight}kg √ó ${stats.bestSetDetails.reps}
			  </div>
			</div>
			<div class="key-stat" data-date="${stats.bestSessionVolumeDate}">
			  <div class="key-stat-label">Best Session Volume</div>
			  <div class="key-stat-value">
				${stats.bestSessionVolume.toLocaleString()}kg
			  </div>
			</div>
			<div class="key-stat" data-total-volume="true">
			  <div class="key-stat-label">Total Volume</div>
			  <div class="key-stat-value">${stats.totalVolume.toLocaleString()}kg</div>
			</div>
		  </div>

		  <div class="exercise-stat-block">
			<div class="exercise-stat-title">Best Weight by Rep Range</div>
			<div class="rep-range-list">
		`;

		const sortedReps = Object.keys(stats.repRanges).map(Number).sort((a, b) => a - b);
		sortedReps.forEach(reps => {
		  const data = stats.repRanges[reps];
		  const isOrmSet = (computeOrm(data.weight, reps) === stats.bestOrm);
		  html += `
			<div class="rep-range-row" data-date="${data.date}">
			  <span class="rep-range-count">${reps} reps</span>
			  <span class="rep-range-weight ${isOrmSet ? 'glowing-orm' : ''}">
				${data.weight}kg
			  </span>
			</div>
		  `;
		});

		html += `</div></div>`;
	  }

	  // Inject into the modal
	  content.innerHTML = html;

	  // Set up click handlers
	  content.querySelectorAll("[data-date]").forEach(element => {
		element.addEventListener("click", () => {
		  const date = element.getAttribute("data-date");
		  if (date) {
			const dateObj = new Date(date);
			const dateKey = getDateKey(dateObj);
			openHevyModal(dateKey);
		  }
		});
	  });

	  // Frequency handler
	  const freqElem = content.querySelector("[data-frequency='true']");
	  if (freqElem) {
		freqElem.addEventListener("click", () => {
		  openExerciseFrequencyModal(exerciseName);
		});
	  }

	  // Total volume handler
	  const totalVolElem = content.querySelector("[data-total-volume='true']");
	  if (totalVolElem) {
		totalVolElem.addEventListener("click", () => {
		  openTotalVolumeDistributionModal(getDateKey(new Date()));
		});
	  }
	}
	

	function closeExerciseSummaryModal() {
	  document.getElementById("exerciseSummaryOverlay").classList.remove("active");
	}

	function getExerciseStats(exerciseName) {
	  let totalOccurrences = 0;
	  let heaviestWeight = 0;
	  let heaviestWeightDate = null;
	  let bestOrm = 0;
	  let bestOrmDate = null;
	  let bestSetVolume = 0;
	  let bestSetVolumeDate = null;
	  let bestSetDetails = null;
	  let bestSessionVolume = 0;
	  let bestSessionVolumeDate = null;
	  let totalVolume = 0;
	  const repRanges = {};

	  const template = getExerciseTemplate(exerciseName);

	  Object.entries(calendarData).forEach(([dateKey, dayData]) => {
		if (!dayData.hevyWorkouts) return;
		dayData.hevyWorkouts.forEach(workout => {
		  let sessionVolume = 0;
		  workout.exercises.forEach(ex => {
			if (ex.title === exerciseName) {
			  totalOccurrences++;
			  ex.sets.forEach(set => {
				let effectiveWeight = parseFloat(set.weight_kg);
				if (template && (template.type === 'bodyweight_weighted' || template.type === 'bodyweight_assisted' || template.type === 'reps_only')) {
				const dayData = getDayData(dateKey);
				// Ensure numeric conversion for both the bodyweight and extra weight.
				const bodyweight = parseFloat(dayData.weight) || parseFloat(findNearestWeight(dateKey)) || 0;
				const extra = parseFloat(set.weight_kg) || 0;
				if (template.type === 'bodyweight_weighted') {
				  effectiveWeight = bodyweight + extra;
				} else if (template.type === 'bodyweight_assisted') {
				  effectiveWeight = bodyweight - extra;
				} else {
				  effectiveWeight = bodyweight;
				}
			  }
				// Update rep ranges
				if (!repRanges[set.reps]) {
				  repRanges[set.reps] = { weight: 0, date: null };
				}
				if (effectiveWeight > repRanges[set.reps].weight) {
				  repRanges[set.reps] = { weight: effectiveWeight, date: workout.start_time };
				}
				const setVolume = effectiveWeight * set.reps;
				const orm = computeOrm(effectiveWeight, set.reps);

				if (setVolume > bestSetVolume) {
				  bestSetVolume = setVolume;
				  bestSetVolumeDate = workout.start_time;
				  bestSetDetails = { weight: effectiveWeight, reps: set.reps };
				}
				if (effectiveWeight > heaviestWeight) {
				  heaviestWeight = effectiveWeight;
				  heaviestWeightDate = workout.start_time;
				}
				if (orm > bestOrm) {
				  bestOrm = orm;
				  bestOrmDate = workout.start_time;
				}
				sessionVolume += setVolume;
				totalVolume += setVolume;
			  });
			}
		  });
		  if (sessionVolume > bestSessionVolume) {
			bestSessionVolume = sessionVolume;
			bestSessionVolumeDate = workout.start_time;
		  }
		});
	  });
	  return { 
		totalOccurrences, 
		repRanges,
		heaviestWeight,
		heaviestWeightDate,
		bestOrm,
		bestOrmDate,
		bestSetVolume,
		bestSetVolumeDate,
		bestSetDetails,
		bestSessionVolume,
		bestSessionVolumeDate,
		totalVolume
	  };
	}
	// EXERCISE HISTORY Modal
	function openExerciseHistoryModal(exerciseName) {
	  openModalOnTop("exerciseHistoryOverlay");
	  document.getElementById("exerciseHistorySubheader").textContent = exerciseName;
	  
	  const content = document.getElementById("exerciseHistoryContent");
	  content.innerHTML = '';
	  
	  const sessions = getAllSessionsForExercise(exerciseName);
	  const template = getExerciseTemplate(exerciseName);
	  const exerciseType = template ? template.type : 'weighted_reps';
	  
	  let html = '';
	  
	  sessions.forEach(session => {
		const formattedDate = session.date.toLocaleDateString('en-US', {
		  year: 'numeric',
		  month: 'long',
		  day: 'numeric'
		});
		
		html += `
		  <div class="exercise-history-entry">
			<div class="exercise-history-date">${formattedDate}</div>
			<div class="hevy-sets exercise-history-sets">
		`;
		
		if (exerciseType === 'duration') {
		  let totalDuration = 0;

		  session.exercise.sets.forEach((set, index) => {
			const prInfo = getSetPRInfo(set, exerciseName, session.dateKey, session.workout.id, index);
			const prClass = prInfo.isPR ? 'pr-border' : '';
			const prLabels = prInfo.labels.length > 0 ? `
			  <div class="pr-labels">
				${prInfo.labels.map(label => `<div class="pr-text smaller-pr">${label}</div>`).join('')}
			  </div>
			` : '';

			totalDuration += set.duration_seconds;
			
			html += `
			  <div class="hevy-set ${prClass}">
				${formatDuration(set.duration_seconds)}
				${prInfo.isPR ? buildStarsContainer() : ''}
				${prLabels}
			  </div>
			`;
		  });
		  
		  // Add total duration for the session
		  html += `
			</div>
			<div style="margin-top: 0.5rem; text-align: center; color: #888;">
			  Total Duration: ${formatDuration(totalDuration)}
			</div>
		  </div>
		  `;
		  
		} else if (exerciseType === 'distance_duration') {
		  session.exercise.sets.forEach((set, index) => {
			const prInfo = getSetPRInfo(set, exerciseName, session.dateKey, session.workout.id, index);
			const prClass = prInfo.isPR ? 'pr-border' : '';
			const prLabels = prInfo.labels.length > 0 ? `
			  <div class="pr-labels">
				${prInfo.labels.map(label => `<div class="pr-text smaller-pr">${label}</div>`).join('')}
			  </div>
			` : '';
			
			const pace = formatPace(set.distance_meters, set.duration_seconds);
			
			html += `
			  <div class="hevy-set ${prClass}">
				${(set.distance_meters / 1000).toFixed(2)}km
				<span style="color: #888;">in</span>
				${formatDuration(set.duration_seconds)}
				<div style="font-size: 0.8em; color: #888; margin-top: 4px;">
				  ${pace}/km
				</div>
				${prInfo.isPR ? buildStarsContainer() : ''}
				${prLabels}
			  </div>
			`;
		  });
		  
		  // Add totals
		  let totalDistance = 0;
		  let totalDuration = 0;
		  session.exercise.sets.forEach(set => {
			totalDistance += set.distance_meters;
			totalDuration += set.duration_seconds;
		  });
		  
		  html += `
			</div>
			<div style="margin-top: 0.5rem; text-align: center; color: #888;">
			  Total Distance: ${(totalDistance / 1000).toFixed(2)}km
			  <br>
			  Total Duration: ${formatDuration(totalDuration)}
			</div>
		  </div>
		  `;
		  
		} else {
		  // For weighted exercises (normal weighted_reps and bodyweight-based types)
		  session.exercise.sets.forEach((set, index) => {
			const prInfo = getSetPRInfo(set, exerciseName, session.dateKey, session.workout.id, index);
			const prClass = prInfo.isPR ? 'pr-border' : '';
			const prLabels = prInfo.labels.length > 0 ? `
			  <div class="pr-labels">
				${prInfo.labels.map(label => `<div class="pr-text smaller-pr">${label}</div>`).join('')}
			  </div>
			` : '';
			
			// Compute effective weight: if the template type is bodyweight_weighted or bodyweight_assisted,
			// then effectiveWeight = (day's bodyweight) ¬± (set.weight_kg); otherwise, it's just set.weight_kg.
			let effectiveWeight = parseFloat(set.weight_kg);
			if (template && (template.type === 'bodyweight_weighted' || template.type === 'bodyweight_assisted' || template.type === 'reps_only')) {
				const dayData = getDayData(session.dateKey);
				// Ensure numeric conversion for both the bodyweight and extra weight.
				const bodyweight = parseFloat(dayData.weight) || parseFloat(findNearestWeight(session.dateKey)) || 0;
				const extra = parseFloat(set.weight_kg) || 0;
				if (template.type === 'bodyweight_weighted') {
				  effectiveWeight = bodyweight + extra;
				} else if (template.type === 'bodyweight_assisted') {
				  effectiveWeight = bodyweight - extra;
				} else {
				  effectiveWeight = bodyweight;
				}
			  }
			
			html += `
			  <div class="hevy-set ${prClass}" data-exercise="${escapeHtml(exerciseName)}" data-reps="${set.reps}" data-weight="${effectiveWeight}" data-date-key="${session.dateKey}">
				<span class="hevy-set-weight">${effectiveWeight}kg</span>
				x
				<span class="hevy-set-reps">${set.reps}</span>
				${prInfo.isPR ? buildStarsContainer() : ''}
				${prLabels}
			  </div>
			`;
		  });
		  
		  html += `</div></div>`;
		}
	  });

	  if (sessions.length === 0) {
		html = '<p style="text-align: center; color: #888; padding: 2rem;">No historical data found for this exercise.</p>';
	  }

	  content.innerHTML = html;

	  // Only add click handlers for weighted exercises
	  if (exerciseType === 'weighted_reps') {
		content.addEventListener('click', (e) => {
		  const setEl = e.target.closest('.hevy-set');
		  if (setEl) {
			const exerciseName = setEl.dataset.exercise;
			const weight = parseFloat(setEl.dataset.weight);
			const reps = parseInt(setEl.dataset.reps, 10);
			const dateKey = setEl.dataset.dateKey;
			openExerciseProgressionModal(exerciseName, weight, reps, dateKey);
		  }
		});
	  }

	  content.scrollTop = 0;
	}


	function closeExerciseHistoryModal() {
	  document.getElementById("exerciseHistoryOverlay").classList.remove("active");
	}

	// Add to existing getSetPRInfo function (if not exists, create it)
	function getSetPRInfo(set, exerciseName, dateKey, workoutId, setIndex) {
	  const template = getExerciseTemplate(exerciseName);
	  const exerciseType = template ? template.type : 'weighted_reps';
	  
	  const prInfo = {
		isPR: false,
		labels: []
	  };

	  if (exerciseType === 'duration') {
		// Find best duration ever recorded for this exercise
		let bestDuration = {
		  duration: 0,
		  dateKey: null,
		  workoutId: null,
		  setIndex: null
		};

		Object.entries(calendarData).forEach(([k, dayData]) => {
		  if (!dayData.hevyWorkouts) return;
		  dayData.hevyWorkouts.forEach(w => {
			w.exercises.forEach(ex => {
			  if (ex.title === exerciseName) {
				ex.sets.forEach((s, i) => {
				  if (s.duration_seconds > bestDuration.duration) {
					bestDuration = {
					  duration: s.duration_seconds,
					  dateKey: k,
					  workoutId: w.id,
					  setIndex: i
					};
				  }
				});
			  }
			});
		  });
		});

		// Check if this set is the best duration
		if (set.duration_seconds === bestDuration.duration &&
			dateKey === bestDuration.dateKey &&
			workoutId === bestDuration.workoutId &&
			setIndex === bestDuration.setIndex) {
		  prInfo.isPR = true;
		  prInfo.labels.push('Duration PR');
		}
	  } else if (exerciseType === 'distance_duration') {
		const prs = getCardioPRs(exerciseName);
		
		if (prs.distancePR && 
			prs.distancePR.dateKey === dateKey && 
			prs.distancePR.workoutId === workoutId && 
			prs.distancePR.setIndex === setIndex) {
		  prInfo.isPR = true;
		  prInfo.labels.push('Distance PR');
		}

		if (prs.durationPR && 
			prs.durationPR.dateKey === dateKey && 
			prs.durationPR.workoutId === workoutId && 
			prs.durationPR.setIndex === setIndex) {
		  prInfo.isPR = true;
		  prInfo.labels.push('Duration PR');
		}

		if (prs.pacePR && 
			prs.pacePR.dateKey === dateKey && 
			prs.pacePR.workoutId === workoutId && 
			prs.pacePR.setIndex === setIndex) {
		  prInfo.isPR = true;
		  prInfo.labels.push('Pace (5km+) PR');
		}
	  } else {
		const globalPRs = getGlobalPRsForExercise(exerciseName);
		const setDate = parseDateKey(dateKey);
		
		// Compute effective weight.
		let effectiveWeight = parseFloat(set.weight_kg);
		if (template && (template.type === 'bodyweight_weighted' || template.type === 'bodyweight_assisted' || template.type === 'reps_only')) {
				const dayData = getDayData(dateKey);
				// Ensure numeric conversion for both the bodyweight and extra weight.
				const bodyweight = parseFloat(dayData.weight) || parseFloat(findNearestWeight(dateKey)) || 0;
				const extra = parseFloat(set.weight_kg) || 0;
				if (template.type === 'bodyweight_weighted') {
				  effectiveWeight = bodyweight + extra;
				} else if (template.type === 'bodyweight_assisted') {
				  effectiveWeight = bodyweight - extra;
				} else {
				  effectiveWeight = bodyweight;
				}
			  }
		
		if (effectiveWeight === globalPRs.weightPR?.weight &&
			setDate.getTime() === parseDateKey(globalPRs.weightPR.dateKey).getTime() &&
			workoutId === globalPRs.weightPR.workoutId &&
			setIndex === globalPRs.weightPR.setIndex) {
		  prInfo.isPR = true;
		  prInfo.labels.push('Weight PR');
		}
		
		const setVolume = effectiveWeight * set.reps;
		if (setVolume === globalPRs.volumePR?.volume &&
			setDate.getTime() === parseDateKey(globalPRs.volumePR.dateKey).getTime() &&
			workoutId === globalPRs.volumePR.workoutId &&
			setIndex === globalPRs.volumePR.setIndex) {
		  prInfo.isPR = true;
		  prInfo.labels.push('Volume PR');
		}
		
		const setORM = computeOrm(effectiveWeight, set.reps);
		if (setORM === globalPRs.ormPR?.orm &&
			setDate.getTime() === parseDateKey(globalPRs.ormPR.dateKey).getTime() &&
			workoutId === globalPRs.ormPR.workoutId &&
			setIndex === globalPRs.ormPR.setIndex) {
		  prInfo.isPR = true;
		  prInfo.labels.push('1RM PR');
		}
	  }
	  
	  return prInfo;
	}
	
	/*
      =======================================
      = 20) Exercise Frequency Modal        =
      =======================================
    */
	function getAllExerciseFrequencies() {
	  const frequencies = {};
	  
	  Object.values(calendarData).forEach(dayData => {
		if (dayData.hevyWorkouts) {
		  dayData.hevyWorkouts.forEach(workout => {
			workout.exercises.forEach(exercise => {
			  frequencies[exercise.title] = (frequencies[exercise.title] || 0) + 1;
			});
		  });
		}
	  });
	  
	  // Convert to array and sort by frequency
	  return Object.entries(frequencies)
		.map(([name, count]) => ({ name, count }))
		.sort((a, b) => b.count - a.count);
	}

	function openExerciseFrequencyModal(selectedExercise) {
	  openModalOnTop("exerciseFrequencyOverlay");
	  
	  const frequencies = getAllExerciseFrequencies();
	  
	  // Prepare data for Chart.js
	  const labels = frequencies.map(f => f.name);
	  const data = frequencies.map(f => f.count);
	  const backgroundColor = labels.map(label => 
		label === selectedExercise ? '#FFDD77' : '#4DAAFF'
	  );
	  
	  if (exerciseFrequencyChart) {
		exerciseFrequencyChart.destroy();
	  }
	  
	  const ctx = document.getElementById('exerciseFrequencyChart').getContext('2d');
	  exerciseFrequencyChart = new Chart(ctx, {
		type: 'bar',
		data: {
		  labels: labels,
		  datasets: [{
			data: data,
			backgroundColor: backgroundColor,
			borderColor: backgroundColor,
			borderWidth: 1
		  }]
		},
		options: {
		  responsive: true,
		  maintainAspectRatio: false,
		  plugins: {
			legend: {
			  display: false
			},
			title: {
			  display: true,
			  text: '',
			  color: '#fff',
			  font: { size: 16 }
			}
		  },
		  scales: {
			y: {
			  beginAtZero: true,
			  title: {
				display: true,
				text: 'Frequency',
				color: '#ccc'
			  },
			  ticks: { color: '#ccc' },
			  grid: { color: '#555' }
			},
			x: {
			  ticks: { 
				color: '#ccc',
				maxRotation: 45,
				minRotation: 45
			  },
			  grid: { color: '#555' }
			}
		  }
		}
	  });
	}

	function closeExerciseFrequencyModal() {
	  document.getElementById("exerciseFrequencyOverlay").classList.remove("active");
	  if (exerciseFrequencyChart) {
		exerciseFrequencyChart.destroy();
		exerciseFrequencyChart = null;
	  }
	}
	
	function getExerciseVolumeTotals() {
	  const volumeTotals = {};
	  
	  Object.values(calendarData).forEach(dayData => {
		if (dayData.hevyWorkouts) {
		  dayData.hevyWorkouts.forEach(workout => {
			workout.exercises.forEach(exercise => {
			  const exerciseName = exercise.title;
			  if (!volumeTotals[exerciseName]) {
				volumeTotals[exerciseName] = 0;
			  }
			  
			  exercise.sets.forEach(set => {
				volumeTotals[exerciseName] += set.weight_kg * set.reps;
			  });
			});
		  });
		}
	  });
	  
	  // Convert to array and sort by volume
	  return Object.entries(volumeTotals)
		.map(([name, volume]) => ({ name, volume }))
		.sort((a, b) => b.volume - a.volume);
	}
	/*
      =========================================
      = 21) Total Volume Distribution Modal   =
      =========================================
    */
	
	let lastDistributionData = null; // store the main data vs. "others" data for re-draws

	function openTotalVolumeDistributionModal(selectedExercise = null) {
	  // 1) Show the overlay
	  openModalOnTop("totalVolumeDistributionOverlay");
	  
	  // 2) Gather volume data for all exercises
	  const volumeData = getExerciseVolumeTotals(); 
	  // e.g. volumeData: [{ name: "Bench Press", volume: 12345 }, { name: "Squat", volume: 23456 }, ...]

	  // (Optional) Sort descending, so largest is first
	  volumeData.sort((a, b) => b.volume - a.volume);
	  
	  // 3) Compute total volume across all exercises
	  const grandTotal = volumeData.reduce((sum, item) => sum + item.volume, 0);

	  // 4) Show total weight in the modal
	  const distributionModal = document.getElementById("totalVolumeDistributionModal");
	  let totalWeightElem = distributionModal.querySelector("#grandTotalWeight");
	  if (!totalWeightElem) {
		totalWeightElem = document.createElement("div");
		totalWeightElem.id = "grandTotalWeight";
		totalWeightElem.style.cssText = `
		  font-size: 1rem;
		  text-align: center;
		  color: #FFDD77;
		  margin-bottom: 0.75rem;
		  font-weight: 600;
		`;
		distributionModal.insertBefore(totalWeightElem, distributionModal.querySelector(".modal-row"));
	  }
	  totalWeightElem.textContent = `Total Weight Lifted: ${grandTotal.toLocaleString()} kg`;

	  // 5) Prepare labels and data arrays
	  const labels = volumeData.map(d => d.name);
	  const data = volumeData.map(d => d.volume);

	  // 6) Build color array from the 24 shift-time colors
	  const shiftColorKeys = Object.keys(workTimeColors).sort();  // ["0000","0100",...,"2300"]
	  const shiftColorVals = shiftColorKeys.map(k => workTimeColors[k]); // array of hex codes
	  const colorCount = shiftColorVals.length;
	  
	  const backgroundColors = labels.map((_, i) => {
		return shiftColorVals[i % colorCount];
	  });

	  // 7) Determine slice offsets to pop out the selected exercise
	  const offsetArray = new Array(labels.length).fill(0);
	  if (selectedExercise) {
		const highlightIndex = labels.findIndex(label => label === selectedExercise);
		if (highlightIndex >= 0) {
		  offsetArray[highlightIndex] = 30; // bigger offset for that slice
		}
	  }

	  // 8) Destroy old chart if needed
	  if (totalVolumeDistributionChart) {
		totalVolumeDistributionChart.destroy();
		totalVolumeDistributionChart = null;
	  }
	  
	  // 9) Build the new Donut chart
	  const ctx = document.getElementById("totalVolumeDistributionChart").getContext("2d");
	  totalVolumeDistributionChart = new Chart(ctx, {
		type: "doughnut",
		data: {
		  labels: labels,
		  datasets: [{
			data: data,
			backgroundColor: backgroundColors,
			borderWidth: 1,   // remove outline
			spacing: 1,       // smaller gap between slices
			offset: offsetArray
		  }]
		},
		options: {
		  responsive: true,
		  rotation: 0,
		  maintainAspectRatio: false,
		  cutout: "50%", // donut hole size
		  plugins: {
			legend: {
			  position: "right",
			  labels: {
				color: "#eee",
				padding: 10,
				font: { size: 11 }
			  }
			},
			tooltip: {
			  callbacks: {
				label: function(context) {
				  const value = context.raw;
				  const total = context.dataset.data.reduce((a, b) => a + b, 0);
				  const percentage = ((value / total) * 100).toFixed(1);
				  return `${context.label}: ${value.toLocaleString()}kg (${percentage}%)`;
				}
			  }
			},
			title: {
			  display: true,
			  text: "",
			  color: "#FFDD77",
			  font: { size: 16, weight: "bold" },
			  padding: { top: 10, bottom: 20 }
			}
		  }
		}
	  });
	}

	/**
	 * Closes the Total Volume Distribution Modal & destroys the chart.
	 */
	function closeTotalVolumeDistributionModal() {
	  document.getElementById("totalVolumeDistributionOverlay").classList.remove("active");
	  if (totalVolumeDistributionChart) {
		totalVolumeDistributionChart.destroy();
		totalVolumeDistributionChart = null;
	  }
	}
	
    /*
      =======================================
      = 22) Exercise Creation	            =
      =======================================
    */
	
	// Global variables
	let currentWorkoutDateKey = null;
	let exerciseSelectionCallback = null;
	let selectedExercises = new Set();

	// Exercise Selection Modal
	function openExerciseSelectionModal(callback) {
	  // 1) Store callback
	  exerciseSelectionCallback = callback;
	  selectedExercises.clear();

	  // 2) Bring this overlay to the top
	  openModalOnTop("exerciseSelectionOverlay");

	  // 3) Grab references
	  const list = document.getElementById("exerciseSelectionList");
	  const searchInput = document.getElementById("exerciseSearchInput");

	  // 4) Clear previous content
	  list.innerHTML = '';
	  searchInput.value = '';

	  // 5) Populate list
	  populateExerciseList();

	  // 6) Optionally focus search
	  searchInput.focus();
	}

	function populateExerciseList(searchTerm = '') {
	  const list = document.getElementById('exerciseSelectionList');
	  list.innerHTML = '';
	  
	  const filteredExercises = searchTerm 
		? exerciseTemplates.filter(ex => 
			ex.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
			ex.primary_muscle_group.toLowerCase().includes(searchTerm.toLowerCase()))
		: exerciseTemplates;

	  filteredExercises.forEach(exercise => {
		const div = document.createElement('div');
		div.className = `exercise-option ${selectedExercises.has(exercise.id) ? 'selected' : ''}`;
		div.setAttribute('data-exercise-id', exercise.id);
		div.innerHTML = `
		  <div class="title">${exercise.title}</div>
		  <div class="details">
			${exercise.primary_muscle_group.charAt(0).toUpperCase() + 
			exercise.primary_muscle_group.slice(1)} ¬∑ ${exercise.equipment || 'No equipment'}
		  </div>
		`;
		
		div.addEventListener('click', () => {
		  toggleExerciseSelection(exercise.id, div);
		});
		
		list.appendChild(div);
	  });
	}

	function toggleExerciseSelection(exerciseId, element) {
	  if (selectedExercises.has(exerciseId)) {
		selectedExercises.delete(exerciseId);
		element.classList.remove('selected');
	  } else {
		selectedExercises.add(exerciseId);
		element.classList.add('selected');
	  }
	}

	function closeExerciseSelectionModal() {
	  document.getElementById('exerciseSelectionOverlay').classList.remove('active');
	  selectedExercises.clear();
	  exerciseSelectionCallback = null;
	}

	// Initialize workout creation functionality
	function initWorkoutCreation() {
	  // Add the create workout button to the toolbar
	  const importBtn = document.getElementById('hevyImportBtn');
	  const createBtn = document.createElement('button');
	  createBtn.className = 'arrow-button';
	  createBtn.id = 'createWorkoutBtn';
	  createBtn.title = 'Create Workout';
	  createBtn.innerHTML = '+';
	  importBtn.parentNode.insertBefore(createBtn, importBtn.nextSibling);

	  // Add the edit workout button
	  const editBtn = document.createElement('button');
	  editBtn.className = 'arrow-button';
	  editBtn.id = 'editWorkoutBtn';
	  editBtn.title = 'Edit Workout';
	  editBtn.innerHTML = '‚úé';
	  importBtn.parentNode.insertBefore(editBtn, createBtn.nextSibling);

	  // Event listeners for the create workout button
	  createBtn.addEventListener('click', () => {
		if (selectedDates.size !== 1) {
		  showCustomAlert('Please select exactly one day to create a workout.');
		  return;
		}
		isEditingWorkout = false;
		editingWorkoutId = null;
		openCreateWorkoutModal([...selectedDates][0]);
	  });

	  // Event listener for edit workout button
	  editBtn.addEventListener('click', () => {
	  if (selectedDates.size !== 1) {
		showCustomAlert('Please select exactly one day to edit a workout.');
		return;
	  }
	  const dateKey = [...selectedDates][0];
	  const dayData = getDayData(dateKey);
	  
	  if (!dayData.hevyWorkouts || dayData.hevyWorkouts.length === 0) {
		showCustomAlert('No workout found on the selected day to edit.');
		return;
	  }
	  
	  // If multiple workouts exist, show selection modal
	  if (dayData.hevyWorkouts.length > 1) {
		// Create and show the workout selection overlay
		let html = `
		  <div class="overlay" id="workoutSelectionOverlay">
			<div class="modal" style="width: 400px; padding: 1.5rem;">
			  <h2 style="text-align: center; margin-bottom: 1rem; color: #EAEAEA;">Select Workout to Edit</h2>
			  <div style="display: flex; flex-direction: column; gap: 0.75rem;">
		`;
		
		dayData.hevyWorkouts.forEach((workout, index) => {
		  const workoutTime = new Date(workout.start_time).toLocaleTimeString('en-US', {
			hour: 'numeric',
			minute: '2-digit',
			hour12: true
		  });
		  
		  html += `
			<div class="workout-option" data-workout-id="${workout.id}"
				 style="background: #393939; padding: 1rem; border-radius: 6px; cursor: pointer;
						transition: all 0.2s; display: flex; justify-content: space-between;
						align-items: center;">
			  <span style="color: #4DAAFF; font-weight: 500;">
				${workout.title || `Workout ${index + 1}`}
			  </span>
			  <span style="color: #888;">${workoutTime}</span>
			</div>
		  `;
		});
		
		html += `
			  </div>
			</div>
		  </div>
		`;
		
		// Add the modal to the document
		const tempDiv = document.createElement('div');
		tempDiv.innerHTML = html;
		document.body.appendChild(tempDiv.firstElementChild);
		
		// Show the modal
		const overlay = document.getElementById('workoutSelectionOverlay');
		openModalOnTop("workoutSelectionOverlay");
		
		// Add click handlers
		overlay.addEventListener('click', (e) => {
		  const option = e.target.closest('.workout-option');
		  if (option) {
			const selectedId = option.getAttribute('data-workout-id');
			isEditingWorkout = true;
			editingWorkoutId = selectedId;
			overlay.remove();
			openCreateWorkoutModal(dateKey);
		  }
		});
		
		// Add hover effects
		const options = overlay.querySelectorAll('.workout-option');
		options.forEach(option => {
		  option.addEventListener('mouseenter', () => {
			option.style.background = '#424242';
			option.style.transform = 'translateY(-2px)';
		  });
		  option.addEventListener('mouseleave', () => {
			option.style.background = '#393939';
			option.style.transform = 'translateY(0)';
		  });
		});
	  } else {
		// Single workout - edit it directly
		isEditingWorkout = true;
		editingWorkoutId = dayData.hevyWorkouts[0].id;
		openCreateWorkoutModal(dateKey);
	  }
	});

	  // Initialize search functionality
	  document.getElementById('exerciseSearchInput').addEventListener('input', (e) => {
		populateExerciseList(e.target.value.trim());
	  });

	  // Exercise selection modal buttons
	  document.getElementById('exerciseSelectionSaveBtn').addEventListener('click', () => {
		if (selectedExercises.size === 0) {
		  showCustomAlert('Please select at least one exercise.');
		  return;
		}
		if (exerciseSelectionCallback) {
		  const exercises = Array.from(selectedExercises)
			.map(id => exerciseTemplates.find(t => t.id === id))
			.filter(ex => ex !== undefined);
		  exerciseSelectionCallback(exercises);
		}
		closeExerciseSelectionModal();
	  });

	  document.getElementById('exerciseSelectionCancelBtn').addEventListener('click', closeExerciseSelectionModal);

	  // Initialize other event listeners
	  initCreateWorkoutModalListeners();
	}

	function openCreateWorkoutModal(dateKey) {
	  currentWorkoutDateKey = dateKey;
	  const date = parseDateKey(dateKey);
	  
	  // Set default start/end times - now using local timezone
	  let startTime = new Date(date);
	  startTime.setHours(9, 0, 0, 0);
	  let endTime = new Date(date);
	  endTime.setHours(10, 0, 0, 0);
	  
	  let title = '';
	  
	  // If editing, populate with existing workout data
	  if (isEditingWorkout) {
		const dayData = getDayData(dateKey);
		const workout = dayData.hevyWorkouts.find(w => w.id === editingWorkoutId);
		
		if (workout) {
		  // Convert UTC timestamps to local date objects
		  startTime = new Date(workout.start_time);
		  endTime = new Date(workout.end_time);
		  title = workout.title;
		}
	  }
	  
	  // Format datetime-local inputs in the correct format (YYYY-MM-DDThh:mm)
	  const formatDateTimeLocal = (date) => {
		return new Date(date.getTime() - (date.getTimezoneOffset() * 60000))
		  .toISOString()
		  .slice(0, 16);
	  };
	  
	  // Update modal fields
	  document.getElementById('workoutTitleInput').value = title;
	  document.getElementById('workoutStartTime').value = formatDateTimeLocal(startTime);
	  document.getElementById('workoutEndTime').value = formatDateTimeLocal(endTime);
	  
	  // Clear exercises list
	  document.getElementById('exercisesList').innerHTML = '';
	  
	  // If editing, populate exercises
	  if (isEditingWorkout) {
		const dayData = getDayData(dateKey);
		const workout = dayData.hevyWorkouts.find(w => w.id === editingWorkoutId);
		
		if (workout && workout.exercises) {
		  workout.exercises.forEach(exercise => {
			const template = exerciseTemplates.find(t => t.id === exercise.exercise_template_id);
			if (template) {
			  const block = addExerciseBlock(template);
			  
			  if (block) {
				// Remove the default empty set
				const setsList = block.querySelector('.sets-list');
				if (setsList) {
				  setsList.innerHTML = '';
				  
				  // Add existing sets
				  exercise.sets.forEach(set => {
					addExistingSet(block, set);
				  });
				}
			  }
			}
		  });
		}
	  }
	  
	  // Show modal
	  openModalOnTop("createWorkoutOverlay");
	  
	  // Update header date
	  const dateEl = document.querySelector('#createWorkoutModal .workout-date');
	  if (dateEl) {
		dateEl.textContent = date.toLocaleDateString('en-US', {
		  weekday: 'long',
		  year: 'numeric',
		  month: 'long',
		  day: 'numeric'
		});
	  }
	  
	  // Update modal title based on mode
	  const modalTitle = document.querySelector('#createWorkoutModal h2');
	  if (modalTitle) {
		modalTitle.textContent = isEditingWorkout ? 'Edit Workout' : 'Create Workout';
	  }
	}

	function closeCreateWorkoutModal() {
	  document.getElementById('createWorkoutOverlay').classList.remove('active');
	  currentWorkoutDateKey = null;
	}

	function initCreateWorkoutModalListeners() {
	  // Add Exercise button
	  document.getElementById('addExerciseBtn').addEventListener('click', () => {
		openExerciseSelectionModal((exercises) => {
		  exercises.forEach((exercise, index) => {
			addExerciseBlock(exercise);
		  });
		});
	  });
	  
	  // Save and Cancel buttons
	  document.getElementById('createWorkoutSaveBtn').addEventListener('click', saveWorkout);
	  document.getElementById('createWorkoutCancelBtn').addEventListener('click', closeCreateWorkoutModal);
	  
	  // Exercise list event delegation
	  document.getElementById('exercisesList').addEventListener('click', handleExerciseListClicks);
	}

	function addExerciseBlock(exercise) {
	  const template = document.getElementById('exerciseTemplate');
	  const clone = template.content.cloneNode(true);
	  const container = document.getElementById('exercisesList');
	  
	  // Set exercise title and data
	  clone.querySelector('.exercise-title').textContent = exercise.title;
	  const block = clone.querySelector('.exercise-block');
	  block.setAttribute('data-exercise-id', exercise.id);
	  block.setAttribute('data-exercise-type', exercise.type);
	  block.setAttribute('data-exercise-index', container.children.length);
	  
	  container.appendChild(block);
	  addSetToExercise(block);
	  return block;  // Return the block element
	}

	function handleExerciseListClicks(e) {
	  // Remove exercise button
	  if (e.target.closest('.remove-exercise-btn')) {
		const block = e.target.closest('.exercise-block');
		if (block) {
		  block.remove();
		  // Reindex remaining exercises
		  reindexExercises();
		}
	  }
	  
	  // Add set button
	  if (e.target.closest('.add-set-btn')) {
		const block = e.target.closest('.exercise-block');
		addSetToExercise(block);
	  }
	  
	  // Remove set button
	  if (e.target.closest('.remove-set-btn')) {
		const setRow = e.target.closest('.set-row');
		if (setRow) {
		  const block = setRow.closest('.exercise-block');
		  setRow.remove();
		  // Only renumber sets if the block still exists
		  if (block) {
			renumberSets(block);
		  }
		}
	  }
	}

	function reindexExercises() {
	  const blocks = document.querySelectorAll('.exercise-block');
	  blocks.forEach((block, index) => {
		block.setAttribute('data-exercise-index', index);
	  });
	}

	function addSetToExercise(block) {
	  const exerciseType = block.getAttribute('data-exercise-type');
	  const template = getSetTemplate(exerciseType);
	  const clone = template.content.cloneNode(true);
	  const setsList = block.querySelector('.sets-list');
	  setsList.appendChild(clone);
	  
	  // Initialize time inputs for duration-based exercises
	  if (exerciseType === 'distance_duration' || exerciseType === 'duration') {
		initTimeInputs(setsList.lastElementChild);
	  }
	  
	  // For bodyweight exercises, no pre-filling is required now since the bodyweight input was removed.
	  
	  renumberSets(block);
	}

	function renumberSets(block) {
	  if (!block) return; // Guard clause to prevent null reference
	  
	  // Find the sets-list container first
	  const setsList = block.querySelector('.sets-list');
	  if (!setsList) return; // Guard clause if sets-list not found
	  
	  // Get all set rows within this specific sets-list
	  const sets = setsList.querySelectorAll('.set-row');
	  sets.forEach((set, index) => {
		const numberElement = set.querySelector('.set-number');
		if (numberElement) {
		  numberElement.textContent = `Set ${index + 1}`;
		}
		set.setAttribute('data-set-index', index);
	  });
	}

	function saveWorkout() {
	  // Get basic workout info
	  const title = document.getElementById('workoutTitleInput').value.trim();
	  const startTime = document.getElementById('workoutStartTime').value;
	  const endTime = document.getElementById('workoutEndTime').value;
	  
	  // Validation
	  if (!title || !startTime || !endTime) {
		showCustomAlert('Please fill in all required workout fields.');
		return;
	  }

	  if (new Date(endTime) <= new Date(startTime)) {
		showCustomAlert('End time must be after start time.');
		return;
	  }

	  // Generate new ID only if creating
	  const workoutId = isEditingWorkout ? editingWorkoutId : 
		'LOCAL_' + Math.random().toString(36).substring(2) + Date.now().toString(36);
		
	  const exercises = [];
	  const exerciseBlocks = document.querySelectorAll('.exercise-block');
	  let isValid = true;

	  exerciseBlocks.forEach(block => {
		const exerciseId = block.getAttribute('data-exercise-id');
		const exerciseType = block.getAttribute('data-exercise-type');
		const exerciseIndex = parseInt(block.getAttribute('data-exercise-index'));
		const exerciseTemplate = exerciseTemplates.find(t => t.id === exerciseId);
		
		if (!exerciseTemplate) {
		  isValid = false;
		  showCustomAlert('Invalid exercise selection.');
		  return;
		}

		const setRows = block.querySelectorAll('.set-row');
		if (setRows.length === 0) {
		  isValid = false;
		  showCustomAlert(`Each exercise must have at least one set. Please add a set to ${exerciseTemplate.title}.`);
		  return;
		}

		const sets = [];
		setRows.forEach((setRow, idx) => {
		  let setData;

		  try {
			setData = {
			  index: idx,
			  type: "normal",
			  ...getSetData(setRow, exerciseType)
			};
		  } catch (error) {
			isValid = false;
			showCustomAlert(`Error processing set data for ${exerciseTemplate.title}: ${error.message}`);
			return;
		  }

		  if (!validateSetData(setData, exerciseType)) {
			isValid = false;
			if (exerciseType === 'duration') {
			  showCustomAlert(`Please fill in a valid duration for all sets in ${exerciseTemplate.title}.`);
			} else if (exerciseType === 'distance_duration') {
			  showCustomAlert(`Please fill in valid distance and duration for all sets in ${exerciseTemplate.title}.`);
			} else {
			  showCustomAlert(`Please fill in valid weight and reps for all sets in ${exerciseTemplate.title}.`);
			}
			return;
		  }

		  sets.push(setData);
		});

		if (!isValid) return;

		exercises.push({
		  index: exerciseIndex,
		  title: exerciseTemplate.title,
		  notes: "",
		  exercise_template_id: exerciseId,
		  superset_id: null,
		  sets: sets
		});
	  });

	  if (!isValid) return;
	  if (exercises.length === 0) {
		showCustomAlert('Please add at least one exercise to the workout.');
		return;
	  }

	  exercises.sort((a, b) => a.index - b.index);

	  const workout = {
		id: workoutId,
		title: title,
		description: null,
		start_time: new Date(startTime).toISOString(),
		end_time: new Date(endTime).toISOString(),
		created_at: isEditingWorkout ? 
		  calendarData[currentWorkoutDateKey].hevyWorkouts.find(w => w.id === workoutId).created_at : 
		  new Date().toISOString(),
		updated_at: new Date().toISOString(),
		exercises: exercises
	  };

	  const dayData = getDayData(currentWorkoutDateKey);
	  if (!dayData.hevyWorkouts) {
		dayData.hevyWorkouts = [];
	  }
	  
	  if (isEditingWorkout) {
		// Replace the existing workout
		const workoutIndex = dayData.hevyWorkouts.findIndex(w => w.id === workoutId);
		if (workoutIndex !== -1) {
		  dayData.hevyWorkouts[workoutIndex] = workout;
		}
	  } else {
		// Add new workout
		dayData.hevyWorkouts.push(workout);
	  }
	  
	  dayData.completed = true;
	  
	  setDayData(currentWorkoutDateKey, dayData);
	  closeCreateWorkoutModal();
	  renderCalendar(currentYear, currentMonth);
	  showCustomAlert(isEditingWorkout ? 'Workout updated successfully!' : 'Workout created successfully!');
	}

	// Initialize everything when DOM loads
	document.addEventListener('DOMContentLoaded', () => {
	  initWorkoutCreation();
	});
	
    /*
      =======================================
      = 23) Distance_Duration Exercises     =
      =======================================
    */
	
	function getCardioStats(exerciseName) {
	  let totalDistance = 0;
	  let totalDuration = 0;
	  let longestSetDistance = 0;
	  let longestSetDuration = 0;
	  let longestSetDate = null;
	  let longestDurationDate = null;
	  let bestPace5kPlus = Infinity;
	  let bestPace5kDate = null;
	  let longestSessionDistance = 0;
	  let longestSessionDate = null;
	  let longestSessionDuration = 0;
	  let longestSessionDurationDate = null;
	  let totalOccurrences = 0;

	  // For ‚Äúbest pace by distance,‚Äù we‚Äôll store these distances (in meters) and track the best pace:
	  const distanceSegments = [
		{ dist: 60,    label: '60m+' },
		{ dist: 100,   label: '100m+' },
		{ dist: 400,   label: '400m+' },
		{ dist: 800,   label: '800m+' },
		{ dist: 1000,  label: '1km+' },
		{ dist: 2000,  label: '2km+' },
		{ dist: 3000,  label: '3km+' },
		{ dist: 4000,  label: '4km+' },
		{ dist: 5000,  label: '5km+' },
		{ dist: 10000, label: '10km+' },
		{ dist: 21100, label: '21.1km+' },    // Half Marathon
		{ dist: 42195, label: '42.195km+' }  // Full Marathon
	  ];
	  // We'll store best pace in min/km (as a float) + the dateKey
	  const bestPacesByDistance = {};
	  distanceSegments.forEach(seg => {
		bestPacesByDistance[seg.dist] = {
		  paceValue: Infinity,  // the numeric pace in min/km
		  dateKey: null
		};
	  });

	  // Now loop over the calendar data for this exercise
	  Object.entries(calendarData).forEach(([dateKey, dayData]) => {
		if (!dayData.hevyWorkouts) return;

		dayData.hevyWorkouts.forEach(workout => {
		  let sessionDistance = 0;
		  let sessionDuration = 0;

		  workout.exercises.forEach(exercise => {
			if (exercise.title === exerciseName) {
			  totalOccurrences++;

			  exercise.sets.forEach(set => {
				if (!set.distance_meters || !set.duration_seconds) return;

				const dist = set.distance_meters;
				const dur = set.duration_seconds;
				totalDistance += dist;
				totalDuration += dur;

				sessionDistance += dist;
				sessionDuration += dur;

				// Longest single-set distance
				if (dist > longestSetDistance) {
				  longestSetDistance = dist;
				  longestSetDate = workout.start_time;
				}
				// Longest single-set duration
				if (dur > longestSetDuration) {
				  longestSetDuration = dur;
				  longestDurationDate = workout.start_time;
				}

				// Best pace for sets >= 5km
				if (dist >= 5000) {
				  const paceSecPerKm = dur / (dist / 1000); // seconds/km
				  if (paceSecPerKm < bestPace5kPlus) {
					bestPace5kPlus = paceSecPerKm;
					bestPace5kDate = workout.start_time;
				  }
				}

				// Also update bestPacesByDistance
				distanceSegments.forEach(seg => {
				  if (dist >= seg.dist) {
					// paceSecPerKm:
					const paceSecPerKm = dur / (dist / 1000);
					// convert to min/km
					const paceMinPerKm = paceSecPerKm / 60;
					if (paceMinPerKm < bestPacesByDistance[seg.dist].paceValue) {
					  bestPacesByDistance[seg.dist].paceValue = paceMinPerKm;
					  bestPacesByDistance[seg.dist].dateKey = getDateKey(new Date(workout.start_time));
					}
				  }
				});
			  });
			}
		  });

		  // After all sets in this workout
		  if (sessionDistance > longestSessionDistance) {
			longestSessionDistance = sessionDistance;
			longestSessionDate = workout.start_time;
		  }
		  if (sessionDuration > longestSessionDuration) {
			longestSessionDuration = sessionDuration;
			longestSessionDurationDate = workout.start_time;
		  }
		});
	  });

	  // If we never set bestPace5kPlus, leave it null
	  if (bestPace5kPlus === Infinity) bestPace5kPlus = null;

	  const stats = {
		totalOccurrences,
		longestSetDistance,
		longestSetDate,
		longestSetDuration,
		longestDurationDate,
		bestPace5kPlus,   // in sec/km if not null
		bestPace5kDate,
		longestSessionDistance,
		longestSessionDate,
		longestSessionDuration,
		longestSessionDurationDate,
		totalDistance,
		totalDuration,
		bestPacesByDistance // { 60: { paceValue, dateKey }, 100: { ... }, ... }
	  };

	  return stats;
	}
	
	function openDistanceProgressionModal(exerciseName, dateKey) {
	  openModalOnTop("exerciseProgressOverlay");
	  
	  const dateObj = parseDateKey(dateKey);
	  const dateLabel = `${dateObj.getDate()} ${monthNames[dateObj.getMonth()]}, ${dateObj.getFullYear()}`;
	  document.getElementById("exerciseProgressionModalDate").textContent = dateLabel;

	  // Store current exercise info for range button updates
	  currentProgressionExercise = exerciseName;
	  currentProgressionDateKey = dateKey;

	  buildDistanceProgressionChart(exerciseName, dateKey);
	  buildPaceProgressionChart(exerciseName, dateKey);

	  // Set up range button handlers
	  document.querySelectorAll('#exerciseProgressionModal .date-range-btn').forEach(btn => {
		const existingListener = btn.getAttribute('distance-listener');
		if (!existingListener) {
		  btn.addEventListener('click', () => {
			if (!btn.classList.contains('active')) {
			  document.querySelectorAll('#exerciseProgressionModal .date-range-btn')
				.forEach(b => b.classList.remove('active'));
			  btn.classList.add('active');
			  
			  buildDistanceProgressionChart(currentProgressionExercise, currentProgressionDateKey);
			  buildPaceProgressionChart(currentProgressionExercise, currentProgressionDateKey);
			}
		  });
		  btn.setAttribute('distance-listener', 'true');
		}
	  });
	}

	function buildDistanceProgressionChart(exerciseName, dateKey) {
	  const selectedRange = document.querySelector('#exerciseProgressionModal .date-range-btn.active').getAttribute('data-range');
	  const refDate = parseDateKey(dateKey);
	  const { start, end } = getDateRangeBounds(selectedRange, refDate);
	  
	  const dateKeys = Object.keys(calendarData)
		.filter(key => {
		  const date = parseDateKey(key);
		  return date >= start && date <= end;
		})
		.sort();

	  const dataMap = {};

	  // Collect max distance for each day
	  dateKeys.forEach(k => {
		const dayObj = calendarData[k];
		if (dayObj.hevyWorkouts && dayObj.hevyWorkouts.length > 0) {
		  let maxDistanceForDay = 0;
		  dayObj.hevyWorkouts.forEach(workout => {
			workout.exercises.forEach(ex => {
			  if (ex.title === exerciseName) {
				ex.sets.forEach(s => {
				  if (s.distance_meters > maxDistanceForDay) {
					maxDistanceForDay = s.distance_meters;
				  }
				});
			  }
			});
		  });
		  if (maxDistanceForDay > 0) {
			dataMap[k] = maxDistanceForDay;
		  }
		}
	  });

	  const chartKeys = Object.keys(dataMap).sort();
	  if (chartKeys.length < 1) {
		destroyExerciseWeightProgressChart();
		showCustomAlert("No distance progression data found.");
		return;
	  }

	  const dataPoints = chartKeys.map(k => ({ x: k, y: dataMap[k] / 1000 })); // Convert to km
	  const labels = chartKeys.map(k => {
		const d = parseDateKey(k);
		return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
	  });

	  const distances = dataPoints.map(dp => dp.y);
	  const minDistance = Math.min(...distances);
	  const maxDistance = Math.max(...distances);
	  const suggestedMin = Math.max(0, minDistance - 0.5);
	  const suggestedMax = maxDistance + 0.5;

	  destroyExerciseWeightProgressChart();
	  const ctx = document.getElementById('exerciseWeightProgressionChart').getContext('2d');

	  const { bgColors, borderColors, pointRadii } = buildHighlightArrays(
		dataPoints, dateKey, '#4DAAFF', '#FFDD77', 2.5, 5
	  );

	  exerciseWeightProgressionChart = new Chart(ctx, {
		type: 'line',
		data: {
		  labels: labels,
		  datasets: [{
			label: exerciseName,
			data: dataPoints.map(dp => dp.y),
			borderColor: '#4DAAFF',
			backgroundColor: 'rgba(77, 169, 255,0.2)',
			fill: true,
			tension: 0.1,
			pointRadius: pointRadii,
			pointBackgroundColor: bgColors,
			pointBorderColor: borderColors,
			pointHoverRadius: 6
		  }]
		},
		options: {
		  responsive: true,
		  maintainAspectRatio: false,
		  scales: {
			x: {
			  title: { display: true, text: 'Date' },
			  ticks: { color: '#ccc' },
			  grid: { color: '#555' }
			},
			y: {
			  suggestedMin,
			  suggestedMax,
			  title: { display: true, text: 'Distance (km)' },
			  ticks: { color: '#ccc' },
			  grid: { color: '#555' }
			}
		  },
		  plugins: {
			legend: { labels: { color: '#eee' } },
			title: {
			  display: true,
			  text: 'Distance Progression',
			  color: '#fff',
			  font: { size: 16 }
			}
		  }
		}
	  });
	}

	function buildPaceProgressionChart(exerciseName, dateKey) {
	  const selectedRange = document.querySelector('#exerciseProgressionModal .date-range-btn.active').getAttribute('data-range');
	  const refDate = parseDateKey(dateKey);
	  const { start, end } = getDateRangeBounds(selectedRange, refDate);
	  
	  const dateKeys = Object.keys(calendarData)
		.filter(key => {
		  const date = parseDateKey(key);
		  return date >= start && date <= end;
		})
		.sort();

	  const dataMap = {};

	  // Collect best pace (min/km) for each day
	  dateKeys.forEach(k => {
		const dayObj = calendarData[k];
		if (dayObj.hevyWorkouts && dayObj.hevyWorkouts.length > 0) {
		  let bestPaceForDay = Infinity;
		  dayObj.hevyWorkouts.forEach(workout => {
			workout.exercises.forEach(ex => {
			  if (ex.title === exerciseName) {
				ex.sets.forEach(s => {
				  if (s.distance_meters >= 1000) { // Only consider segments of 1km or more
					const paceMinPerKm = (s.duration_seconds / 60) / (s.distance_meters / 1000);
					if (paceMinPerKm < bestPaceForDay) {
					  bestPaceForDay = paceMinPerKm;
					}
				  }
				});
			  }
			});
		  });
		  if (bestPaceForDay < Infinity) {
			dataMap[k] = bestPaceForDay;
		  }
		}
	  });

	  const chartKeys = Object.keys(dataMap).sort();
	  if (chartKeys.length < 1) {
		destroyExerciseRepProgressChart();
		showCustomAlert("No pace progression data found.");
		return;
	  }

	  const dataPoints = chartKeys.map(k => ({ x: k, y: dataMap[k] }));
	  const labels = chartKeys.map(k => {
		const d = parseDateKey(k);
		return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
	  });

	  const paces = dataPoints.map(dp => dp.y);
	  const minPace = Math.min(...paces);
	  const maxPace = Math.max(...paces);
	  const suggestedMin = Math.max(0, minPace - 0.5);
	  const suggestedMax = maxPace + 0.5;

	  destroyExerciseRepProgressChart();
	  const ctx = document.getElementById('exerciseRepProgressionChart').getContext('2d');

	  const { bgColors, borderColors, pointRadii } = buildHighlightArrays(
		dataPoints, dateKey, '#FFDD77', '#4DAAFF', 2.5, 5
	  );

	  exerciseRepProgressionChart = new Chart(ctx, {
		type: 'line',
		data: {
		  labels: labels,
		  datasets: [{
			label: exerciseName,
			data: dataPoints.map(dp => dp.y),
			borderColor: '#FFDD77',
			backgroundColor: 'rgba(255, 221, 119,0.2)',
			fill: true,
			tension: 0.1,
			pointRadius: pointRadii,
			pointBackgroundColor: bgColors,
			pointBorderColor: borderColors,
			pointHoverRadius: 6
		  }]
		},
		options: {
		  responsive: true,
		  maintainAspectRatio: false,
		  scales: {
			x: {
			  title: { display: true, text: 'Date' },
			  ticks: { color: '#ccc' },
			  grid: { color: '#555' }
			},
			y: {
			  suggestedMin,
			  suggestedMax,
			  title: { display: true, text: 'Pace (min/km)' },
			  ticks: {
				color: '#ccc',
				callback: function(value) {
				  return formatPace(1000, value * 60) + '/km';
				}
			  },
			  grid: { color: '#555' }
			}
		  },
		  plugins: {
			legend: { labels: { color: '#eee' } },
			title: {
			  display: true,
			  text: 'Pace Progression (Best Pace per Day)',
			  color: '#fff',
			  font: { size: 16 }
			},
			tooltip: {
			  callbacks: {
				label: function(context) {
				  const pace = context.raw;
				  return `Pace: ${formatPace(1000, pace * 60)}/km`;
				}
			  }
			}
		  }
		}
	  });
	}

	// Distance over time chart
	function openDistanceOverTimeModal(exerciseName, dateKey) {
	  openModalOnTop("exerciseVolumeOverlay");
	  
	  // Store these for range button updates
	  currentExerciseVolumeName = exerciseName;
	  currentExerciseVolumeDateKey = dateKey;
	  
	  buildDistanceOverTimeChart(exerciseName, dateKey);
	}

	function buildDistanceOverTimeChart(exerciseName, dateKey) {
	  const selectedRange = document.querySelector('#exerciseVolumeModal .date-range-btn.active').getAttribute('data-range');
	  const refDate = parseDateKey(dateKey);
	  const { start, end } = getDateRangeBounds(selectedRange, refDate);
	  
	  const dateKeys = Object.keys(calendarData)
		.filter(key => {
		  const date = parseDateKey(key);
		  return date >= start && date <= end;
		})
		.sort();

	  const dataMap = {};

	  // Calculate total distance for each day
	  dateKeys.forEach(k => {
		const dayObj = calendarData[k];
		if (dayObj.hevyWorkouts && dayObj.hevyWorkouts.length > 0) {
		  let totalDistanceForDay = 0;
		  let totalDurationForDay = 0;
		  
		  dayObj.hevyWorkouts.forEach(workout => {
			workout.exercises.forEach(ex => {
			  if (ex.title === exerciseName) {
				ex.sets.forEach(s => {
				  totalDistanceForDay += s.distance_meters;
				  totalDurationForDay += s.duration_seconds;
				});
			  }
			});
		  });
		  
		  if (totalDistanceForDay > 0) {
			dataMap[k] = {
			  distance: totalDistanceForDay,
			  duration: totalDurationForDay
			};
		  }
		}
	  });

	  const chartKeys = Object.keys(dataMap).sort();
	  if (chartKeys.length < 1) {
		destroyExerciseVolumeChart();
		showCustomAlert("No distance data found for this time period.");
		return;
	  }

	  const dataPoints = chartKeys.map(k => ({
		x: k,
		y: dataMap[k].distance / 1000, // Convert to km
		duration: dataMap[k].duration
	  }));
	  
	  const labels = chartKeys.map(k => {
		const d = parseDateKey(k);
		return d.toLocaleDateString('en-US', {
		  month: 'short',
		  day: 'numeric',
		  year: 'numeric'
		});
	  });

	  const distances = dataPoints.map(dp => dp.y);
	  const minDistance = Math.min(...distances);
	  const maxDistance = Math.max(...distances);
	  const range = maxDistance - minDistance;
	  const padding = range * 0.1;
	  const suggestedMin = Math.max(0, minDistance - padding);
	  const suggestedMax = maxDistance + padding;

	  destroyExerciseVolumeChart();
	  const ctx = document.getElementById('exerciseVolumeChart').getContext('2d');

	  const { bgColors, borderColors, pointRadii } = buildHighlightArrays(
		dataPoints,
		dateKey,
		'#4DAAFF',
		'#FFDD77',
		2.5,
		5
	  );

	  exerciseVolumeChart = new Chart(ctx, {
		type: 'line',
		data: {
		  labels: labels,
		  datasets: [{
			label: `Distance: ${exerciseName}`,
			data: dataPoints.map(dp => dp.y),
			borderColor: '#4DAAFF',
			backgroundColor: 'rgba(77, 170, 255,0.2)',
			fill: true,
			tension: 0.1,
			pointRadius: pointRadii,
			pointBackgroundColor: bgColors,
			pointBorderColor: borderColors,
			pointHoverRadius: 6
		  }]
		},
		options: {
		  responsive: true,
		  maintainAspectRatio: false,
		  scales: {
			x: {
			  title: { display: true, text: 'Date' },
			  ticks: { color: '#ccc' },
			  grid: { color: '#555' }
			},
			y: {
			  suggestedMin,
			  suggestedMax,
			  title: { display: true, text: 'Distance (km)' },
			  ticks: { color: '#ccc' },
			  grid: { color: '#555' }
			}
		  },
		  plugins: {
			legend: { labels: { color: '#eee' } },
			tooltip: {
			  callbacks: {
				label: function(context) {
				  const index = context.dataIndex;
				  const distance = context.raw;
				  const duration = dataPoints[index].duration;
				  const pace = formatPace(distance * 1000, duration);
				  return [
					`Distance: ${distance.toFixed(2)}km`,
					`Duration: ${formatDuration(duration)}`,
					`Pace: ${pace}/km`
				  ];
				}
			  }
			}
		  }
		}
	  });
	}
	
	// Build distance chart showing total distance over time
	function buildDistanceTimeChart(exerciseName, highlightDateKey) {
	  const selectedRange = document.querySelector('#exerciseVolumeModal .date-range-btn.active').getAttribute('data-range');
	  const refDate = parseDateKey(highlightDateKey);
	  const { start, end } = getDateRangeBounds(selectedRange, refDate);
	  
	  const dateKeys = Object.keys(calendarData)
		.filter(key => {
		  const date = parseDateKey(key);
		  return date >= start && date <= end;
		})
		.sort();

	  const dataMap = {};

	  // Calculate total distance for each day
	  dateKeys.forEach(k => {
		const dayObj = calendarData[k];
		if (dayObj.hevyWorkouts && dayObj.hevyWorkouts.length > 0) {
		  let totalDistanceForDay = 0;
		  
		  dayObj.hevyWorkouts.forEach(workout => {
			workout.exercises.forEach(ex => {
			  if (ex.title === exerciseName) {
				ex.sets.forEach(s => {
				  if (s.distance_meters) {
					totalDistanceForDay += s.distance_meters;
				  }
				});
			  }
			});
		  });
		  
		  if (totalDistanceForDay > 0) {
			dataMap[k] = totalDistanceForDay;
		  }
		}
	  });

	  const chartKeys = Object.keys(dataMap).sort();
	  if (chartKeys.length < 1) {
		destroyExerciseVolumeChart();
		showCustomAlert("No distance data found for this time period.");
		return;
	  }

	  const dataPoints = chartKeys.map(k => ({
		x: k,
		y: dataMap[k] / 1000 // Convert to km
	  }));
	  
	  const labels = chartKeys.map(k => {
		const d = parseDateKey(k);
		return d.toLocaleDateString('en-US', {
		  month: 'short',
		  day: 'numeric',
		  year: 'numeric'
		});
	  });

	  const distances = dataPoints.map(dp => dp.y);
	  const minDistance = Math.min(...distances);
	  const maxDistance = Math.max(...distances);
	  const range = maxDistance - minDistance;
	  const padding = range * 0.1;
	  const suggestedMin = Math.max(0, minDistance - padding);
	  const suggestedMax = maxDistance + padding;

	  destroyExerciseVolumeChart();
	  const ctx = document.getElementById('exerciseVolumeChart').getContext('2d');

	  const { bgColors, borderColors, pointRadii } = buildHighlightArrays(
		dataPoints,
		highlightDateKey,
		'#4DAAFF',
		'#FFDD77',
		2.5,
		5
	  );

	  exerciseVolumeChart = new Chart(ctx, {
		type: 'line',
		data: {
		  labels: labels,
		  datasets: [{
			label: `Total Distance: ${exerciseName}`,
			data: dataPoints.map(dp => dp.y),
			borderColor: '#4DAAFF',
			backgroundColor: 'rgba(77, 170, 255,0.2)',
			fill: true,
			tension: 0.1,
			pointRadius: pointRadii,
			pointBackgroundColor: bgColors,
			pointBorderColor: borderColors,
			pointHoverRadius: 6
		  }]
		},
		options: {
		  responsive: true,
		  maintainAspectRatio: false,
		  scales: {
			x: {
			  title: { display: true, text: 'Date' },
			  ticks: { color: '#ccc' },
			  grid: { color: '#555' }
			},
			y: {
			  suggestedMin,
			  suggestedMax,
			  title: { display: true, text: 'Distance (km)' },
			  ticks: { color: '#ccc' },
			  grid: { color: '#555' }
			}
		  },
		  plugins: {
			legend: { labels: { color: '#eee' } },
			title: {
			  display: true,
			  text: 'Total Distance Over Time',
			  color: '#fff',
			  font: { size: 16 }
			}
		  }
		}
	  });
	}

	// Build duration chart showing total duration over time
	function buildDurationTimeChart(exerciseName, highlightDateKey) {
	  const selectedRange = document.querySelector('#exerciseVolumeModal .date-range-btn.active').getAttribute('data-range');
	  const refDate = parseDateKey(highlightDateKey);
	  const { start, end } = getDateRangeBounds(selectedRange, refDate);
	  
	  const dateKeys = Object.keys(calendarData)
		.filter(key => {
		  const date = parseDateKey(key);
		  return date >= start && date <= end;
		})
		.sort();

	  const dataMap = {};

	  // Calculate total duration for each day
	  dateKeys.forEach(k => {
		const dayObj = calendarData[k];
		if (dayObj.hevyWorkouts && dayObj.hevyWorkouts.length > 0) {
		  let totalDurationForDay = 0;
		  
		  dayObj.hevyWorkouts.forEach(workout => {
			workout.exercises.forEach(ex => {
			  if (ex.title === exerciseName) {
				ex.sets.forEach(s => {
				  if (s.duration_seconds) {
					totalDurationForDay += s.duration_seconds;
				  }
				});
			  }
			});
		  });
		  
		  if (totalDurationForDay > 0) {
			dataMap[k] = totalDurationForDay;
		  }
		}
	  });

	  const chartKeys = Object.keys(dataMap).sort();
	  if (chartKeys.length < 1) {
		destroyExerciseVolumeChart();
		showCustomAlert("No duration data found for this time period.");
		return;
	  }

	  const dataPoints = chartKeys.map(k => ({
		x: k,
		y: dataMap[k] / 60 // Convert to minutes
	  }));
	  
	  const labels = chartKeys.map(k => {
		const d = parseDateKey(k);
		return d.toLocaleDateString('en-US', {
		  month: 'short',
		  day: 'numeric',
		  year: 'numeric'
		});
	  });

	  const durations = dataPoints.map(dp => dp.y);
	  const minDuration = Math.min(...durations);
	  const maxDuration = Math.max(...durations);
	  const range = maxDuration - minDuration;
	  const padding = range * 0.1;
	  const suggestedMin = Math.max(0, minDuration - padding);
	  const suggestedMax = maxDuration + padding;

	  destroyExerciseVolumeChart();
	  const ctx = document.getElementById('exerciseVolumeChart').getContext('2d');

	  const { bgColors, borderColors, pointRadii } = buildHighlightArrays(
		dataPoints,
		highlightDateKey,
		'#4DAAFF',
		'#FFDD77',
		2.5,
		5
	  );

	  exerciseVolumeChart = new Chart(ctx, {
		type: 'line',
		data: {
		  labels: labels,
		  datasets: [{
			label: `Total Duration: ${exerciseName}`,
			data: dataPoints.map(dp => dp.y),
			borderColor: '#4DAAFF',
			backgroundColor: 'rgba(77, 170, 255,0.2)',
			fill: true,
			tension: 0.1,
			pointRadius: pointRadii,
			pointBackgroundColor: bgColors,
			pointBorderColor: borderColors,
			pointHoverRadius: 6
		  }]
		},
		options: {
		  responsive: true,
		  maintainAspectRatio: false,
		  scales: {
			x: {
			  title: { display: true, text: 'Date' },
			  ticks: { color: '#ccc' },
			  grid: { color: '#555' }
			},
			y: {
			  suggestedMin,
			  suggestedMax,
			  title: { display: true, text: 'Duration (minutes)' },
			  ticks: { 
				color: '#ccc',
				callback: function(value) {
				  return formatDuration(value * 60);
				}
			  },
			  grid: { color: '#555' }
			}
		  },
		  plugins: {
			legend: { labels: { color: '#eee' } },
			title: {
			  display: true,
			  text: 'Total Duration Over Time',
			  color: '#fff',
			  font: { size: 16 }
			},
			tooltip: {
			  callbacks: {
				label: function(context) {
				  return `Duration: ${formatDuration(context.raw * 60)}`;
				}
			  }
			}
		  }
		}
	  });
	}
	
	function openExerciseDistanceModal(exerciseName, dateKey) {
	  // 1) Reset date-range buttons so "year" is active
	  const modalRangeBtns = document.querySelectorAll('#exerciseVolumeModal .date-range-btn');
	  modalRangeBtns.forEach(btn => {
		btn.classList.remove('active');
		if (btn.getAttribute('data-range') === 'year') {
		  btn.classList.add('active');
		}
	  });

	  // 2) Show the modal
	  openModalOnTop("exerciseVolumeOverlay");
	  document.getElementById("exerciseVolumeModal").querySelector("h2").textContent =
		"Distance Progression";
		
		currentExerciseVolumeName = exerciseName;
		currentExerciseVolumeDateKey = dateKey;

	  // 3) Build the default chart (uses 'year' range by default now)
	  buildDistanceTimeChart(exerciseName, dateKey);
	}

	function openExerciseDurationModal(exerciseName, dateKey) {
	  // 1) Reset date-range buttons so "year" is active
	  const modalRangeBtns = document.querySelectorAll('#exerciseVolumeModal .date-range-btn');
	  modalRangeBtns.forEach(btn => {
		btn.classList.remove('active');
		if (btn.getAttribute('data-range') === 'year') {
		  btn.classList.add('active');
		}
	  });

	  // 2) Show the modal
	  openModalOnTop("exerciseVolumeOverlay");
	  document.getElementById("exerciseVolumeModal").querySelector("h2").textContent =
		"Duration Progression";
		
		currentExerciseVolumeName = exerciseName;
		currentExerciseVolumeDateKey = dateKey;

	  // 3) Build the default chart (uses 'year' range by default now)
	  buildDurationTimeChart(exerciseName, dateKey);
	}
		
	function setupWorkoutContainerHandlers(container) {
	  container.addEventListener('click', (e) => {
		// Exercise title clicks
		const titleEl = e.target.closest(".hevy-exercise-title");
		if (titleEl) {
		  e.stopPropagation();
		  const exerciseName = titleEl.getAttribute("data-exercise");
		  openExerciseSummaryModal(exerciseName);
		  return;
		}

		// Get exercise type
		const setEl = e.target.closest(".hevy-set");
		if (setEl) {
		  e.stopPropagation();
		  const exerciseName = setEl.getAttribute("data-exercise");
		  const template = getExerciseTemplate(exerciseName);
		  const exerciseType = template ? template.type : 'weighted_reps';
		  
		  // Don't handle clicks for duration or distance_duration exercises
		  if (exerciseType === 'duration' || exerciseType === 'distance_duration') {
			return;
		  }

		  const weight = Number(setEl.getAttribute("data-weight"));
		  const reps = parseInt(setEl.getAttribute("data-reps"), 10);
		  const dateKey = setEl.getAttribute("data-date-key");
		  openExerciseProgressionModal(exerciseName, weight, reps, dateKey);
		  return;
		}

		// Volume/Distance clicks
		const volumeEl = e.target.closest(".hevy-exercise-volume");
		if (volumeEl) {
		  e.stopPropagation();
		  const exerciseName = volumeEl.getAttribute("data-exercise");
		  const template = getExerciseTemplate(exerciseName);
		  const exerciseType = template ? template.type : 'weighted_reps';
		  
		  const dateKey = volumeEl.getAttribute("data-date-key");
		  if (exerciseType === 'duration') {
			openTotalDurationModal(exerciseName, dateKey);
		  } else if (exerciseType === 'distance_duration') {
			openExerciseDistanceModal(exerciseName, dateKey);
		  } else {
			openExerciseVolumeModal(exerciseName, dateKey);
		  }
		  return;
		}

		// ORM/Duration clicks
		const ormEl = e.target.closest(".hevy-orm");
		if (ormEl) {
		  e.stopPropagation();
		  const exerciseName = ormEl.getAttribute("data-exercise");
		  const template = getExerciseTemplate(exerciseName);
		  const exerciseType = template ? template.type : 'weighted_reps';
		  
		  const dateKey = ormEl.getAttribute("data-date-key");
		  if (exerciseType === 'distance_duration') {
			openExerciseDurationModal(exerciseName, dateKey);
		  } else if (exerciseType !== 'duration') {
			openOrmProgressModal(exerciseName, dateKey);
		  }
		  return;
		}

		// Total volume clicks (workout level)
		const totalEl = e.target.closest(".hevy-total");
		if (totalEl) {
		  e.stopPropagation();
		  const dateKey = totalEl.getAttribute("data-date-key");
		  openVolumeModal(dateKey);
		  return;
		}
	  });
	}

	function getCardioPRs(exerciseName) {
	  let distancePR = null;  // { dateKey, workoutId, setIndex, distance, duration }
	  let durationPR = null;  // { dateKey, workoutId, setIndex, distance, duration }
	  let pacePR = null;      // { dateKey, workoutId, setIndex, distance, duration, pace }
	  
	  Object.entries(calendarData).forEach(([dateKey, dayData]) => {
		if (!dayData.hevyWorkouts) return;
		
		dayData.hevyWorkouts.forEach(workout => {
		  workout.exercises.forEach(exercise => {
			if (exercise.title === exerciseName) {
			  exercise.sets.forEach((set, setIndex) => {
				if (!set.distance_meters || !set.duration_seconds) return;
				
				const record = {
				  dateKey,
				  workoutId: workout.id,
				  setIndex,
				  distance: set.distance_meters,
				  duration: set.duration_seconds
				};

				// Distance PR
				if (!distancePR || record.distance > distancePR.distance || 
				   (record.distance === distancePR.distance && record.duration < distancePR.duration)) {
				  distancePR = record;
				}

				// Duration PR
				if (!durationPR || record.duration > durationPR.duration ||
				   (record.duration === durationPR.duration && record.distance > durationPR.distance)) {
				  durationPR = record;
				}

				// Pace PR (5km+)
				if (record.distance >= 5000) {
				  const pace = record.duration / (record.distance / 1000);
				  if (!pacePR || 
					  pace < (pacePR.duration / (pacePR.distance / 1000)) ||
					  (pace === (pacePR.duration / (pacePR.distance / 1000)) && record.distance > pacePR.distance)) {
					pacePR = { ...record, pace };
				  }
				}
			  });
			}
		  });
		});
	  });
	  
	  return { distancePR, durationPR, pacePR };
	}
	
	// Update the saveWorkout function to handle the new inputs
	function getSetData(setRow, exerciseType) {
	  if (exerciseType === 'distance_duration') {
		const distanceKm = parseFloat(setRow.querySelector('.distance-input').value || '0');
		const hours = parseInt(setRow.querySelector('.duration-hours').value || '0', 10);
		const minutes = parseInt(setRow.querySelector('.duration-minutes').value || '0', 10);
		const seconds = parseInt(setRow.querySelector('.duration-seconds').value || '0', 10);
		const distanceMeters = Math.floor(distanceKm * 1000);
		const totalSeconds = (hours * 3600) + (minutes * 60) + seconds;
		return {
		  distance_meters: distanceMeters,
		  duration_seconds: totalSeconds,
		  weight_kg: null,
		  reps: null
		};
	  } else if (exerciseType === 'duration') {
		const hours = parseInt(setRow.querySelector('.duration-hours').value || '0', 10);
		const minutes = parseInt(setRow.querySelector('.duration-minutes').value || '0', 10);
		const seconds = parseInt(setRow.querySelector('.duration-seconds').value || '0', 10);
		const totalSeconds = (hours * 3600) + (minutes * 60) + seconds;
		return {
		  distance_meters: null,
		  duration_seconds: totalSeconds,
		  weight_kg: null,
		  reps: null
		};
	  } else if (exerciseType === 'bodyweight_weighted' || exerciseType === 'bodyweight_assisted') {
		const extraWeight = parseFloat(setRow.querySelector('.assistance-input').value);
		const reps = parseInt(setRow.querySelector('.reps-input').value);
		return {
		  weight_kg: extraWeight,
		  reps: reps,
		  rpe: null,
		  distance_meters: null,
		  duration_seconds: null
		};
	  } else if (exerciseType === 'reps_only') {
		const reps = parseInt(setRow.querySelector('.reps-input').value);
		return {
		  weight_kg: null,
		  reps: reps,
		  rpe: null,
		  distance_meters: null,
		  duration_seconds: null
		};
	  } else {
		const weight = parseFloat(setRow.querySelector('.weight-input').value);
		const reps = parseInt(setRow.querySelector('.reps-input').value);
		const rpeInput = setRow.querySelector('.rpe-input');
		const rpe = rpeInput ? parseFloat(rpeInput.value) : null;
		return {
		  weight_kg: weight,
		  reps: reps,
		  rpe: isNaN(rpe) ? null : rpe,
		  distance_meters: null,
		  duration_seconds: null
		};
	  }
	}

	// Validate set data
	function validateSetData(setData, exerciseType) {
	  if (exerciseType === 'distance_duration') {
		if (!setData.distance_meters || !setData.duration_seconds || setData.distance_meters <= 0 || setData.duration_seconds <= 0) {
		  return false;
		}
	  } else if (exerciseType === 'duration') {
		if (!setData.duration_seconds || setData.duration_seconds <= 0) {
		  return false;
		}
	  } else if (exerciseType === 'bodyweight_weighted' || exerciseType === 'bodyweight_assisted') {
		if (isNaN(setData.weight_kg)) return false;
		if (!setData.reps || setData.reps < 1) return false;
	  } else if (exerciseType === 'reps_only') {
		if (!setData.reps || setData.reps < 1) return false;
	  } else {
		if (!setData.weight_kg || setData.weight_kg < 0 || setData.reps < 1) return false;
	  }
	  return true;
	}

	
	// Handle numeric input validation
	function validateTimeInput(input, max) {
	  let value = parseInt(input.value);
	  
	  // Remove leading zeros
	  if (input.value.startsWith('0') && input.value.length > 1) {
		input.value = value.toString();
	  }
	  
	  // Handle empty or invalid input
	  if (isNaN(value)) {
		input.value = '';
		return;
	  }
	  
	  // Clamp value between 0 and max
	  value = Math.min(Math.max(0, value), max);
	  input.value = value.toString();
	  
	  // Add leading zero if needed
	  if (value < 10 && input.value.length === 1) {
		input.value = '0' + value;
	  }
	}

	// Initialize time input handlers for a set
	function initTimeInputs(setRow) {
	  const hoursInput = setRow.querySelector('.duration-hours');
	  const minutesInput = setRow.querySelector('.duration-minutes');
	  const secondsInput = setRow.querySelector('.duration-seconds');
	  const distanceInput = setRow.querySelector('.distance-input');
	  const paceDisplay = setRow.querySelector('.pace-display');
	  
	  // Add validation and formatting for each time input
	  if (hoursInput) {
		hoursInput.addEventListener('input', () => {
		  validateTimeInput(hoursInput, 99);
		  if (paceDisplay) updatePaceDisplay(setRow);
		});
		hoursInput.addEventListener('blur', () => {
		  if (hoursInput.value === '') hoursInput.value = '00';
		});
	  }
	  
	  if (minutesInput) {
		minutesInput.addEventListener('input', () => {
		  validateTimeInput(minutesInput, 59);
		  if (paceDisplay) updatePaceDisplay(setRow);
		});
		minutesInput.addEventListener('blur', () => {
		  if (minutesInput.value === '') minutesInput.value = '00';
		});
	  }
	  
	  if (secondsInput) {
		secondsInput.addEventListener('input', () => {
		  validateTimeInput(secondsInput, 59);
		  if (paceDisplay) updatePaceDisplay(setRow);
		});
		secondsInput.addEventListener('blur', () => {
		  if (secondsInput.value === '') secondsInput.value = '00';
		});
	  }
	  
	  // Update pace when distance changes (only for distance_duration type)
	  if (distanceInput) {
		distanceInput.addEventListener('input', () => {
		  updatePaceDisplay(setRow);
		});
	  }
	}

	// Update the pace display for a set
	function updatePaceDisplay(setRow) {
	  const hours = parseInt(setRow.querySelector('.duration-hours')?.value || '0');
	  const minutes = parseInt(setRow.querySelector('.duration-minutes')?.value || '0');
	  const seconds = parseInt(setRow.querySelector('.duration-seconds')?.value || '0');
	  const distance = parseFloat(setRow.querySelector('.distance-input')?.value || '0');
	  const paceDisplay = setRow.querySelector('.pace-display');
	  
	  if (!paceDisplay) return;
	  
	  if (distance > 0) {
		const totalSeconds = (hours * 3600) + (minutes * 60) + seconds;
		const pacePerKm = totalSeconds / distance;
		const paceMinutes = Math.floor(pacePerKm / 60);
		const paceSeconds = Math.floor(pacePerKm % 60);
		paceDisplay.textContent = `${paceMinutes}:${paceSeconds.toString().padStart(2, '0')} /km`;
	  } else {
		paceDisplay.textContent = '-:-- /km';
	  }
	}
	
    /*
      =======================================
      = 24) DOM Loaded: Event Setup         =
      =======================================
    */
	window.addEventListener("DOMContentLoaded", () => {
	  // Add this at the very start of the function
	  const styleSheet = document.createElement('style');
	  baseColorOptions.concat(customPresets).forEach(option => {
		if (option.data && option.data.color) {
		  styleSheet.textContent += `.${option.className} { background-color: ${option.data.color}; }`;
		}
	  });
	  document.head.appendChild(styleSheet);
	  buildColorSwatches();

      // Single modal
      document.getElementById("singleSaveBtn").addEventListener("click", saveSingleModal);
      document.getElementById("singleRevertBtn").addEventListener("click", revertSingleModal);
      document.getElementById("singleCancelBtn").addEventListener("click", closeSingleModal);
      document.querySelectorAll("#singleModal .reset-emoji").forEach(btn => {
        btn.addEventListener("click", () => { resetSingleField(btn.getAttribute("data-field")); });
      });

      // Multi modal
      document.getElementById("multiKeySelect").addEventListener("change", handleMultiKeyChange);
      document.getElementById("multiSaveBtn").addEventListener("click", saveMultiModal);
      document.getElementById("multiRevertBtn").addEventListener("click", revertMultiModal);
      document.getElementById("multiCancelBtn").addEventListener("click", closeMultiModal);
	  
	  // Frequency modal
	  document.getElementById("exerciseFrequencyCloseBtn").addEventListener("click", closeExerciseFrequencyModal);

      // Stats
      document.getElementById("statsBtn").addEventListener("click", openStatsModal);
      document.getElementById("statsCloseBtn").addEventListener("click", closeStatsModal);

      // Backup
      document.getElementById("saveDataBtn").addEventListener("click", saveData);
      document.getElementById("loadDataBtn").addEventListener("click", () => {
        document.getElementById("importFileInput").click();
      });
      document.getElementById("importFileInput").addEventListener("change", (event) => {
        const file = event.target.files[0];
        if(file) {
          showCustomConfirm("Loading data will overwrite your current calendar data. Proceed?", () => {
            loadData(file);
          });
        }
        event.target.value = "";
      });

      // Hevy import
      document.getElementById("hevyImportBtn").addEventListener("click", () => {
        showCustomPrompt("Enter your Hevy API key:", "API Key", (apiKey) => {
          if(apiKey){
            importHevyData(apiKey);
          } else {
            showCustomAlert("Hevy API key is required to import data.");
          }
        });
      });

      // Populate calendar
      document.getElementById("populateCalendarBtn").addEventListener("click", () => {
        showCustomConfirm("Populate the current year with the selected cycle? This will overwrite existing data in that year for those days.", () => {
          populateEntireCalendar();
        });
      });

      // Hevy summary modal
      document.getElementById("hevyCloseBtn").addEventListener("click", closeHevyModal);

      // Volume chart modal
      document.getElementById("volumeCloseBtn").addEventListener("click", closeVolumeModal);

      // Exercise volume chart modal
      document.getElementById("exerciseVolumeCloseBtn").addEventListener("click", closeExerciseVolumeModal);

      // Combined progression modal
      document.getElementById("exerciseProgressCloseBtn").addEventListener("click", closeExerciseProgressModal);
	  
	  // Total Volume Distribution Modal
	  document.getElementById("totalVolumeDistributionCloseBtn").addEventListener("click", closeTotalVolumeDistributionModal);
	  
	  document.addEventListener('click', (e) => {
        const rangeBtn = e.target.closest('.date-range-btn');
        if (rangeBtn && !rangeBtn.classList.contains('active')) {
          // Update active state
          document.querySelectorAll('.date-range-btn').forEach(btn => btn.classList.remove('active'));
          rangeBtn.classList.add('active');
          
          // Rebuild charts with new range if we have current progression data
          if (currentProgressionExercise && currentProgressionDateKey) {
            buildExerciseWeightProgressChart(
              currentProgressionExercise,
              currentProgressionReps,
              currentProgressionDateKey
            );
            buildExerciseRepProgressChart(
              currentProgressionExercise,
              currentProgressionWeight,
              currentProgressionDateKey
            );
          }
        }
      });
	  
	  document.getElementById("volumeModal").addEventListener("click", (e) => {
	  const rangeBtn = e.target.closest(".date-range-btn");
	  if (!rangeBtn) return;

	  if (rangeBtn.classList.contains("active")) return;

	  // Toggle active state
	  document.querySelectorAll("#volumeModal .date-range-btn")
		.forEach(btn => btn.classList.remove("active"));
	  rangeBtn.classList.add("active");

	  // Rebuild the volume chart
	  if (currentVolumeDateKey) {
		buildVolumeChart(currentVolumeDateKey);
	  }
	});

	// ORM progress modal
	document.getElementById("ormProgressCloseBtn").addEventListener("click", closeOrmProgressModal);
		  
	// ORM date range button handlers
	document.getElementById("exerciseOrmProgressModal").addEventListener('click', (e) => {
	  const ormRangeBtn = e.target.closest('.date-range-btn');
	  if (ormRangeBtn && !ormRangeBtn.classList.contains('active')) {
		// Update active state
		document.querySelectorAll('#exerciseOrmProgressModal .date-range-btn')
		  .forEach(btn => btn.classList.remove('active'));
		ormRangeBtn.classList.add('active');
		
		// Rebuild ORM chart with new range if we have current data
		if (currentOrmExercise && currentOrmDateKey) {
		  buildExerciseOrmProgressChart(currentOrmExercise, currentOrmDateKey);
		}
	  }
	});
	
	document.getElementById("exerciseVolumeModal").addEventListener("click", (e) => {
	  const rangeBtn = e.target.closest(".date-range-btn");
	  if (!rangeBtn) return;

	  // Remove 'active' from all range buttons, then set on the clicked one
	  document.querySelectorAll("#exerciseVolumeModal .date-range-btn")
		.forEach(btn => btn.classList.remove("active"));
	  rangeBtn.classList.add("active");

	  // Re-build the correct chart
	  if (currentExerciseVolumeName && currentExerciseVolumeDateKey) {
		const template = getExerciseTemplate(currentExerciseVolumeName);
		if (template && (template.type === 'distance_duration' || template.type === 'duration')) {
		  if (template.type === 'distance_duration') {
			// For distance_duration exercises, decide based on the heading text
			const heading = document.getElementById("exerciseVolumeModal")
							   .querySelector("h2").textContent;
			if (heading.includes("Distance")) {
			  // Rebuild the distance chart
			  buildDistanceTimeChart(currentExerciseVolumeName, currentExerciseVolumeDateKey);
			} else {
			  // Rebuild the duration chart
			  buildDurationTimeChart(currentExerciseVolumeName, currentExerciseVolumeDateKey);
			}
		  } else if (template.type === 'duration') {
			// For duration type exercises, always build the duration chart
			buildDurationTimeChart(currentExerciseVolumeName, currentExerciseVolumeDateKey);
		  }
		} else {
		  // For weighted exercises ‚Üí normal volume progression
		  buildExerciseVolumeProgressionChart(currentExerciseVolumeName, currentExerciseVolumeDateKey);
		}
	  }
	});

      // Clear Calendar
      document.getElementById("clearCalendarBtn").addEventListener("click", clearCalendar);

      // Help
      document.getElementById("helpBtn").addEventListener("click", () => {
        showCustomAlert("Help feature is coming soon!");
      });

      // Calendar cell selection (click & drag)
      document.addEventListener("mousedown", (e) => {
        // If overlay or a button is clicked, skip
        if(document.querySelector(".overlay.active")) return;
        if(e.target.closest("button")) return;

        // Middle mouse => open Hevy
        if (e.button === 1) {
          e.preventDefault();
          const dayCell = e.target.closest(".day-cell");
          if (dayCell) {
            const dateKey = dayCell.getAttribute("data-date-key");
            if (dateKey) {
              openHevyModal(dateKey);
            }
          }
          return;
        }

        if(e.target.closest(".refresh-emoji") || e.target.closest(".completed-badge")) return;
        e.preventDefault();

        const dayCell = e.target.closest(".day-cell");
        if(!dayCell){
          selectedDates.clear();
          renderCalendar(currentYear, currentMonth);
          return;
        }
        isDragging = true;

        if(!e.ctrlKey && !e.metaKey){
          selectedDates.clear();
        }

        const startRow = parseInt(dayCell.getAttribute("data-row"), 10);
        const startCol = parseInt(dayCell.getAttribute("data-col"), 10);
        const dateKey = dayCell.getAttribute("data-date-key");
        if(dateKey) selectedDates.add(dateKey);
        renderCalendar(currentYear, currentMonth);

        const mouseMoveHandler = (moveEvent) => {
          if(!isDragging) return;
          const cell = moveEvent.target.closest(".day-cell");
          if(cell){
            const row = parseInt(cell.getAttribute("data-row"), 10);
            const col = parseInt(cell.getAttribute("data-col"), 10);
            const minRow = Math.min(startRow, row);
            const maxRow = Math.max(startRow, row);
            const minCol = Math.min(startCol, col);
            const maxCol = Math.max(startCol, col);

            if(!moveEvent.ctrlKey && !moveEvent.metaKey){
              selectedDates.clear();
            }
            const allCells = document.querySelectorAll(".calendar-grid .day-cell");
            allCells.forEach(c => {
              const r = parseInt(c.getAttribute("data-row"), 10);
              const cc = parseInt(c.getAttribute("data-col"), 10);
              if(r >= minRow && r <= maxRow && cc >= minCol && cc <= maxCol){
                const dk = c.getAttribute("data-date-key");
                if(dk) selectedDates.add(dk);
              }
            });
            renderCalendar(currentYear, currentMonth);
          }
        };
        const mouseUpHandler = () => {
          isDragging = false;
          document.removeEventListener("mousemove", mouseMoveHandler);
          document.removeEventListener("mouseup", mouseUpHandler);
        };
        document.addEventListener("mousemove", mouseMoveHandler);
        document.addEventListener("mouseup", mouseUpHandler);
      });
	  
	document.addEventListener("keydown", (e) => {
	  // Check if user pressed 'h' or 'H'
	  if (e.key === "h" || e.key === "H") {
		// Check if any overlay (modal) is active
		const anyOverlayActive = document.querySelector(".overlay.active");
		if (anyOverlayActive) {
		  // If a modal is already open, do nothing
		  return;
		}

		// Only proceed if exactly one date is selected
		if (selectedDates.size === 1) {
		  const [dateKey] = [...selectedDates];
		  openHevyModal(dateKey);
		} else {
		  showCustomAlert("You must have exactly one day cell selected to open the Hevy summary with the H key.");
		}
	  }
	});
	
	document.getElementById("exerciseSummaryCloseBtn").addEventListener("click", closeExerciseSummaryModal);
	document.getElementById("exerciseHistoryCloseBtn").addEventListener("click", closeExerciseHistoryModal);
      // Finally, initial render:
      renderCalendar(currentYear, currentMonth);
    });
	
	
  </script>
</body>
</html>
