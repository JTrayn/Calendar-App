<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Multi-Year Calendar (2020-2030) + Hevy Chart</title>

  <!-- Include Chart.js from a CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700;900&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html, body {
      height: 100%;
      width: 100%;
      background: #1E1E1E;
      color: #EAEAEA;
      font-family: 'Montserrat', sans-serif;
      user-select: none; /* Prevent text selection on entire page */
    }
    body {
      display: flex;
      justify-content: center;
      align-items: center;
    }
	.main-wrapper {
	  background: rgba(50, 50, 50, 0.5);  /* semi-transparent dark background */
	  padding: 1rem;
	  border-radius: 8px;
	  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
	  max-width: 800px;
	  width: 1000px;
	  margin: 20px auto;
	  display: flex;
	  flex-direction: column;
	  align-items: center;
	  backdrop-filter: blur(2px);
	  -webkit-backdrop-filter: blur(2px);
	}

    /* Month Bar */
    .month-bar {
      display: flex;
      flex-direction: row;
      align-items: center;
      margin-bottom: 1rem;
      width: 100%;
      justify-content: center;
    }
    .month-title {
      font-size: 1.1rem;
      font-weight: 700;
      padding: 0.2rem 0.5rem;
      width: 200px;
      text-align: center;
      white-space: nowrap;
    }
    .arrow-buttons {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      margin-left: 2rem;
    }
    .month-nav-buttons {
      display: inline-flex;
      gap: 0.5rem;
    }
    .data-buttons {
      display: inline-flex;
      gap: 0.5rem;
      margin-left: 1.5rem;
      align-items: center;
    }
	
    .arrow-button {
      background-color: rgba(51, 51, 51, 0.3);
      border: 0px solid #555;
      color: #EAEAEA;
      cursor: pointer;
      font-size: 1rem;
      min-width: 2rem;
      height: 2rem;
      border-radius: 4px;
      text-align: center;
      line-height: 2rem;
      padding: 0 0.5rem;
      transition: background-color 0.2s, border 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .arrow-button:hover {
      background-color: #444;
    }
    .arrow-button:disabled {
      background-color: #555;
      cursor: not-allowed;
      opacity: 0.5;
    }

    .arrow-button img {
      vertical-align: middle;
      display: inline-block;
      position: relative;
      top: -1px; /* Adjust as needed to center the icon */
    }

    /* Calendar Layout */
    .calendar-container {
      width: 100%;
      max-width: 700px;
    }
	
    .calendar-header,
    .calendar-grid {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 0.3rem;
    }
    .calendar-header div {
      text-align: center;
      font-weight: bold;
      padding: 0.5rem 0;
      border-bottom: 1px solid #444;
      font-size: 0.85rem;
    }
    .calendar-grid {
      margin-top: 0.5rem;
    }

    /* Day Cell */
    .day-cell {
      aspect-ratio: 1 / 1;
      border-radius: 2px;
      position: relative;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s ease-in-out;
      padding: 0.5rem;
    }
    .day-cell:hover {
      outline: 2px solid #888;
    }
    .faded {
      opacity: 0.15;
      pointer-events: none;
    }
    .morning-bg    { background-color: #FFAD66; }
    .late-day-bg   { background-color: #CC8A52; }
    .afternoon-bg  { background-color: #7AB6D9; }
    .evening-bg    { background-color: #4F7EAA; }
    .night-bg      { background-color: #5C4EA2; }
    .off-bg        { background-color: #3A3A3A; }
    .al-bg         { background-color: #616161; }
    .custom-shift  { /* Custom dynamic background if needed */ }
    .selected {
      outline: 2px solid limegreen !important;
    }
    .today {
      outline: 3px solid #FFD700;
    }

    /* Date & Icons */
    .date-num {
      position: absolute;
      top: 4px;
      left: 6px;
      font-weight: bold;
      font-size: 0.75rem;
      color: rgba(255,255,255,0.8);
      white-space: nowrap;
      pointer-events: none;
    }
    .refresh-emoji {
      position: absolute;
      top: 4px;
      right: 6px;
      font-size: 1rem;
      z-index: 3;
      cursor: pointer;
      opacity: 0.15;
      transition: opacity 0.2s;
    }
    .refresh-emoji:hover {
      opacity: 1.0;
    }

    /* Extra info overlays */
    .weight-display {
      position: absolute;
      top: 42%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 0.9rem;
      text-align: center;
      white-space: nowrap;
      color: #FFF;
      font-weight: bold;
      pointer-events: none;
    }
    .shift-time-text {
      position: absolute;
      top: 60%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 1rem;
      font-weight: bold;
      white-space: nowrap;
      color: rgba(0, 0, 0, 0.3);
      pointer-events: none;
    }
    .free-time-text {
      position: absolute;
      top: 10%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 0.65rem;
      font-weight: bold;
      white-space: nowrap;
      color: rgba(0, 0, 0, 0.3);
      pointer-events: none;
    }
    .workout-info {
      position: absolute;
      bottom: 4px;
      left: 0;
      right: 0;
      text-align: center;
      font-size: 0.75rem;
      line-height: 1.1;
      color: #FFF;
      opacity: 0.75;
      pointer-events: none;
    }

    /* Completed Badge */
    .completed-badge {
      position: absolute;
      bottom: 4px;
      right: 4px;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background-color: #28a745;
      color: #fff;
      font-size: 1rem;
      text-align: center;
      line-height: 24px;
      box-shadow: 0 0 5px rgba(0,0,0,0.5);
      cursor: pointer;
      user-select: none;
      transition: opacity 0.2s ease-out, transform 0.2s ease-out;
      opacity: 0;
    }
    .day-cell:hover .completed-badge:not(.enabled) {
      opacity: 0.3;
    }
    .day-cell.completed .completed-badge.enabled {
      opacity: 1.0;
    }
    .completed-badge:hover {
      transform: scale(1.1);
      opacity: 1.0;
    }

    /* Alert Feature */
    .alert-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 50%;
      z-index: 2;
      pointer-events: none;
    }
    .alert-text {
      position: absolute;
      top: 1.2rem;
      left: 0;
      right: 0;
      margin: 0 auto;
      width: 80%;
      text-align: center;
      font-size: 0.65rem;
      font-weight: bold;
      color: #fff;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.6);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      z-index: 3;
      pointer-events: none;
    }

    /* Overlays and Modals */
    .overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.6);
      z-index: 999;
      justify-content: center;
      align-items: center;
      /* for the open animation */
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    .overlay.active {
      display: flex;
      opacity: 1;
    }
    .modal {
      position: relative; /* For positioning modal-date if needed */
      background: #2D2D2D;
      padding: 1.5rem;
      border-radius: 6px;
      width: 420px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.7);
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      transform: translateY(-20px);
      animation: slideDownFade 0.3s forwards;
    }
    @keyframes slideDownFade {
      0% {
        opacity: 0;
        transform: translateY(-20px);
      }
      100% {
        opacity: 1;
        transform: translateY(0);
      }
    }
    .modal-date {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 0.9rem;
      color: #ccc;
    }
    .modal h2 {
      font-size: 1.2rem;
      margin-bottom: 0.5rem;
      text-align: center;
    }
    .modal-row {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }
    .modal-row label {
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .reset-emoji {
      cursor: pointer;
      opacity: 0.6;
      transition: opacity 0.2s;
      font-size: 1rem;
    }
    .reset-emoji:hover {
      opacity: 1.0;
    }
    .modal-row select, 
    .modal-row input[type=text] {
      width: 100%;
      padding: 0.3rem;
      border: 1px solid #555;
      background: #444;
      color: #EAEAEA;
      border-radius: 4px;
      font-size: 0.85rem;
    }
    .modal-buttons {
      display: flex;
      justify-content: space-between;
      gap: 1rem;
      margin-top: 0.5rem;
    }
    .modal-buttons button {
      flex: 1;
      cursor: pointer;
      padding: 0.5rem;
      font-size: 0.9rem;
      border: 1px solid #555;
      border-radius: 4px;
      background: #444;
      color: #EAEAEA;
      transition: background-color 0.2s;
    }
    .modal-buttons button:hover {
      background: #555;
    }
    .color-swatches {
      display: flex;
      flex-wrap: nowrap;
      gap: 0.5rem;
      overflow-x: auto;
    }
    .swatch {
      width: 32px;
      height: 32px;
      border-radius: 4px;
      cursor: pointer;
      border: 2px solid transparent;
      flex: 0 0 auto;
    }
    .swatch.active {
      border-color: limegreen;
    }
    .shift-label-text {
      color: #f0f0f0;
      font-weight: bold;
    }

    /* Stats Counters Text */
    .counter-value {
      color: #77DD77;
      font-weight: bold;
    }
    .stats-summary {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      margin-bottom: 1rem;
    }
    .stat-item {
      font-size: 1.1rem;
      color: #77DD77;
      margin-bottom: 0.5rem;
    }
    #weightChart, #exerciseWeightProgressionChart, #exerciseRepProgressionChart, #volumeChart {
      width: 100%;
      height: 250px;
    }

    /* Pulse Animation (generic) */
    @keyframes pulseEffect {
      0% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(255, 255, 0, 0.5);
      }
      50% {
        transform: scale(1.03);
        box-shadow: 0 0 8px 4px rgba(255, 255, 0, 0.25);
      }
      100% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(255, 255, 0, 0);
      }
    }
    .cell-pulse {
      animation: pulseEffect 0.8s ease-out;
    }

	/* ==============================================
	   UPDATED PR STYLING: Subtle Alternation
	   between Two Gold Shades + Stronger Glow
	   ============================================== */

	/* 1) TEXT shimmer: subtle gold ‚Üí lighter gold ‚Üí gold */
	.pr-text {
	  position: relative;
	  display: inline-block;
	  
	  /* Here we use #FFD86F (a stronger gold) at 0% & 100%,
		 and #FFE8A6 (a lighter gold) at 50% */
	  background: linear-gradient(
		90deg,
		#FFD86F 0%,    /* stronger gold */
		#FFE8A6 50%,   /* lighter gold */
		#FFD86F 100%
	  );
	  background-size: 200% 200%;
	  background-position: 0% 50%;

	  -webkit-background-clip: text;
	  -webkit-text-fill-color: transparent;
	  background-clip: text;
	  color: transparent; /* fallback */

	  /* Slightly stronger glow behind the text */
	  text-shadow:
		0 0 6px rgba(255, 216, 111, 0.6),
		0 0 2px rgba(255, 216, 111, 0.4);

	  /* Animate the background for that ‚Äúshimmer‚Äù sweep */
	  animation: textShimmer 3s infinite ease-in-out;
	}

	@keyframes textShimmer {
	  0%   { background-position: 0% 50%; }
	  50%  { background-position: 100% 50%; }
	  100% { background-position: 0% 50%; }
	}

	/* 2) BORDER shimmer: gentle ‚Äúlight sweep‚Äù around edges */
	.pr-border {
	  position: relative;
	  /* Use the stronger gold as the solid border color */
	  border: 2px solid #FFD86F;
	  overflow: visible;
	}

	.pr-border::after {
	  content: "";
	  position: absolute;
	  top: -2px;
	  left: -2px;
	  right: -2px;
	  bottom: -2px;
	  
	  /* We do a similar gradient but in RGBA for a subtle shimmer glow */
	  background: linear-gradient(
		60deg,
		rgba(255, 216, 111, 0.05) 0%,  /* translucent stronger gold */
		rgba(255, 232, 166, 0.2) 50%, /* translucent lighter gold */
		rgba(255, 216, 111, 0.05) 100%
	  );
	  background-size: 200% 200%;
	  background-position: 0% 50%;
	  
	  border-radius: 4px;
	  pointer-events: none;
	  z-index: 0;

	  animation: borderShimmer 3s infinite ease-in-out;
	}

	@keyframes borderShimmer {
	  0%   { background-position: 0% 50%; }
	  50%  { background-position: 100% 50%; }
	  100% { background-position: 0% 50%; }
	}

    /* =========================
       HEVY WORKOUT STYLING
       ========================= */
    /* Hevy Workout Blocks */
    .hevy-workout {
      margin-bottom: 1.5rem;
      background: #393939;
      border-radius: 8px;
      padding: 1rem;
      box-shadow: 0 2px 8px rgba(0,0,0,0.5);
      position: relative;
    }
    .hevy-workout:last-child {
      margin-bottom: 0;
    }
    .hevy-workout-title {
      font-size: 1.15rem;
      font-weight: 700;
      color: #ffffff;
      margin-bottom: 0.75rem;
      text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }
    .hevy-exercise {
      margin-bottom: 1rem;
      background: #2D2D2D;
      border-radius: 6px;
      padding: 0.75rem;
      position: relative;
      box-shadow: inset 0 0 8px rgba(0,0,0,0.3);
    }
    .hevy-exercise:last-child {
      margin-bottom: 0;
    }
    .hevy-exercise-title {
      font-weight: bold;
      color: #EAEAEA;
      margin-bottom: 0.5rem;
      display: flex;
      align-items: center;
      font-size: 1rem;
    }
    .hevy-sets {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
      gap: 0.5rem;
      margin-top: 0.5rem;
    }
    .hevy-set {
      background: linear-gradient(45deg, #444, #555);
      padding: 0.4rem;
      border-radius: 4px;
      text-align: center;
      font-size: 0.85rem;
      cursor: pointer;
      position: relative;
      transition: all 0.2s;
      color: #EEE;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }
    .hevy-set:hover {
      background: linear-gradient(45deg, #555, #666);
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.4);
    }
    .hevy-set-weight, .hevy-set-reps {
      cursor: pointer;
      transition: color 0.2s;
    }
    .hevy-total {
      margin-top: 1rem;
      padding-top: 0.5rem;
      border-top: 1px solid #555;
      font-weight: bold;
      color: white;
      cursor: pointer;
      transition: color 0.2s;
      text-align: center;
    }
    .hevy-total:hover {
      color: #FFDD77;
    }

    /* Updated: One Rep Max line */
    .hevy-orm {
      margin-top: 0.25rem;
      color: #FFFFFF;
      font-weight: 400;
      cursor: pointer;
      transition: color 0.2s;
      text-align: center;
      font-size: 0.9rem;
    }
    .hevy-orm:hover {
      color: #FFDD77;
    }

    /* Volume Over Time for Each Exercise */
    .hevy-exercise-volume {
      margin-top: 1.5rem;
      color: #FFFFFF;
      cursor: pointer;
      transition: color 0.2s;
      text-align: center;
      font-size: 0.9rem;
    }
    .hevy-exercise-volume:hover {
      color: #FFDD77;
    }

    /* Hevy Modal Layout */
    .hevy-modal-content {
      display: flex;
      flex-direction: row;
      gap: 1rem;
      width: 100%;
      align-items: flex-start;
      justify-content: flex-start;
      max-height: 450px;
      overflow-y: hidden;
    }
    #hevyModalWorkoutDetails {
      flex: 1;
      overflow-y: auto;
      padding-right: 4px; /* to give space for scrollbar */
      max-height: 450px;
    }
    #hevyProgressChartContainer {
      flex: 1;
      max-width: 320px;
      display: none; /* Hidden unless you want to show a chart in the same modal */
      overflow: hidden;
    }
    #hevyProgressChart {
      width: 100%;
      height: 300px;
    }

    /* Exercise Volume Over Time Modal */
    #exerciseVolumeOverlay {
      z-index: 1000; /* Higher than hevyOverlay */
    }
    #exerciseVolumeModal {
      width: 500px;
    }
    #exerciseVolumeChart {
      width: 100%;
      height: 300px;
    }
    /* Hide the date element inside #exerciseProgressOverlay only */
    #exerciseProgressOverlay .modal-date {
      display: none;
    }

    /* Combined Weight & Rep Progression Modal */
    #exerciseProgressOverlay {
      z-index: 1001; /* Higher than exerciseVolumeOverlay */
    }
    #exerciseProgressionModal {
      width: 500px; /* Make a bit wider to fit two charts */
    }
    #exerciseWeightProgressionChart,
    #exerciseRepProgressionChart {
      width: 100%;
      height: 250px; /* adjust as you like */
    }

    /* Volume Over Time Modal */
    #volumeOverlay {
      z-index: 1003; /* Higher than all other overlays so far */
    }
    #volumeModal {
      width: 600px;
    }
    #volumeChart {
      width: 100%;
      height: 400px;
    }
	/* Date Range Buttons */
    .date-range-btn {
      background: #444;
      border: 1px solid #555;
      color: #EAEAEA;
      padding: 0.4rem 0.8rem;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .date-range-btn:hover {
      background: #555;
    }
    .date-range-btn.active {
      background: #4DAAFF;
      border-color: #4DAAFF;
      color: #FFF;
    }
	
    /* ORM Progress Modal */
    #ormProgressOverlay {
      z-index: 1004; /* Highest so far */
    }
    #exerciseOrmProgressModal {
      width: 500px;
    }
    #exerciseOrmProgressChart {
      width: 100%;
      height: 300px;
    }

    /* Custom Alert Overlay */
    .custom-alert-modal {
      background: #2D2D2D;
      padding: 1.5rem;
      border-radius: 6px;
      width: 300px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.7);
      display: flex;
      flex-direction: column;
      gap: 1rem;
      text-align: center;
      justify-content: center;
      align-items: center;
      transform: translateY(-20px);
      animation: slideDownFade 0.3s forwards;
    }
    .custom-alert-modal p {
      font-size: 1rem;
      color: #EAEAEA;
    }
    .custom-alert-modal input[type="text"] {
      padding: 0.5rem;
      border: 1px solid #555;
      border-radius: 4px;
      background: #444;
      color: #EAEAEA;
      font-size: 1rem;
    }
    .custom-alert-modal button {
      padding: 0.5rem;
      font-size: 0.9rem;
      border: 1px solid #555;
      border-radius: 4px;
      background: #444;
      color: #EAEAEA;
      cursor: pointer;
      transition: background-color 0.2s;
      flex: 1;
    }
    .custom-alert-modal button:hover {
      background: #555;
    }
    .custom-alert-modal .confirm-buttons {
      display: flex;
      gap: 1rem;
    }

    /* Loading Overlay */
    .loading-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.6);
      z-index: 1002; /* Adjust as needed */
      justify-content: center;
      align-items: center;
    }
    .loading-overlay.active {
      display: flex;
    }
    .spinner {
      border: 6px solid rgba(255, 255, 255, 0.3);
      border-top: 6px solid #fff;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
	#hevyModal.no-workout {
	  width: 350px;        /* or whatever smaller width you prefer */
	  text-align: center;   /* centers the text inside the modal */
	  padding: 1rem;        /* optional: if you want less or more padding */
	}
	#hevyModal {
		width: 500px;
	}
  
  </style>
</head>
<body>
  <div class="main-wrapper">
    <!-- Month/Navigation/Buttons Bar -->
    <div class="month-bar">
      <div id="monthLabel" class="month-title">Month / Year</div>
      <div class="arrow-buttons">
        <div class="month-nav-buttons">
          <button class="arrow-button" onclick="prevMonth()" title="Previous Month">‚ñ≤</button>
          <button class="arrow-button" onclick="nextMonth()" title="Next Month">‚ñº</button>
        </div>
        <div class="data-buttons">
          <!-- Save Button -->
          <button class="arrow-button" id="saveDataBtn" title="Save Data">üíæ</button>
          <!-- Load Button -->
          <button class="arrow-button" id="loadDataBtn" title="Load Data">üìÅ</button>
          <!-- Import Hevy Button -->
          <button class="arrow-button" id="hevyImportBtn" title="Import Hevy">
            <img src="https://play-lh.googleusercontent.com/_HgX2ELOeBOIS6H-99ymHkNcEOlqoEncbt0x-D1MSgXx0ao8sTd7GRe16u-v70EgaAI"
                 alt="Hevy" style="width:18px;height:18px;">
          </button>
          <!-- Populate Calendar Button -->
          <button class="arrow-button" id="populateCalendarBtn" title="Populate Calendar" disabled style="opacity: 0.5; border: 2px solid #555;">
            üìÖ
          </button>
          <!-- Stats Button -->
          <button class="arrow-button" id="statsBtn" title="View Statistics">üìâ</button>
          <!-- Clear Calendar Button -->
          <button class="arrow-button" id="clearCalendarBtn" title="Clear Calendar">üóã</button>
          <!-- Help Button -->
          <button class="arrow-button" id="helpBtn" title="Help">‚ùî</button>
        </div>
      </div>
      <input type="file" id="importFileInput" accept=".json" style="display: none;">
    </div>
    <!-- Calendar -->
    <div class="calendar-container" id="calendar"></div>
  </div>

  <!-- Single-Cell Edit Overlay -->
  <div class="overlay" id="singleOverlay">
    <div class="modal" id="singleModal">
      <div class="modal-date" id="singleModalDate">2 January</div>
      <h2>Edit Cell</h2>
      <!-- SHIFT Presets -->
      <div class="modal-row">
        <label>
          <span id="singleShiftMainLabel">Shift Presets:</span>
          <span class="shift-label-text" id="singleShiftLabelText">(none)</span>
          <span class="reset-emoji" data-field="shiftClass" title="Reset Shift">‚ü≥</span>
        </label>
        <div class="color-swatches" id="singleColorSwatchesContainer"></div>
      </div>
      <!-- GYM -->
      <div class="modal-row">
        <label>Workout Type
          <span class="reset-emoji" data-field="gym" title="Reset Workout Type">‚ü≥</span>
        </label>
        <select id="singleWorkoutTypeSelect">
          <option value="Push">Push</option>
          <option value="Pull">Pull</option>
          <option value="Rest">Rest</option>
          <option value="Upper">Upper</option>
          <option value="Lower">Lower</option>
          <option value="Chest">Chest</option>
          <option value="Arms">Arms</option>
          <option value="Shoulders">Shoulders</option>
          <option value="Back">Back</option>
          <option value="Legs">Legs</option>
          <option value="Cardio">Cardio</option>
          <option value="None">None</option>
        </select>
      </div>
      <!-- Gym Time -->
      <div class="modal-row">
        <label>Gym Time (HHMM)
          <span class="reset-emoji" data-field="gymTime" title="Reset Gym Time">‚ü≥</span>
        </label>
        <input type="text" id="singleGymTimeInput" placeholder="e.g. 2100">
      </div>
      <!-- Work Time ‚Äì Dropdown -->
      <div class="modal-row">
        <label>Work Time (HHMM)
          <span class="reset-emoji" data-field="workTime" title="Reset Work Time">‚ü≥</span>
        </label>
        <select id="singleWorkTimeSelect"></select>
      </div>
      <!-- Weight -->
      <div class="modal-row">
        <label>Weight (kg)
          <span class="reset-emoji" data-field="weight" title="Reset Weight">‚ü≥</span>
        </label>
        <input type="text" id="singleWeightInput" placeholder="e.g. 88.0">
      </div>
      <!-- Alert Type -->
      <div class="modal-row">
        <label>Alert Type
          <span class="reset-emoji" data-field="alertType" title="Reset Alert Type">‚ü≥</span>
        </label>
        <select id="singleAlertTypeSelect">
          <option value="None">‚ö™ None</option>
          <option value="Generic">üü¢ Generic</option>
          <option value="Birthday">üü£ Birthday</option>
          <option value="Work">üîµ Work</option>
          <option value="PublicHoliday">üü° Public Holiday</option>
		  <option value="Deadline">üî¥ Deadline</option>
        </select>
      </div>
      <!-- Alert Text -->
      <div class="modal-row">
        <label>Alert Text
          <span class="reset-emoji" data-field="alertText" title="Reset Alert Text">‚ü≥</span>
        </label>
        <input type="text" id="singleAlertTextInput" placeholder="e.g. My birthday!">
      </div>

      <div class="modal-buttons">
        <button id="singleSaveBtn" title="Save Changes">Save</button>
        <button id="singleRevertBtn" style="font-size:1.5rem;" title="Revert Changes">‚ü≥</button>
        <button id="singleCancelBtn" title="Cancel">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Multi-Cell Edit Overlay -->
  <div class="overlay" id="multiOverlay">
    <div class="modal" id="multiModal">
      <h2>Edit Cells</h2>
      <!-- Key to Change -->
      <div class="modal-row">
        <label>Select Key to Change</label>
        <select id="multiKeySelect">
          <option value="">(select key)</option>
          <option value="shiftClass">Shift Presets</option>
          <option value="gym">Workout Type</option>
          <option value="gymTime">Gym Time</option>
          <option value="workTime">Work Time</option>
          <option value="weight">Weight</option>
          <option value="alertType">Alert Type</option>
          <option value="alertText">Alert Text</option>
        </select>
      </div>
      <!-- SHIFT Presets Swatches Row -->
      <div class="modal-row" id="multiShiftSwatchesRow" style="display:none;">
        <label>
          Choose Shift Preset:
          <span class="shift-label-text" id="multiShiftLabelText">(none)</span>
        </label>
        <div class="color-swatches" id="multiColorSwatchesContainer"></div>
      </div>
      <!-- Alert Type Row -->
      <div class="modal-row" id="multiAlertTypeRow" style="display:none;">
        <label>Alert Type</label>
        <select id="multiAlertTypeSelect">
          <option value="None">‚ö™ None</option>
          <option value="Generic">üü¢ Generic</option>
          <option value="Birthday">üü£ Birthday</option>
          <option value="Work">üîµ Work</option>
          <option value="PublicHoliday">üü° Public Holiday</option>
		  <option value="Deadline">üî¥ Deadline</option>
        </select>
      </div>
      <!-- Work Time Row -->
      <div class="modal-row" id="multiWorkTimeRow" style="display: none;">
        <label>Work Time (HHMM)</label>
        <select id="multiWorkTimeSelect"></select>
      </div>
      <!-- Value Row for other keys -->
      <div class="modal-row" id="multiValueRow" style="display:none;">
        <label>New Value</label>
        <input type="text" id="multiValueInput" placeholder="">
      </div>
      <!-- Value Row for Workout Type -->
      <div class="modal-row" id="multiWorkoutTypeRow" style="display:none;">
        <label>New Workout Type</label>
        <select id="multiWorkoutTypeSelect">
          <option value="Push">Push</option>
          <option value="Pull">Pull</option>
          <option value="Rest">Rest</option>
          <option value="Upper">Upper</option>
          <option value="Lower">Lower</option>
          <option value="Chest">Chest</option>
          <option value="Arms">Arms</option>
          <option value="Shoulders">Shoulders</option>
          <option value="Back">Back</option>
          <option value="Legs">Legs</option>
          <option value="Cardio">Cardio</option>
          <option value="None">None</option>
        </select>
      </div>
      <div class="modal-buttons">
        <button id="multiSaveBtn" title="Save Changes">Save</button>
        <button id="multiRevertBtn" style="font-size:1.5rem;" title="Revert Changes">‚ü≥</button>
        <button id="multiCancelBtn" title="Cancel">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Stats Overlay -->
  <div class="overlay" id="statsOverlay">
    <div class="modal" id="statsModal">
      <h2>Statistics</h2>
      <div class="stats-summary">
        <div class="stat-item">
          Sessions Completed: <span class="counter-value" id="sessionCounter">0</span>
        </div>
        <div class="stat-item">
          Days Trained: <span class="counter-value" id="daysTrainedCounter">0</span>
        </div>
        <div class="stat-item">
          Percentage Trained: <span class="counter-value" id="percentageCounter">0.00%</span>
        </div>
      </div>
      <div class="modal-row" style="height:300px;">
        <canvas id="weightChart"></canvas>
      </div>
      <div class="modal-buttons">
        <button id="statsCloseBtn" title="Close Statistics">Close</button>
      </div>
    </div>
  </div>

  <!-- Hevy Workout Summary Overlay -->
  <div class="overlay" id="hevyOverlay">
    <div class="modal" id="hevyModal">
      <h2>Hevy Workout Summary</h2>
      <div class="hevy-modal-content">
        <div id="hevyModalWorkoutDetails"></div>
        <!-- Optional chart container if you want to show a set-based progression in the same modal -->
        <div id="hevyProgressChartContainer">
          <canvas id="hevyProgressChart"></canvas>
        </div>
      </div>
      <div class="modal-buttons">
        <button id="hevyCloseBtn" title="Close Hevy Summary">Close</button>
      </div>
    </div>
  </div>

  <!-- Volume Over Time Overlay -->
  <div class="overlay" id="volumeOverlay">
    <div class="modal" id="volumeModal">
      <div class="modal-date" id="volumeModalDate"></div>
      <h2>Volume Over Time</h2>
      <div class="modal-row" style="height:300px;">
        <canvas id="volumeChart"></canvas>
      </div>
      <div class="modal-buttons">
        <button id="volumeCloseBtn" title="Close Volume Chart">Close</button>
      </div>
    </div>
  </div>

  <!-- Exercise Volume Over Time Overlay -->
  <div class="overlay" id="exerciseVolumeOverlay">
    <div class="modal" id="exerciseVolumeModal">
      <h2>Exercise Volume Over Time</h2>
      <div class="modal-row" style="height:300px;">
        <canvas id="exerciseVolumeChart"></canvas>
      </div>
      <div class="modal-buttons">
        <button id="exerciseVolumeCloseBtn" title="Close Exercise Volume Chart">Close</button>
      </div>
    </div>
  </div>

  <!-- Combined Weight & Rep Progression Modal -->
  <div class="overlay" id="exerciseProgressOverlay">
    <div class="modal" id="exerciseProgressionModal">
      <div class="modal-date" id="exerciseProgressionModalDate"></div>
      <h2>Exercise: Weight & Rep Progression</h2>
	  
	  <!-- Date Range Controls -->
      <div class="modal-row" style="margin-bottom: 1rem;">
        <div style="display: flex; gap: 0.5rem; justify-content: center;">
          <button class="date-range-btn active" data-range="year">Year</button>
          <button class="date-range-btn" data-range="month">Month</button>
          <button class="date-range-btn" data-range="week">Week</button>
          <button class="date-range-btn" data-range="all">All Time</button>
        </div>
      </div>

      <!-- First row: Weight Progression Chart -->
      <div class="modal-row" style="height:320px;">
        <canvas id="exerciseWeightProgressionChart"></canvas>
      </div>

      <!-- Second row: Rep Progression Chart -->
      <div class="modal-row" style="height:320px;">
        <canvas id="exerciseRepProgressionChart"></canvas>
      </div>

      <div class="modal-buttons">
        <button id="exerciseProgressCloseBtn" title="Close Progression">Close</button>
      </div>
    </div>
  </div>

  <!-- ORM Progress Modal -->
  <div class="overlay" id="ormProgressOverlay">
    <div class="modal" id="exerciseOrmProgressModal">
      <h2>Exercise: ORM Progression</h2>
	  <!-- Date Range Controls -->
      <div class="modal-row" style="margin-bottom: 1rem;">
        <div style="display: flex; gap: 0.5rem; justify-content: center;">
          <button class="date-range-btn active" data-range="year">Year</button>
          <button class="date-range-btn" data-range="month">Month</button>
          <button class="date-range-btn" data-range="week">Week</button>
          <button class="date-range-btn" data-range="all">All Time</button>
        </div>
      </div>
      <div class="modal-row" style="height:300px;">
        <canvas id="exerciseOrmProgressChart"></canvas>
      </div>
      <div class="modal-buttons">
        <button id="ormProgressCloseBtn" title="Close ORM Progression">Close</button>
      </div>
    </div>
  </div>

  <!-- Custom Alert Overlay -->
  <div class="overlay" id="customAlertOverlay">
    <div class="custom-alert-modal" id="customAlertModal">
      <p id="customAlertMessage"></p>
      <input type="text" id="customAlertInput" style="display: none;" placeholder="">
      <div class="confirm-buttons" id="customConfirmButtons" style="display: none;"></div>
      <div class="default-button" id="customDefaultButton" style="display: block;">
        <button onclick="closeCustomAlert()" title="OK">OK</button>
      </div>
    </div>
  </div>

  <!-- Loading Overlay -->
  <div class="overlay loading-overlay" id="loadingOverlay">
    <div class="custom-alert-modal">
      <p>Loading...</p>
      <div class="spinner"></div>
    </div>
  </div>

  <script>
    /*
      =======================================
      =      1) Data, Constants, Config     =
      =======================================
    */

    const START_YEAR = 2020;
    const END_YEAR = 2030;

    const monthNames = [
      "January","February","March","April","May","June",
      "July","August","September","October","November","December"
    ];
    const dayNames = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];

    // We'll store multi-year data in localStorage
    const LS_CALENDAR_DATA_KEY = "multiYearCalendarData";
    const LS_DEFAULT_CYCLE_KEY = "defaultCycleMultiYear";

    const MS_IN_DAY = 86400000;

    // Load or initialize global calendar data
    let calendarData = JSON.parse(localStorage.getItem(LS_CALENDAR_DATA_KEY)) || {};

    // If no default cycle stored yet
    let defaultCycleData = JSON.parse(localStorage.getItem(LS_DEFAULT_CYCLE_KEY)) || {
      pattern: [],
      startDate: null
    };

    // We default to the current month/year (clamped to 2020‚Äì2030)
    const now = new Date();
    let currentYear = now.getFullYear();
    if (currentYear < START_YEAR) currentYear = START_YEAR;
    if (currentYear > END_YEAR)   currentYear = END_YEAR;
    let currentMonth = now.getMonth(); // 0-11

    const selectedDates = new Set();
    let isDragging = false;

    // For charts
    let weightChart = null;
    let hevyProgressChart = null;
    let exerciseWeightProgressionChart = null;
    let exerciseRepProgressionChart = null;
    let volumeChart = null;
    let exerciseVolumeChart = null;
    let exerciseOrmProgressChart = null;

    /*
      =======================================
      =       2) Helper Functions           =
      =======================================
    */
	function updateBackgroundForMonth(month) {
	  // Now the image files are inside the "images" folder.
	  const imageFile = 'images/' + monthNames[month].toLowerCase() + '.jpg';
	  document.body.style.backgroundImage = `url('${imageFile}')`;
	  document.body.style.backgroundSize = 'cover';
	  document.body.style.backgroundPosition = 'center center';
	}
	
	function hasAnyPR(dateKey) {
	  // Grab the day data
	  const dayObj = getDayData(dateKey);
	  if (!dayObj.hevyWorkouts || dayObj.hevyWorkouts.length === 0) return false;

	  // For each workout‚Äôs exercises, check for:
	  //  - Set-based PR (exceeding previous best weight/reps)
	  //  - Volume PR
	  //  - 1RM PR
	  for (const workout of dayObj.hevyWorkouts) {
		for (const ex of workout.exercises) {
		  // 1) Compare with prior best (weight + reps)
		  const { bestWeight, bestRepsForWeight } = getBestWeightAndRepsBeforeDate(ex.title, dateKey);

		  // 2) Calculate this day‚Äôs total volume + highest 1RM for this exercise
		  let dayVolume = 0;
		  let highestOrmForThisEx = 0;
		  ex.sets.forEach(set => {
			const vol = set.weight_kg * set.reps;
			dayVolume += vol;
			const oneRepMax = computeOrm(set.weight_kg, set.reps);
			if (oneRepMax > highestOrmForThisEx) highestOrmForThisEx = oneRepMax;
		  });

		  // 3) Compare volume / 1RM with prior best
		  const prevMaxVolume = getMaxVolumeForExerciseBeforeDate(ex.title, dateKey);
		  const prevMaxOrm    = getMaxOrmForExerciseBeforeDate(ex.title, dateKey);
		  if (dayVolume > prevMaxVolume) return true; // Volume PR
		  if (highestOrmForThisEx > prevMaxOrm) return true; // 1RM PR

		  // 4) Check if any set is a ‚Äúweight PR‚Äù or ‚Äúweight+reps PR‚Äù
		  for (const set of ex.sets) {
			// If this set's weight is above the old best weight,
			// or same weight but more reps, it's a new PR
			if (
			  set.weight_kg > bestWeight ||
			  (set.weight_kg === bestWeight && set.reps > bestRepsForWeight)
			) {
			  return true;
			}
		  }
		}
	  }

	  // If no PR found in all workouts, return false
	  return false;
	}

	function hasAnyPR(dateKey) {
	  // Grab the day data
	  const dayObj = getDayData(dateKey);
	  if (!dayObj.hevyWorkouts || dayObj.hevyWorkouts.length === 0) return false;

	  // For each workout‚Äôs exercises, check for:
	  //  - Set-based PR (exceeding previous best weight/reps)
	  //  - Volume PR
	  //  - ORM PR
	  for (const workout of dayObj.hevyWorkouts) {
		for (const ex of workout.exercises) {
		  // 1) Compare with prior best (weight)
		  const { bestWeight, bestRepsForWeight } = getBestWeightAndRepsBeforeDate(ex.title, dateKey);

		  // 2) Calculate day‚Äôs total volume + highest ORM for this exercise
		  let dayVolume = 0;
		  let highestOrmThisEx = 0;
		  ex.sets.forEach(set => {
			const vol = set.weight_kg * set.reps;
			dayVolume += vol;
			const oneRepMax = computeOrm(set.weight_kg, set.reps);
			if (oneRepMax > highestOrmThisEx) {
			  highestOrmThisEx = oneRepMax;
			}
		  });

		  // 3) Compare volume, ORM with prior best
		  const prevMaxVolume = getMaxVolumeForExerciseBeforeDate(ex.title, dateKey);
		  const prevMaxOrm    = getMaxOrmForExerciseBeforeDate(ex.title, dateKey);
		  if (dayVolume > prevMaxVolume) return true;          // Volume PR
		  if (highestOrmThisEx > prevMaxOrm) return true;      // ORM PR

		  // 4) Check if any set is a ‚Äúweight PR‚Äù or ‚Äúweight+reps PR‚Äù
		  for (const set of ex.sets) {
			if (
			  set.weight_kg > bestWeight ||
			  (set.weight_kg === bestWeight && set.reps > bestRepsForWeight)
			) {
			  return true;
			}
		  }
		}
	  }
	  // If we never returned true, no PR found
	  return false;
	}
	
	function getDateRangeBounds(rangeType, referenceDate) {
	  const refDate = new Date(referenceDate);
	  let start, end;

	  switch(rangeType) {
		case 'year':
		  start = new Date(refDate.getFullYear(), 0, 1);
		  end = new Date(refDate.getFullYear(), 11, 31);
		  break;
		case 'month':
		  start = new Date(refDate.getFullYear(), refDate.getMonth(), 1);
		  end = new Date(refDate.getFullYear(), refDate.getMonth() + 1, 0);
		  break;
		case 'week':
		  // Get Monday of current week
		  const day = refDate.getDay();
		  const diff = refDate.getDate() - day + (day === 0 ? -6 : 1);
		  start = new Date(refDate.setDate(diff));
		  end = new Date(start);
		  end.setDate(end.getDate() + 6);
		  break;
		case 'all':
		default:
		  start = new Date(START_YEAR, 0, 1);
		  end = new Date(END_YEAR, 11, 31);
	  }
	  return { start, end };
	}
	
    function getDateKey(dateObj) {
      const y = dateObj.getFullYear();
      const m = String(dateObj.getMonth() + 1).padStart(2,"0");
      const d = String(dateObj.getDate()).padStart(2,"0");
      return `${y}-${m}-${d}`;
    }
    function parseDateKey(dateKey) {
      const [y,m,d] = dateKey.split("-").map(Number);
      return new Date(y, m - 1, d);
    }
    function isToday(dateObj) {
      const nowLocal = new Date();
      return (
        dateObj.getFullYear() === nowLocal.getFullYear() &&
        dateObj.getMonth() === nowLocal.getMonth() &&
        dateObj.getDate() === nowLocal.getDate()
      );
    }
    function isOffDayShift(shiftClass) {
      return (shiftClass === "off-bg" || shiftClass === "al-bg");
    }
    function isTrainingDay(dayObj) {
      return (dayObj.gym !== "Rest" && dayObj.gym !== "None");
    }
    function validateTimeHHMM(value) {
      if (!value) return true;
      return !!value.match(/^([01]\d|2[0-3])[0-5]\d$/);
    }
    function formatTimeForDisplay(time24) {
      if(!time24) return "";
      const hour = parseInt(time24.substring(0,2),10);
      const minute = time24.substring(2,4);
      let period = "am";
      let displayHour = hour;
      if(hour >= 12){
        period = "pm";
        if(hour > 12) displayHour = hour - 12;
      }
      if(hour === 0){
        displayHour = 12;
        period = "am";
      }
      return `${displayHour}:${minute}${period}`;
    }
    function getDayData(dateKey) {
      if(!calendarData[dateKey]) {
        calendarData[dateKey] = {
          shiftClass: "off-bg",
          gym: "None",
          gymTime: "",
          workTime: "",
          completed: false,
          weight: null,
          alert: null,
          hevyWorkouts: []
        };
      }
      return calendarData[dateKey];
    }
    function setDayData(dateKey, newData) {
      if(!calendarData[dateKey]) {
        calendarData[dateKey] = {};
      }
      Object.assign(calendarData[dateKey], newData);
      localStorage.setItem(LS_CALENDAR_DATA_KEY, JSON.stringify(calendarData));
    }
    function getLastRecordedWeightBefore(dateKey) {
      const dateObj = parseDateKey(dateKey);
      const d = new Date(dateObj.getTime());
      d.setDate(d.getDate() - 1);

      // We'll stop if we go before START_YEAR
      const earliestBoundary = new Date(START_YEAR, 0, 1);

      while(d >= earliestBoundary) {
        const prevKey = getDateKey(d);
        if (calendarData[prevKey] && calendarData[prevKey].weight > 0) {
          return calendarData[prevKey].weight;
        }
        d.setDate(d.getDate() - 1);
      }
      return null;
    }
    function getWeightArrow(dateKey) {
      const dayObj = getDayData(dateKey);
      if(!dayObj.weight || parseFloat(dayObj.weight) <= 0) return "";
      const lastWeight = getLastRecordedWeightBefore(dateKey);
      if(!lastWeight) return "";
      if(dayObj.weight > lastWeight)  return "‚Üë";
      if(dayObj.weight < lastWeight)  return "‚Üì";
      return "";
    }
    function computeFreeTime(dateKey) {
      const dayObj = getDayData(dateKey);
      if(!dayObj.workTime || isOffDayShift(dayObj.shiftClass)){
        return null;
      }
      const curStartHour = parseInt(dayObj.workTime.substring(0,2),10);
      const curStartMin = parseInt(dayObj.workTime.substring(2,4),10);
      let currentShiftDate = parseDateKey(dateKey);
      currentShiftDate.setHours(curStartHour, curStartMin, 0, 0);

      let currentShiftEnd = new Date(currentShiftDate.getTime() + 10 * 3600000);

      // Next day that has a valid workTime (within 2020-2030)
      let nextDate = new Date(parseDateKey(dateKey).getTime());
      nextDate.setDate(nextDate.getDate() + 1);
      let nextWorkShiftDate = null;

      while(nextDate.getFullYear() >= START_YEAR && nextDate.getFullYear() <= END_YEAR) {
        const nextKey = getDateKey(nextDate);
        const nextDay = getDayData(nextKey);
        if(nextDay.workTime && !isOffDayShift(nextDay.shiftClass)) {
          nextWorkShiftDate = new Date(nextDate.getTime());
          const nxHr = parseInt(nextDay.workTime.substring(0,2),10);
          const nxMin = parseInt(nextDay.workTime.substring(2,4),10);
          nextWorkShiftDate.setHours(nxHr, nxMin, 0, 0);
          break;
        }
        nextDate.setDate(nextDate.getDate() + 1);
      }
      if(!nextWorkShiftDate) return null;

      let nextPrepTime = new Date(nextWorkShiftDate.getTime() - 3600000); 
      let gapHours = (nextPrepTime - currentShiftEnd) / 3600000;

      // Subtract 8 hours sleep
      gapHours -= 8;

      return Math.max(0, Math.floor(gapHours));
    }
    function computeCurrentDayFreeTimeFull() {
      const nowLocal = new Date();
      let nextDate = new Date(nowLocal.getFullYear(), nowLocal.getMonth(), nowLocal.getDate() + 1);
      let nextWorkShiftDate = null;

      while(nextDate.getFullYear() >= START_YEAR && nextDate.getFullYear() <= END_YEAR) {
        const nextKey = getDateKey(nextDate);
        const nextDay = getDayData(nextKey);
        if(nextDay.workTime && !isOffDayShift(nextDay.shiftClass)) {
          nextWorkShiftDate = new Date(nextDate.getTime());
          const nxHr = parseInt(nextDay.workTime.substring(0,2),10);
          const nxMin = parseInt(nextDay.workTime.substring(2,4),10);
          nextWorkShiftDate.setHours(nxHr, nxMin, 0, 0);
          break;
        }
        nextDate.setDate(nextDate.getDate() + 1);
      }
      if(!nextWorkShiftDate) return "N/A";

      const diffMs = nextWorkShiftDate - nowLocal - 8 * 3600000; // Subtract 8 hours sleep
      if (diffMs < 0) return "N/A";
      const totalMinutes = Math.floor(diffMs / 60000);
      const hours = Math.floor(totalMinutes / 60);
      const minutes = totalMinutes % 60;
      return `${hours.toString().padStart(2,"0")}:${minutes.toString().padStart(2,"0")}`;
    }
    function getDefaultDataForDate(dateKey){
      if(!defaultCycleData.pattern.length || !defaultCycleData.startDate){
        return {
          shiftClass: "off-bg",
          gym: "None",
          gymTime: "",
          workTime: "",
          completed: false,
          weight: null,
          alert: null,
          hevyWorkouts: []
        };
      }
      const startDate = parseDateKey(defaultCycleData.startDate);
      const currentDate = parseDateKey(dateKey);
      const diffDays = Math.floor((currentDate - startDate) / MS_IN_DAY);
      const patternLength = defaultCycleData.pattern.length;
      const patternIndex = ((diffDays % patternLength) + patternLength) % patternLength;
      return defaultCycleData.pattern[patternIndex];
    }
    function escapeHtml(str) {
      return str.replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }

    // Compute approximate 1RM (Brzycki/Epley)
    function computeOrm(weightKg, reps) {
      if(reps <= 0 || weightKg <= 0) return 0;
      if(reps <= 10) {
        // Brzycki
        return weightKg / (1.0278 - 0.0278 * reps);
      } else {
        // Epley
        return weightKg * (1 + (reps / 30));
      }
    }

    // Return best historical (weight, reps) for an exercise (before a date)
    function getBestWeightAndRepsBeforeDate(exerciseName, dateKey) {
      let bestWeight = 0;
      let bestRepsForWeight = 0;

      const targetDate = parseDateKey(dateKey);

      for (const k of Object.keys(calendarData)) {
        const d = parseDateKey(k);
        if (d < targetDate) {
          const dayObj = calendarData[k];
          if (dayObj.hevyWorkouts) {
            dayObj.hevyWorkouts.forEach(workout => {
              workout.exercises.forEach(ex => {
                if (ex.title === exerciseName) {
                  ex.sets.forEach(s => {
                    if (s.weight_kg > bestWeight) {
                      bestWeight = s.weight_kg;
                      bestRepsForWeight = s.reps;
                    }
                    else if (s.weight_kg === bestWeight && s.reps > bestRepsForWeight) {
                      bestRepsForWeight = s.reps;
                    }
                  });
                }
              });
            });
          }
        }
      }
      return { bestWeight, bestRepsForWeight };
    }
    function getMaxVolumeForExerciseBeforeDate(exerciseName, dateKey) {
      const targetDate = parseDateKey(dateKey);
      let maxVolume = 0;
      for(const k of Object.keys(calendarData)) {
        const d = parseDateKey(k);
        if(d < targetDate) {
          let dayVolume = 0;
          const dayObj = calendarData[k];
          if(dayObj.hevyWorkouts) {
            dayObj.hevyWorkouts.forEach(workout => {
              workout.exercises.forEach(ex => {
                if(ex.title === exerciseName) {
                  ex.sets.forEach(s => {
                    dayVolume += (s.weight_kg * s.reps);
                  });
                }
              });
            });
          }
          if(dayVolume > maxVolume) {
            maxVolume = dayVolume;
          }
        }
      }
      return maxVolume;
    }
    function getMaxOrmForExerciseBeforeDate(exerciseName, dateKey) {
      const targetDate = parseDateKey(dateKey);
      let maxOrm = 0;
      for(const k of Object.keys(calendarData)) {
        const d = parseDateKey(k);
        if(d < targetDate) {
          const dayObj = calendarData[k];
          if(dayObj.hevyWorkouts) {
            dayObj.hevyWorkouts.forEach(workout => {
              workout.exercises.forEach(ex => {
                if(ex.title === exerciseName) {
                  ex.sets.forEach(s => {
                    const thisOrm = computeOrm(s.weight_kg, s.reps);
                    if(thisOrm > maxOrm) {
                      maxOrm = thisOrm;
                    }
                  });
                }
              });
            });
          }
        }
      }
      return maxOrm;
    }

    /*
      =======================================
      =       3) Calendar Rendering         =
      =======================================
    */
    function renderCalendar(year, month) {
      document.getElementById("monthLabel").textContent = `${monthNames[month]} ${year}`;
	  updateBackgroundForMonth(month);
      const calendar = document.getElementById("calendar");
      calendar.innerHTML = "";

      const headerEl = renderCalendarHeader();
      const gridEl = renderCalendarGrid(year, month);

      calendar.appendChild(headerEl);
      calendar.appendChild(gridEl);

      updateCounters();
      updatePopulateCalendarButtonState();
    }
    function renderCalendarHeader() {
      const headerGrid = document.createElement("div");
      headerGrid.classList.add("calendar-header");
      dayNames.forEach(d => {
        const hd = document.createElement("div");
        hd.textContent = d;
        headerGrid.appendChild(hd);
      });
      return headerGrid;
    }
    function renderCalendarGrid(year, month) {
      const grid = document.createElement("div");
      grid.classList.add("calendar-grid");

      const daysInMonth = new Date(year, month + 1, 0).getDate();
      const firstDay = new Date(year, month, 1);
      const startWeekday = firstDay.getDay();
      let rowIndex = 0, colIndex = 0;

      // Blank cells before the first day
      for(let i = 0; i < startWeekday; i++){
        grid.appendChild(blankCell(rowIndex, colIndex++));
      }

      // Days of the current month
      for(let dayNum = 1; dayNum <= daysInMonth; dayNum++){
        const dateObj = new Date(year, month, dayNum);
        const cell = renderDayCell(dateObj, dayNum);
        cell.setAttribute("data-row", rowIndex);
        cell.setAttribute("data-col", colIndex);
        grid.appendChild(cell);

        colIndex++;
        if(colIndex > 6){
          colIndex = 0;
          rowIndex++;
        }
      }

      // Fill remaining cells to make up to 6 rows (42 cells total)
      const totalCellsUsed = startWeekday + daysInMonth;
      const remainingCells = 42 - totalCellsUsed;
      for(let i = 0; i < remainingCells; i++){
        grid.appendChild(blankCell(rowIndex, colIndex++));
        if(colIndex > 6){
          colIndex = 0;
          rowIndex++;
        }
      }
      return grid;
    }
    function blankCell(row, col) {
      const blank = document.createElement("div");
      blank.classList.add("day-cell", "faded");
      blank.setAttribute("data-row", row);
      blank.setAttribute("data-col", col);
      return blank;
    }
    function renderDayCell(dateObj, dayNum) {
      const dateKey = getDateKey(dateObj);
      const dayData = getDayData(dateKey);

      const cell = document.createElement("div");
      cell.classList.add("day-cell");

      // Shift color or custom
      if(dayData.workTime && !isOffDayShift(dayData.shiftClass)) {
        // If user picked custom shift but has a known time color, use that:
        if(dayData.shiftClass === "custom-shift" && workTimeColors[dayData.workTime]) {
          cell.style.backgroundColor = workTimeColors[dayData.workTime];
        } else if(workTimeColors[dayData.workTime]) {
          cell.style.backgroundColor = workTimeColors[dayData.workTime];
        } else {
          cell.classList.add(dayData.shiftClass);
        }
      } else {
        cell.classList.add(dayData.shiftClass);
      }

      cell.setAttribute("data-date-key", dateKey);

      if(isToday(dateObj)) cell.classList.add("today");
      if(dayData.completed) cell.classList.add("completed");
      if(selectedDates.has(dateKey)) cell.classList.add("selected");

      // Date number
      const dateDiv = document.createElement("div");
      dateDiv.classList.add("date-num");
      dateDiv.textContent = dayNum;
      cell.appendChild(dateDiv);

      // Free time
      if(isToday(dateObj)) {
        if(isOffDayShift(dayData.shiftClass)) {
          const currentFreeTime = computeCurrentDayFreeTimeFull();
          appendFreeTime(cell, currentFreeTime, true);
        } else {
          const freeTime = computeFreeTime(dateKey);
          if(freeTime) appendFreeTime(cell, freeTime);
        }
      } else {
        const freeTime = computeFreeTime(dateKey);
        if(freeTime) appendFreeTime(cell, freeTime);
      }

      // Refresh icon
      const refreshDiv = document.createElement("div");
      refreshDiv.classList.add("refresh-emoji");
      refreshDiv.textContent = "‚ü≥";
      refreshDiv.addEventListener("mousedown", e => e.stopPropagation());
      refreshDiv.addEventListener("click", e => {
        e.stopPropagation();
        if(!selectedDates.has(dateKey)){
          selectedDates.clear();
          selectedDates.add(dateKey);
        }
        openCustomizationPopup();
      });
      cell.appendChild(refreshDiv);

      // Alerts
      if(dayData.alert && dayData.alert.type && dayData.alert.type !== "None") {
        const color = alertColors[dayData.alert.type] || "#32CD32";
        const overlay = document.createElement("div");
        overlay.classList.add("alert-overlay");
        overlay.style.background = `linear-gradient(to bottom, ${color}CC, transparent 100%)`;
        cell.appendChild(overlay);

        const alertSpan = document.createElement("div");
        alertSpan.classList.add("alert-text");
        alertSpan.textContent = dayData.alert.text || "";
        cell.appendChild(alertSpan);
      }

      // Weight display
      const weightDiv = document.createElement("div");
      weightDiv.classList.add("weight-display");
      if(dayData.weight && parseFloat(dayData.weight) > 0) {
        const arrow = getWeightArrow(dateKey);
        let arrowColor = "#FFF";
        if(arrow === "‚Üë") arrowColor = "#FF4444";
        if(arrow === "‚Üì") arrowColor = "#66CC66";

        const textSpan = `${dayData.weight}kg`;
        if(arrow){
          if(arrow === "‚Üë"){
            weightDiv.innerHTML = `<span style="font-size:120%; color:${arrowColor}; margin-right:0.3em;">${arrow}</span> ${textSpan}`;
            weightDiv.style.color = arrowColor;
          } else {
            weightDiv.innerHTML = `${textSpan} <span style="font-size:120%; color:${arrowColor}; margin-left:0.3em;">${arrow}</span>`;
            weightDiv.style.color = arrowColor;
          }
        } else {
          weightDiv.textContent = textSpan;
        }
      }
      cell.appendChild(weightDiv);

      // Shift time
      const shiftTimeDiv = document.createElement("div");
      shiftTimeDiv.classList.add("shift-time-text");
      if(dayData.shiftClass === "al-bg") {
        shiftTimeDiv.textContent = "AL";
      } else if(dayData.workTime && !isOffDayShift(dayData.shiftClass)) {
        shiftTimeDiv.textContent = dayData.workTime;
      }
      cell.appendChild(shiftTimeDiv);

      // Workout info
      const wDiv = document.createElement("div");
      wDiv.classList.add("workout-info");
      if(dayData.gym === "Rest") {
        wDiv.textContent = "üò¥";
        wDiv.style.opacity = "1.0";
      }
      else if(dayData.gym === "None") {
        wDiv.textContent = "";
      }
      else {
        wDiv.innerHTML = `${dayData.gym}: ${formatTimeForDisplay(dayData.gymTime || "")}`;
      }
      cell.appendChild(wDiv);

      // Completed badge
      const badgeDiv = document.createElement("div");
      badgeDiv.classList.add("completed-badge");
      if(dayData.completed) badgeDiv.classList.add("enabled");
      badgeDiv.addEventListener("mousedown", e => e.stopPropagation());
      badgeDiv.addEventListener("click", (e) => {
        e.stopPropagation();
        setDayData(dateKey, { completed: !dayData.completed });
        renderCalendar(currentYear, currentMonth);
      });
      badgeDiv.innerHTML = `
        <svg width="16" height="16" fill="none" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" />
        </svg>
      `;
      cell.appendChild(badgeDiv);
	  
      return cell;
    }
    function appendFreeTime(cell, freeTimeValue, isTodayOffShift) {
      const freeTimeDiv = document.createElement("div");
      freeTimeDiv.classList.add("free-time-text");
      freeTimeDiv.textContent = freeTimeValue;
      if(isTodayOffShift) {
        freeTimeDiv.style.color = "gold";
        freeTimeDiv.style.opacity = "0.7";
      }
      cell.appendChild(freeTimeDiv);
    }

    /*
      =======================================
      =    4) Single vs Multi Popup Flow    =
      =======================================
    */
    function openCustomizationPopup() {
      if(selectedDates.size === 0){
        showCustomAlert("No days selected. Please select a cell first.");
        return;
      }
      if(selectedDates.size === 1){
        openSingleModal();
      } else {
        openMultiModal();
      }
    }

    // 4a) Single-Cell Modal
    let currentSingleDayKey = null;

    function populateWorkTimeSelect(selectId, selectedValue){
      const selectElem = document.getElementById(selectId);
      selectElem.innerHTML = "";
      Object.keys(workTimeColors).sort().forEach(time => {
        const option = document.createElement("option");
        option.value = time;
        option.textContent = time;
        option.style.backgroundColor = workTimeColors[time] || "#444";
        option.style.color = "#fff";
        if(time === selectedValue) { option.selected = true; }
        selectElem.appendChild(option);
      });
    }
    function updateSingleWorkTimeState(){
      const active = document.querySelector("#singleColorSwatchesContainer .swatch.active");
      if(active){
        const preset = active.id.replace("swatch-single-", "");
        document.getElementById("singleWorkTimeSelect").disabled =
          (preset === "off-bg" || preset === "al-bg");
      }
    }
    function openSingleModal() {
      document.getElementById("singleOverlay").classList.add("active");
      document.querySelectorAll("#singleColorSwatchesContainer .swatch").forEach(s => s.classList.remove("active"));

      const [dKey] = [...selectedDates];
      currentSingleDayKey = dKey;
      const dayData = getDayData(dKey);

      // Date
      const dateObj = parseDateKey(currentSingleDayKey);
      const formattedDate = `${dateObj.getDate()} ${monthNames[dateObj.getMonth()]}, ${dateObj.getFullYear()}`;
      document.getElementById("singleModalDate").textContent = formattedDate;

      // Shift Preset
      document.querySelectorAll("#singleColorSwatchesContainer .swatch").forEach(swatch => {
        if(swatch.id === `swatch-single-${dayData.shiftClass}`){
          swatch.classList.add("active");
        } else {
          swatch.classList.remove("active");
        }
      });
      const preset = colorOptions.find(opt => opt.className === dayData.shiftClass);
      document.getElementById("singleShiftLabelText").textContent = preset ? preset.label : "Custom Shift";

      // Form values
      document.getElementById("singleWorkoutTypeSelect").value = dayData.gym || "None";
      document.getElementById("singleGymTimeInput").value = dayData.gymTime || "";
      populateWorkTimeSelect("singleWorkTimeSelect", dayData.workTime);
      document.getElementById("singleWeightInput").value = dayData.weight || "";

      if(isOffDayShift(dayData.shiftClass)) {
        document.getElementById("singleWorkTimeSelect").disabled = true;
      } else {
        document.getElementById("singleWorkTimeSelect").disabled = false;
      }

      // Alerts
      let alertVal = "None";
      if(dayData.alert && dayData.alert.type && dayData.alert.type !== "None") {
        alertVal = dayData.alert.type;
      }
      document.getElementById("singleAlertTypeSelect").value = alertVal;
      document.getElementById("singleAlertTextInput").value =
        (dayData.alert && dayData.alert.text) ? dayData.alert.text : "";
    }
    function closeSingleModal() {
      document.getElementById("singleOverlay").classList.remove("active");
    }
    function resetSingleField(fieldName) {
      if(!currentSingleDayKey) return;
      const defaultData = getDefaultDataForDate(currentSingleDayKey);
      if(!defaultData) return;

      if(fieldName === "shiftClass"){
        document.querySelectorAll("#singleColorSwatchesContainer .swatch").forEach(s => s.classList.remove("active"));
        const sw = document.getElementById("swatch-single-" + defaultData.shiftClass);
        if(sw) sw.classList.add("active");
        const preset = colorOptions.find(o => o.className === defaultData.shiftClass);
        document.getElementById("singleShiftLabelText").textContent = preset ? preset.label : "(none)";

        if(isOffDayShift(defaultData.shiftClass)) {
          document.getElementById("singleWorkTimeSelect").disabled = true;
        } else {
          document.getElementById("singleWorkTimeSelect").disabled = false;
        }
      } else if(fieldName === "gym"){
        document.getElementById("singleWorkoutTypeSelect").value = defaultData.gym;
      } else if(fieldName === "gymTime"){
        document.getElementById("singleGymTimeInput").value = defaultData.gymTime || "";
      } else if(fieldName === "workTime"){
        populateWorkTimeSelect("singleWorkTimeSelect", defaultData.workTime);
      } else if(fieldName === "weight"){
        document.getElementById("singleWeightInput").value = defaultData.weight || "";
      } else if(fieldName === "alertType"){
        if(defaultData.alert && defaultData.alert.type){
          document.getElementById("singleAlertTypeSelect").value = defaultData.alert.type;
        } else {
          document.getElementById("singleAlertTypeSelect").value = "None";
        }
      } else if(fieldName === "alertText"){
        if(defaultData.alert && defaultData.alert.text){
          document.getElementById("singleAlertTextInput").value = defaultData.alert.text;
        } else {
          document.getElementById("singleAlertTextInput").value = "";
        }
      }
    }
    function saveSingleModal() {
      if(!currentSingleDayKey) return;
      const updates = {};
      const activeSwatch = document.querySelector("#singleColorSwatchesContainer .swatch.active");
      if(activeSwatch){
        updates.shiftClass = activeSwatch.id.replace("swatch-single-", "");
      }
      updates.gym = document.getElementById("singleWorkoutTypeSelect").value.trim();

      // Gym time
      const newGymTime = document.getElementById("singleGymTimeInput").value.trim();
      if(newGymTime){
        if(!validateTimeHHMM(newGymTime)){
          showCustomAlert("Invalid Gym Time. Use HHMM format (e.g. 2100).");
          return;
        }
        updates.gymTime = newGymTime;
      } else {
        updates.gymTime = "";
      }

      // Work time
      if(updates.shiftClass === "off-bg" || updates.shiftClass === "al-bg"){
        updates.workTime = "";
      } else {
        updates.workTime = document.getElementById("singleWorkTimeSelect").value;
        const isPreset = Object.values(presetWorkTimeMapping).includes(updates.workTime);
        if(!isPreset){
          updates.shiftClass = "custom-shift";
        }
      }

      // Weight
      const weightVal = document.getElementById("singleWeightInput").value.trim();
      if(weightVal){
        let wf = parseFloat(weightVal);
        if(isNaN(wf) || wf <= 0){
          showCustomAlert("Invalid weight.");
          return;
        }
        updates.weight = wf.toFixed(1);
      } else {
        updates.weight = null;
      }

      // Alert
      const alertType = document.getElementById("singleAlertTypeSelect").value;
      const alertText = document.getElementById("singleAlertTextInput").value.trim();
      if(alertType && alertType !== "None"){
        updates.alert = { type: alertType, text: alertText || "" };
      } else {
        updates.alert = null;
      }

      setDayData(currentSingleDayKey, updates);
      closeSingleModal();
      renderCalendar(currentYear, currentMonth);

      // Pulse highlight
      setTimeout(() => {
        const cellElement = document.querySelector(`[data-date-key="${currentSingleDayKey}"]`);
        if(cellElement){
          cellElement.classList.add("cell-pulse");
          cellElement.addEventListener("animationend", function handler(){
            cellElement.classList.remove("cell-pulse");
            cellElement.removeEventListener("animationend", handler);
          });
        }
      }, 100);
    }
    function revertSingleModal() {
      if(!currentSingleDayKey) return;
      const defaultData = getDefaultDataForDate(currentSingleDayKey);
      if(defaultData){
        setDayData(currentSingleDayKey, {
          shiftClass: defaultData.shiftClass,
          gym: defaultData.gym,
          gymTime: defaultData.gymTime || "",
          workTime: defaultData.workTime || "",
          completed: defaultData.completed || false,
          weight: defaultData.weight || null,
          alert: defaultData.alert || null,
          hevyWorkouts: defaultData.hevyWorkouts ? [...defaultData.hevyWorkouts] : []
        });
      }
      closeSingleModal();
      renderCalendar(currentYear, currentMonth);
    }

    // 4b) Multi-Cell Modal
    function openMultiModal() {
      document.getElementById("multiOverlay").classList.add("active");
      document.getElementById("multiKeySelect").value = "";
      document.getElementById("multiValueInput").value = "";
      document.getElementById("multiValueInput").placeholder = "";
      document.getElementById("multiShiftSwatchesRow").style.display = "none";
      document.getElementById("multiAlertTypeRow").style.display = "none";
      document.getElementById("multiWorkTimeRow").style.display = "none";
      document.getElementById("multiWorkoutTypeRow").style.display = "none";
      document.getElementById("multiAlertTypeSelect").value = "None";
      document.querySelectorAll("#multiColorSwatchesContainer .swatch").forEach(s => s.classList.remove("active"));
      document.getElementById("multiShiftLabelText").textContent = "(none)";
    }
    function closeMultiModal() {
      document.getElementById("multiOverlay").classList.remove("active");
    }
    function handleMultiKeyChange() {
      const key = document.getElementById("multiKeySelect").value;
      const valRow = document.getElementById("multiValueRow");
      const shiftRow = document.getElementById("multiShiftSwatchesRow");
      const alertRow = document.getElementById("multiAlertTypeRow");
      const workTimeRow = document.getElementById("multiWorkTimeRow");
      const workoutTypeRow = document.getElementById("multiWorkoutTypeRow");

      shiftRow.style.display = "none";
      valRow.style.display = "none";
      alertRow.style.display = "none";
      workTimeRow.style.display = "none";
      workoutTypeRow.style.display = "none";

      if(key === "shiftClass"){
        shiftRow.style.display = "flex";
      } else if(key === "alertType"){
        alertRow.style.display = "flex";
      } else if(key === "workTime"){
        workTimeRow.style.display = "flex";
        populateWorkTimeSelect("multiWorkTimeSelect", "");
      } else if(key === "gym"){
        workoutTypeRow.style.display = "flex";
      } else if(key){
        valRow.style.display = "flex";
        document.getElementById("multiValueInput").placeholder = multiPlaceholderMap[key] || "";
      }
    }
    function saveMultiModal() {
      const key = document.getElementById("multiKeySelect").value;
      if(!key){
        showCustomAlert("Please select a key to change.");
        return;
      }

      let newValue;
      if(key === "shiftClass"){
        const swatch = document.querySelector("#multiColorSwatchesContainer .swatch.active");
        if(!swatch){
          showCustomAlert("Please choose a shift preset.");
          return;
        }
        newValue = swatch.id.replace("swatch-multi-", "");
      } else if(key === "alertType"){
        newValue = document.getElementById("multiAlertTypeSelect").value;
      } else if(key === "workTime"){
        newValue = document.getElementById("multiWorkTimeSelect").value;
      } else if(key === "gym"){
        newValue = document.getElementById("multiWorkoutTypeSelect").value;
      } else {
        newValue = document.getElementById("multiValueInput").value.trim();
      }

      if(key === "gymTime" && newValue){
        if(!validateTimeHHMM(newValue)){
          showCustomAlert("Invalid time. Use HHMM format (e.g. 0600).");
          return;
        }
      }
      if(key === "weight"){
        if(newValue){
          let wf = parseFloat(newValue);
          if(isNaN(wf) || wf <= 0){
            showCustomAlert("Invalid weight.");
            return;
          }
          newValue = wf.toFixed(1);
        } else {
          newValue = null;
        }
      }

      selectedDates.forEach(dKey => {
        const updated = {};

        if(key === "shiftClass"){
          updated.shiftClass = newValue;
          if(presetWorkTimeMapping[newValue]) {
            updated.workTime = presetWorkTimeMapping[newValue];
          } else if(newValue === "off-bg" || newValue === "al-bg"){
            updated.workTime = "";
          }
        }
        else if(key === "gym"){
          updated.gym = newValue || "";
        }
        else if(key === "gymTime"){
          updated.gymTime = newValue || "";
        }
        else if(key === "workTime"){
          updated.workTime = newValue || "";
          const found = Object.entries(presetWorkTimeMapping)
                             .find(([preset, time]) => time === newValue);
          if(found) {
            updated.shiftClass = found[0];
          } else {
            updated.shiftClass = "custom-shift";
          }
        }
        else if(key === "weight"){
          updated.weight = newValue ? newValue : null;
        }
        else if(key === "alertType"){
          if(newValue === "None"){
            updated.alert = null;
          } else {
            updated.alert = { type: newValue, text: "" };
          }
        }
        else if(key === "alertText"){
          if(newValue){
            if(calendarData[dKey].alert && calendarData[dKey].alert.type && calendarData[dKey].alert.type !== "None"){
              updated.alert = { type: calendarData[dKey].alert.type, text: newValue };
            } else {
              updated.alert = { type: "Generic", text: newValue };
            }
          } else {
            updated.alert = null;
          }
        }

        setDayData(dKey, updated);
      });

      closeMultiModal();
      renderCalendar(currentYear, currentMonth);

      // Pulse highlight
      setTimeout(() => {
        selectedDates.forEach(dKey => {
          const cellElement = document.querySelector(`[data-date-key="${dKey}"]`);
          if(cellElement){
            cellElement.classList.add("cell-pulse");
            cellElement.addEventListener("animationend", function handler(){
              cellElement.classList.remove("cell-pulse");
              cellElement.removeEventListener("animationend", handler);
            });
          }
        });
      }, 100);
    }
    function revertMultiModal() {
      selectedDates.forEach(dKey => {
        const defaultData = getDefaultDataForDate(dKey);
        if(defaultData){
          setDayData(dKey, {
            shiftClass: defaultData.shiftClass,
            gym: defaultData.gym,
            gymTime: defaultData.gymTime || "",
            workTime: defaultData.workTime || "",
            completed: defaultData.completed || false,
            weight: defaultData.weight || null,
            alert: defaultData.alert || null,
            hevyWorkouts: defaultData.hevyWorkouts ? [...defaultData.hevyWorkouts] : []
          });
        }
      });
      closeMultiModal();
      renderCalendar(currentYear, currentMonth);
    }

    /*
      =======================================
      =          5) Counters (Stats)        =
      =======================================
    */
    function updateCounters() {
      let completedCount = 0;
      let earliestDateKey = null;

      Object.keys(calendarData).forEach(key => {
        const dayObj = calendarData[key];
        if(dayObj.completed && isTrainingDay(dayObj)){
          completedCount++;
          if(!earliestDateKey || key < earliestDateKey){
            earliestDateKey = key;
          }
        }
      });

      let daysTrained = 0;
      if(earliestDateKey){
        const earliestDate = parseDateKey(earliestDateKey);
        const nowLocal = new Date();
        // We'll only do day difference if earliest is <= now
        if(earliestDate <= nowLocal){
          let diff = nowLocal - earliestDate;
          let rawDays = Math.floor(diff / MS_IN_DAY);
          if(rawDays < 0) rawDays = 0;
          daysTrained = rawDays + 1;
        }
      }
      let percentage = 0;
      if(daysTrained > 0){
        percentage = (completedCount / daysTrained) * 100;
      }

      document.getElementById("sessionCounter").textContent = completedCount;
      document.getElementById("daysTrainedCounter").textContent = daysTrained;
      document.getElementById("percentageCounter").textContent = percentage.toFixed(2) + '%';
    }

    /*
      =======================================
      =         6) Navigation               =
      =======================================
    */
    function prevMonth() {
      currentMonth--;
      if(currentMonth < 0){
        currentMonth = 11;
        currentYear--;
      }
      if(currentYear < START_YEAR){
        currentYear = START_YEAR;
        currentMonth = 0;
      }
      selectedDates.clear();
      renderCalendar(currentYear, currentMonth);
    }
    function nextMonth() {
      currentMonth++;
      if(currentMonth > 11){
        currentMonth = 0;
        currentYear++;
      }
      if(currentYear > END_YEAR){
        currentYear = END_YEAR;
        currentMonth = 11;
      }
      selectedDates.clear();
      renderCalendar(currentYear, currentMonth);
    }

    /*
      =======================================
      =   7) Shift Preset & Color Swatches  =
      =======================================
    */
    const colorOptions = [
      { className: "morning-bg",   label: "Day Shift" },
      { className: "late-day-bg",  label: "Late-Day Shift" },
      { className: "afternoon-bg", label: "Afternoon Shift" },
      { className: "evening-bg",   label: "Evening Shift" },
      { className: "night-bg",     label: "Night Shift" },
      { className: "off-bg",       label: "Off (Weekly Leave)" },
      { className: "al-bg",        label: "Annual Leave" }
    ];
    const workTimeColors = {
      "0000": "#926E8E","0100": "#A47887","0200": "#B78381","0300": "#C8917A",
      "0400": "#DB9C73","0500": "#EDA76D","0600": "#FFAD66","0700": "#EEAE74",
      "0800": "#DEAF83","0900": "#D0A77D","1000": "#BDB2A0","1100": "#ACB3AE",
      "1200": "#9CB4BC","1300": "#8CB4CA","1400": "#7AB6D9","1500": "#76A7D1",
      "1600": "#7198C9","1700": "#6D8BC2","1800": "#697DBA","1900": "#627AA3",
      "2000": "#6060AA","2100": "#5C4EA2","2200": "#6E599B","2300": "#806395"
    };
    const alertColors = {
      "Generic": "#32CD32",
      "Birthday": "#FF69B4",
      "Work": "#1E90FF",
      "PublicHoliday": "#FFD700",
	  "Deadline": "#C41E3A"
    };
    const presetWorkTimeMapping = {
      "morning-bg": "0600",
      "late-day-bg": "0900",
      "afternoon-bg": "1400",
      "evening-bg": "1900",
      "night-bg": "2100"
    };
    const multiPlaceholderMap = {
      shiftClass: "Use swatches below",
      gym: "Select Workout Type",
      gymTime: "HHMM e.g. 2100",
      workTime: "Choose work time",
      weight: "e.g. 88.0",
      alertType: "",
      alertText: "e.g. My special event"
    };

    function buildColorSwatches() {
      function buildSet(containerId, prefix, labelTextId) {
        const container = document.getElementById(containerId);
        colorOptions.forEach(opt => {
          const div = document.createElement("div");
          div.id = `swatch-${prefix}-${opt.className}`;
          div.className = `swatch ${opt.className}`;
          div.title = opt.label;
          div.addEventListener("mouseover", () => {
            document.getElementById(labelTextId).textContent = opt.label;
          });
          div.addEventListener("mouseout", () => {
            const activeSw = container.querySelector(".swatch.active");
            if(activeSw) {
              const className = activeSw.id.replace(`swatch-${prefix}-`, "");
              const found = colorOptions.find(o => o.className === className);
              document.getElementById(labelTextId).textContent = found ? found.label : "(none)";
            } else {
              document.getElementById(labelTextId).textContent = "(none)";
            }
          });
          div.addEventListener("click", () => {
            container.querySelectorAll(".swatch").forEach(s => s.classList.remove("active"));
            div.classList.add("active");
            if(prefix === "single") {
              updateSingleWorkTimeState();
              const thisPreset = div.id.replace("swatch-single-", "");
              if(presetWorkTimeMapping[thisPreset]) {
                document.getElementById("singleWorkTimeSelect").value = presetWorkTimeMapping[thisPreset];
              }
            } else if(prefix === "multi") {
              if(document.getElementById("multiKeySelect").value === "shiftClass") {
                const thisPreset = div.id.replace("swatch-multi-", "");
                if(presetWorkTimeMapping[thisPreset]) {
                  document.getElementById("multiWorkTimeSelect").value = presetWorkTimeMapping[thisPreset];
                }
              }
            }
          });
          container.appendChild(div);
        });
      }
      buildSet("singleColorSwatchesContainer", "single", "singleShiftLabelText");
      buildSet("multiColorSwatchesContainer", "multi", "multiShiftLabelText");
    }

    /*
      =======================================
      =   8) Data Backup (Load/Save JSON)   =
      =======================================
    */
    function saveData() {
      const dataToSave = {
        calendarData: calendarData,
        defaultCycle: defaultCycleData
      };
      const dataStr = JSON.stringify(dataToSave, null, 2);
      const blob = new Blob([dataStr], { type: "application/json" });
      const url  = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = 'calendar-data-backup.json';
      a.click();
      URL.revokeObjectURL(url);
    }
    function loadData(file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const importedData = JSON.parse(e.target.result);
          if(!importedData || typeof importedData !== 'object'){
            showCustomAlert("Invalid JSON data.");
            return;
          }
          if(!importedData.calendarData || typeof importedData.calendarData !== 'object'){
            showCustomAlert("Invalid or missing calendarData in JSON.");
            return;
          }
          calendarData = importedData.calendarData;
          localStorage.setItem(LS_CALENDAR_DATA_KEY, JSON.stringify(calendarData));

          if(importedData.defaultCycle && typeof importedData.defaultCycle === 'object'){
            defaultCycleData = importedData.defaultCycle;
            localStorage.setItem(LS_DEFAULT_CYCLE_KEY, JSON.stringify(defaultCycleData));
          } else {
            defaultCycleData = {
              pattern: [],
              startDate: null
            };
            localStorage.setItem(LS_DEFAULT_CYCLE_KEY, JSON.stringify(defaultCycleData));
          }

          selectedDates.clear();
          renderCalendar(currentYear, currentMonth);
          updateCounters();
          showCustomAlert("Data loaded successfully!");
        } catch(err){
          showCustomAlert("Failed to parse JSON file. Please ensure it's valid.");
        }
      };
      reader.readAsText(file);
    }

    /*
      =======================================
      =    9) Import Hevy Data from API     =
      =======================================
    */
    async function importHevyData(userApiKey) {
      try {
        document.getElementById("loadingOverlay").classList.add("active");

        // Get total workout count
        const countResponse = await fetch("https://api.hevyapp.com/v1/workouts/count", {
          method: "GET",
          headers: {
            "accept": "application/json",
            "api-key": userApiKey
          }
        });
        if (!countResponse.ok) throw new Error("Failed to fetch workout count.");
        const countData = await countResponse.json();
        const totalWorkouts = countData.workout_count;

        const pageSize = 10;
        const totalPages = Math.ceil(totalWorkouts / pageSize);
        let allWorkouts = [];

        // Fetch all workouts page by page
        for (let page = 1; page <= totalPages; page++) {
          const response = await fetch(`https://api.hevyapp.com/v1/workouts?page=${page}&pageSize=${pageSize}`, {
            method: "GET",
            headers: {
              "accept": "application/json",
              "api-key": userApiKey
            }
          });
          if (!response.ok) throw new Error("Failed to fetch workouts page " + page);
          const data = await response.json();
          if (data.workouts && Array.isArray(data.workouts)) {
            allWorkouts = allWorkouts.concat(data.workouts);
          }
        }

        let importedCount = 0;
        allWorkouts.forEach(workout => {
          let dateKey = null;

          // If workout title is in dd/mm/yyyy format, try to parse
          if (workout.title && /^(\d{1,2})\/(\d{1,2})\/(\d{4})$/.test(workout.title)) {
            const parts = workout.title.split("/");
            const dayNum = parseInt(parts[0], 10);
            const monthNum = parseInt(parts[1], 10);
            const yearNum = parseInt(parts[2], 10);
            if(yearNum >= START_YEAR && yearNum <= END_YEAR){
              dateKey = `${yearNum}-${String(monthNum).padStart(2, "0")}-${String(dayNum).padStart(2,"0")}`;
            }
          }

          // If title format was off, fall back to the actual start_time
          if(!dateKey && workout.start_time){
            const startTime = new Date(workout.start_time);
            const y = startTime.getFullYear();
            if(y >= START_YEAR && y <= END_YEAR){
              dateKey = getDateKey(startTime);
            }
          }

          if(dateKey) {
            const dayData = getDayData(dateKey);
            if (!dayData.hevyWorkouts) {
              dayData.hevyWorkouts = [];
            }
            // Avoid duplicates
            const duplicate = dayData.hevyWorkouts.some(existing => existing.id === workout.id);
            if (!duplicate) {
              dayData.hevyWorkouts.push(workout);
              dayData.completed = true; 
              setDayData(dateKey, dayData);
              importedCount++;
            }
          }
        });

        showCustomAlert(`Imported ${importedCount} new Hevy workouts into calendar.`);
        renderCalendar(currentYear, currentMonth);
      } catch(err) {
        console.error(err);
        showCustomAlert("An error occurred while importing Hevy data: " + err.message);
      } finally {
        document.getElementById("loadingOverlay").classList.remove("active");
      }
    }

    /*
      =======================================
      = 10) Stats Modal & 'WeightChart'      =
      =======================================
    */
    function openStatsModal() {
      document.getElementById("statsOverlay").classList.add("active");
      buildWeightChart();
    }
    function closeStatsModal() {
      document.getElementById("statsOverlay").classList.remove("active");
      if(weightChart){
        weightChart.destroy();
        weightChart = null;
      }
    }
    function buildWeightChart(){
      // Gather all date keys that have a valid weight
      const weightKeys = Object.keys(calendarData)
        .filter(k => calendarData[k].weight && parseFloat(calendarData[k].weight) > 0)
        .sort();
      if(weightKeys.length < 1){
        if(weightChart){
          weightChart.destroy();
          weightChart = null;
        }
        return;
      }
      const dataPoints = weightKeys.map(k => ({ x: k, y: parseFloat(calendarData[k].weight) }));
      const labels = weightKeys.map(k => {
        const d = parseDateKey(k);
        return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
      });
      const weights = dataPoints.map(dp => dp.y);
      const minWeight = Math.min(...weights);
      const maxWeight = Math.max(...weights);
      const suggestedMin = Math.max(0, minWeight - 1);
      const suggestedMax = maxWeight + 1;

      if(weightChart){
        weightChart.destroy();
        weightChart = null;
      }
      const ctx = document.getElementById('weightChart').getContext('2d');

      // We highlight "today" if it's in data
      const todayKey = getDateKey(new Date());
      const { bgColors, borderColors, pointRadii } = buildHighlightArrays(
        dataPoints, todayKey, '#77DD77', '#4DAAFF', 2.5, 5
      );

      weightChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Weight (kg)',
            data: dataPoints.map(dp => dp.y),
            borderColor: '#77DD77',
            backgroundColor: 'rgba(119,221,119,0.2)',
            fill: true,
            tension: 0.1,
            pointRadius: pointRadii,
            pointBackgroundColor: bgColors,
            pointBorderColor: borderColors,
            pointHoverRadius: 6
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: { 
              title: { display: true, text: 'Date' }, 
              ticks: { color: '#ccc' }, 
              grid: { color: '#555' }
            },
            y: { 
              suggestedMin, 
              suggestedMax, 
              title: { display: true, text: 'Weight (kg)' }, 
              ticks: { color: '#ccc' }, 
              grid: { color: '#555' } 
            }
          },
          plugins: {
            legend: { labels: { color: '#eee' } }
          }
        }
      });
    }
    function buildHighlightArrays(dataPoints, highlightDateKey, normalColor, highlightColor, normalRadius=4, highlightRadius=6) {
      const bgColors = [];
      const borderColors = [];
      const pointRadii = [];

      dataPoints.forEach(dp => {
        if(dp.x === highlightDateKey) {
          bgColors.push(highlightColor);
          borderColors.push("#fff");
          pointRadii.push(highlightRadius);
        } else {
          bgColors.push(normalColor);
          borderColors.push(normalColor);
          pointRadii.push(normalRadius);
        }
      });

      return { bgColors, borderColors, pointRadii };
    }

    /*
      =======================================
      = 11) Hevy Workout Summary Modal       =
      =======================================
    */
	function openHevyModal(dateKey) {
	  // 1) Activate the overlay
	  document.getElementById("hevyOverlay").classList.add("active");

	  // 2) Grab your data and the container
	  const dayData = getDayData(dateKey);
	  const container = document.getElementById("hevyModalWorkoutDetails");
	  
	  // 3) Grab the modal element (so we can toggle a special class)
	  const modalEl = document.getElementById("hevyModal");

	  // 4) First, remove .no-workout in case it was set previously
	  modalEl.classList.remove("no-workout");

	  // 5) Check if there are no workouts
	  if (!dayData.hevyWorkouts || dayData.hevyWorkouts.length === 0) {
		// a) Add the "no-workout" class => smaller width + centered text
		modalEl.classList.add("no-workout");

		// b) Display the "no data" message
		container.innerHTML = "<p>No Hevy workout data for this day.</p>";

		// c) Stop here - do not render normal workout details
		return;
	  }

	  // 6) Otherwise, render the normal workout summary
	  renderHevyWorkoutsToContainer(dayData.hevyWorkouts, "hevyModalWorkoutDetails", dateKey);
	  // Scroll the modal‚Äôs content to the top
	  document.getElementById("hevyModal").scrollTop = 0;
	  // Optionally also scroll the "details" area:
	  document.getElementById("hevyModalWorkoutDetails").scrollTop = 0;
	}
    function closeHevyModal() {
      document.getElementById("hevyOverlay").classList.remove("active");
      destroyHevyProgressChart();
    }
    function destroyHevyProgressChart() {
      if(hevyProgressChart) {
        hevyProgressChart.destroy();
        hevyProgressChart = null;
      }
    }

    /*
      ================================================
      = 12) Rendering Hevy Workouts + PR Logic       =
      ================================================
    */
    function renderHevyWorkoutsToContainer(workouts, containerId, dateKey) {
      const container = document.getElementById(containerId);
      if (!workouts || workouts.length === 0) {
        container.innerHTML = "<p>No Hevy workout data for this day.</p>";
        return;
      }

      let html = "";

      workouts.forEach(workout => {
        html += `<div class="hevy-workout">`;
        html += `<div class="hevy-workout-title">${escapeHtml(workout.title)}</div>`;

        workout.exercises.forEach(exercise => {
          // Compare with prior best
          const { bestWeight, bestRepsForWeight } = getBestWeightAndRepsBeforeDate(exercise.title, dateKey);

          // Check volume/ORM PR
          const prevMaxVolume = getMaxVolumeForExerciseBeforeDate(exercise.title, dateKey);
          const prevMaxOrm    = getMaxOrmForExerciseBeforeDate(exercise.title, dateKey);

          let exerciseVolume = 0;
          let highestOrmForThisExercise = 0;
          exercise.sets.forEach(s => {
            const setVolume = s.weight_kg * s.reps;
            exerciseVolume += setVolume;
            const setOrm = computeOrm(s.weight_kg, s.reps);
            if(setOrm > highestOrmForThisExercise) {
              highestOrmForThisExercise = setOrm;
            }
          });

          const isVolumePR = exerciseVolume > prevMaxVolume;
          const isOrmPR    = highestOrmForThisExercise > prevMaxOrm;

          // Find any set that exceeds prior best
          const candidates = [];
          exercise.sets.forEach((s, i) => {
            if (
              s.weight_kg > bestWeight ||
              (s.weight_kg === bestWeight && s.reps > bestRepsForWeight)
            ) {
              candidates.push({ index: i, weight: s.weight_kg, reps: s.reps });
            }
          });
          let highlightSetIndex = -1;
          if (candidates.length > 0) {
            const maxWeight = Math.max(...candidates.map(c => c.weight));
            const topWeightSets = candidates.filter(c => c.weight === maxWeight);
            const bestReps = Math.max(...topWeightSets.map(c => c.reps));
            const highlight = topWeightSets.find(c => c.reps === bestReps);
            highlightSetIndex = highlight.index;
          }

          html += `<div class="hevy-exercise">`;
          html += `<div class="hevy-exercise-title">${escapeHtml(exercise.title)}</div>`;

          // Each set
          html += `<div class="hevy-sets">`;
          exercise.sets.forEach((set, i) => {
            let setClasses = "hevy-set";
            let prSpan = "";
            if (i === highlightSetIndex) {
              setClasses += " pr-border";
              prSpan = ` <span class="pr-text">PR</span>`;
            }

            html += `
              <div class="${setClasses}"
                   data-exercise="${escapeHtml(exercise.title)}"
                   data-reps="${set.reps}"
                   data-weight="${set.weight_kg}"
                   data-date-key="${dateKey}">
                <span class="hevy-set-weight">${set.weight_kg}kg</span>
                x
                <span class="hevy-set-reps">${set.reps}</span>
                ${prSpan}
                ${set.rpe ? `<br>RPE: ${set.rpe}` : ""}
              </div>
            `;
          });
          html += `</div>`; // end .hevy-sets

          // Volume line
          let volumeText = `Volume: ${exerciseVolume.toLocaleString()}kg`;
          if (isVolumePR) {
            volumeText += ` <span class="pr-text">PR</span>`;
          }
          html += `
            <div class="hevy-exercise-volume"
                 data-exercise="${escapeHtml(exercise.title)}"
                 data-date-key="${dateKey}">
              ${volumeText}
            </div>
          `;

          // One Rep Max line
          let ormText = "One Rep Max: N/A";
          if (highestOrmForThisExercise > 0) {
            ormText = `One Rep Max: ${highestOrmForThisExercise.toFixed(1)}kg`;
            if (isOrmPR) {
              ormText += ` <span class="pr-text">PR</span>`;
            }
          }
          html += `
            <div class="hevy-orm"
                 data-exercise="${escapeHtml(exercise.title)}"
                 data-date-key="${dateKey}">
              ${ormText}
            </div>
          `;

          html += `</div>`; // end .hevy-exercise
        });

        // Summaries (total volume across entire workout)
        let totalWeight = 0;
        workout.exercises.forEach(ex => {
          ex.sets.forEach(s => {
            totalWeight += (s.weight_kg * s.reps);
          });
        });
        html += `<div class="hevy-total" data-date-key="${dateKey}">Total Volume: ${totalWeight.toLocaleString()}kg</div>`;

        html += `</div>`; // end .hevy-workout
      });

      container.innerHTML = html;

      // Container-level click handlers
      container.onclick = (e) => {
        // 1) If clicked on .hevy-set => open combined Weight & Rep progression
        const setParent = e.target.closest(".hevy-set");
        if (setParent) {
          e.stopPropagation();
          const exerciseName = setParent.getAttribute("data-exercise");
          const weight = Number(setParent.getAttribute("data-weight"));
          const reps = parseInt(setParent.getAttribute("data-reps"), 10);
          const dKey = setParent.getAttribute("data-date-key");
          openExerciseProgressionModal(exerciseName, weight, reps, dKey);
          return;
        }

        // 2) Exercise volume chart
        const volumeEl = e.target.closest(".hevy-exercise-volume");
        if (volumeEl) {
          e.stopPropagation();
          const exerciseName = volumeEl.getAttribute("data-exercise");
          const dKey = volumeEl.getAttribute("data-date-key");
          openExerciseVolumeModal(exerciseName, dKey);
          return;
        }

        // 3) total volume chart
        const totalEl = e.target.closest(".hevy-total");
        if (totalEl) {
          e.stopPropagation();
          const associatedDateKey = totalEl.getAttribute("data-date-key");
          openVolumeModal(associatedDateKey);
          return;
        }

        // 4) One Rep Max chart
        const ormEl = e.target.closest(".hevy-orm");
        if (ormEl) {
          e.stopPropagation();
          const exerciseName = ormEl.getAttribute("data-exercise");
          const dKey = ormEl.getAttribute("data-date-key");
          openOrmProgressModal(exerciseName, dKey);
          return;
        }
      };
    }

    /*
      ================================================
      = 13) Unified Weight & Rep Progress Modal      =
      ================================================
    */
	let currentProgressionExercise = null;
	let currentProgressionWeight = null;
	let currentProgressionReps = null;
	let currentProgressionDateKey = null;
	
    function destroyExerciseWeightProgressChart() {
      if(exerciseWeightProgressionChart) {
        exerciseWeightProgressionChart.destroy();
        exerciseWeightProgressionChart = null;
      }
    }
    function destroyExerciseRepProgressChart() {
      if(exerciseRepProgressionChart) {
        exerciseRepProgressionChart.destroy();
        exerciseRepProgressionChart = null;
      }
    }

    function openExerciseProgressionModal(exerciseName, weight, reps, dateKey) {
	  document.querySelectorAll('#exerciseProgressionModal .date-range-btn').forEach(btn => {
		btn.classList.toggle('active', btn.getAttribute('data-range') === 'year');
	  });
	  currentProgressionExercise = exerciseName;
      currentProgressionWeight = weight;
      currentProgressionReps = reps;
      currentProgressionDateKey = dateKey;
      const dateObj = parseDateKey(dateKey);
      const dateLabel = `${dateObj.getDate()} ${monthNames[dateObj.getMonth()]}, ${dateObj.getFullYear()}`;
      document.getElementById("exerciseProgressionModalDate").textContent = dateLabel;

      document.getElementById("exerciseProgressOverlay").classList.add("active");

      buildExerciseWeightProgressChart(exerciseName, reps, dateKey);
      buildExerciseRepProgressChart(exerciseName, weight, dateKey);
    }
    function closeExerciseProgressModal() {
      document.getElementById("exerciseProgressOverlay").classList.remove("active");
      destroyExerciseWeightProgressChart();
      destroyExerciseRepProgressChart();
    }

    // Weight progression at a fixed rep count
    function buildExerciseWeightProgressChart(exerciseName, repCount, highlightDateKey) {
      const selectedRange = document.querySelector('#exerciseProgressionModal .date-range-btn.active').getAttribute('data-range');
      const refDate = parseDateKey(highlightDateKey);
      const { start, end } = getDateRangeBounds(selectedRange, refDate);
      
      const dateKeys = Object.keys(calendarData)
        .filter(key => {
          const date = parseDateKey(key);
          return date >= start && date <= end;
        })
        .sort();
      const dataMap = {};

      // Collect max weight (for the given repCount) on each date
      dateKeys.forEach(k => {
        const dayObj = calendarData[k];
        if (dayObj.hevyWorkouts && dayObj.hevyWorkouts.length > 0) {
          let maxWeightForThatDay = 0;
          dayObj.hevyWorkouts.forEach(workout => {
            workout.exercises.forEach(ex => {
              if (ex.title === exerciseName) {
                ex.sets.forEach(s => {
                  if (s.reps === repCount && s.weight_kg > maxWeightForThatDay) {
                    maxWeightForThatDay = s.weight_kg;
                  }
                });
              }
            });
          });
          if (maxWeightForThatDay > 0) {
            dataMap[k] = maxWeightForThatDay;
          }
        }
      });

      const chartKeys = Object.keys(dataMap).sort();
      if (chartKeys.length < 1) {
        destroyExerciseWeightProgressChart();
        showCustomAlert("No weight progression data found for that set.");
        return;
      }

      const dataPoints = chartKeys.map(k => ({ x: k, y: dataMap[k] }));
      const labels = chartKeys.map(k => {
        const d = parseDateKey(k);
        return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
      });
      const weights = dataPoints.map(dp => dp.y);
      const minWeight = Math.min(...weights);
      const maxWeight = Math.max(...weights);
      const suggestedMin = Math.max(0, minWeight - 1);
      const suggestedMax = maxWeight + 1;

      destroyExerciseWeightProgressChart();
      const ctx = document.getElementById('exerciseWeightProgressionChart').getContext('2d');

      const { bgColors, borderColors, pointRadii } = buildHighlightArrays(
        dataPoints, highlightDateKey, 'rgba(119,221,119,1)', '#4DAAFF', 2.5, 5
      );

      exerciseWeightProgressionChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: `${exerciseName} (${repCount} reps)`,
            data: dataPoints.map(dp => dp.y),
            borderColor: '#77DD77',
            backgroundColor: 'rgba(119,221,119,0.2)',
            fill: true,
            tension: 0.1,
            pointRadius: pointRadii,
            pointBackgroundColor: bgColors,
            pointBorderColor: borderColors,
            pointHoverRadius: 6
          }]
        },
        options: {
			layout: {
		  padding: {
			top: 0,
			bottom: 0,
			left: 0,
			right: 0,
		  }
		},
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              title: { display: true, text: 'Date' },
              ticks: { color: '#ccc' },
              grid: { color: '#555' }
            },
            y: {
              suggestedMin,
              suggestedMax,
              title: { display: true, text: 'Weight (kg)' },
              ticks: { color: '#ccc' },
              grid: { color: '#555' }
            }
          },
          plugins: {
            legend: { 
				labels: { color: '#eee' },
				padding: {
				top: 1,
				bottom: 1
			  }
			},
            title: {
              display: true,
              text: `Weight progression at ${repCount} reps`,
              color: '#fff',
              font: { size: 16 },
			  padding: {
			  top: 1,
			  bottom: 1
			  }
            }
          }
        }
      });
    }

    // Rep progression at a fixed weight
    function buildExerciseRepProgressChart(exerciseName, weight, highlightDateKey) {
      const selectedRange = document.querySelector('#exerciseProgressionModal .date-range-btn.active').getAttribute('data-range');
      const refDate = parseDateKey(highlightDateKey);
      const { start, end } = getDateRangeBounds(selectedRange, refDate);
      
      const dateKeys = Object.keys(calendarData)
        .filter(key => {
          const date = parseDateKey(key);
          return date >= start && date <= end;
        })
        .sort();
      const dataMap = {};

      // Collect max reps (for the given weight) on each date
      dateKeys.forEach(k => {
        const dayObj = calendarData[k];
        if (dayObj.hevyWorkouts && dayObj.hevyWorkouts.length > 0) {
          let maxRepForThatDay = 0;
          dayObj.hevyWorkouts.forEach(workout => {
            workout.exercises.forEach(ex => {
              if (ex.title === exerciseName) {
                ex.sets.forEach(s => {
                  if (Number(s.weight_kg) === Number(weight) && s.reps > maxRepForThatDay) {
                    maxRepForThatDay = s.reps;
                  }
                });
              }
            });
          });
          if (maxRepForThatDay > 0) {
            dataMap[k] = maxRepForThatDay;
          }
        }
      });

      const chartKeys = Object.keys(dataMap).sort();
      if (chartKeys.length < 1) {
        destroyExerciseRepProgressChart();
        showCustomAlert("No rep progression data found for that set.");
        return;
      }

      const dataPoints = chartKeys.map(k => ({ x: k, y: dataMap[k] }));
      const labels = chartKeys.map(k => {
        const d = parseDateKey(k);
        return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
      });
      const reps = dataPoints.map(dp => dp.y);
      const minRep = Math.min(...reps);
      const maxRep = Math.max(...reps);
      const suggestedMin = Math.max(0, minRep - 1);
      const suggestedMax = maxRep + 1;

      destroyExerciseRepProgressChart();
      const ctx = document.getElementById('exerciseRepProgressionChart').getContext('2d');

      const { bgColors, borderColors, pointRadii } = buildHighlightArrays(
        dataPoints, highlightDateKey, 'rgba(255,165,0,1)', '#4DAAFF', 2.5, 5
      );

      exerciseRepProgressionChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: `Repetitions: ${exerciseName} (${weight}kg)`,
            data: dataPoints.map(dp => dp.y),
            borderColor: '#FFA500',
            backgroundColor: 'rgba(255,165,0,0.2)',
            fill: true,
            tension: 0.1,
            pointRadius: pointRadii,
            pointBackgroundColor: bgColors,
            pointBorderColor: borderColors,
            pointHoverRadius: 6
          }]
        },
        options: {
			layout: {
		  padding: {
			top: 0,
			bottom: 0,
			left: 0,
			right: 0,
		  }
		},
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              title: { display: true, text: 'Date' },
              ticks: { color: '#ccc' },
              grid: { color: '#555' }
            },
            y: {
              suggestedMin,
              suggestedMax,
              title: { display: true, text: 'Repetitions' },
              ticks: { color: '#ccc' },
              grid: { color: '#555' }
            }
          },
          plugins: {
            legend: { 
				labels: { color: '#eee' } ,
				padding: {
				top: 1,
				bottom: 1
			  }
			},
            title: {
              display: true,
              text: `Rep progression at ${weight} KG`,
              color: '#fff',
              font: { size: 16 },
			  padding: {
				top: 1,
				bottom: 1
			  }
            }
          }
        }
      });
    }

    /*
      =======================================
      = 14) Volume Over Time (Day-Level)    =
      =======================================
    */
    function openVolumeModal(dateKey) {
      document.getElementById("volumeOverlay").classList.add("active");
      buildVolumeChart(dateKey);
    }
    function closeVolumeModal() {
      document.getElementById("volumeOverlay").classList.remove("active");
      if(volumeChart){
        volumeChart.destroy();
        volumeChart = null;
      }
    }
    function buildVolumeChart(highlightDateKey) {
      const dateKeys = Object.keys(calendarData)
        .filter(k => calendarData[k].hevyWorkouts && calendarData[k].hevyWorkouts.length > 0)
        .sort();

      const dataPoints = dateKeys.map(k => {
        const day = calendarData[k];
        let volume = 0;
        day.hevyWorkouts.forEach(w => {
          w.exercises.forEach(ex => {
            ex.sets.forEach(set => {
              volume += set.weight_kg * set.reps;
            });
          });
        });
        return { x: k, y: volume };
      });

      if(dataPoints.length < 1){
        showCustomAlert("No volume data found.");
        return;
      }
      const labels = dataPoints.map(dp => {
        const d = parseDateKey(dp.x);
        return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
      });

      const volumes = dataPoints.map(dp => dp.y);
      const minVolume = Math.min(...volumes);
      const maxVolume = Math.max(...volumes);
      const suggestedMin = Math.max(0, minVolume - 10);
      const suggestedMax = maxVolume + 10;

      if(volumeChart){
        volumeChart.destroy();
        volumeChart = null;
      }
      const ctx = document.getElementById('volumeChart').getContext('2d');

      const { bgColors, borderColors, pointRadii } = buildHighlightArrays(
        dataPoints, highlightDateKey, 'rgba(255,165,0,1)', '#4DAAFF', 2.5, 5
      );

      volumeChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Volume (kg)',
            data: dataPoints.map(dp => dp.y),
            borderColor: '#FFA500',
            backgroundColor: 'rgba(255,165,0,0.2)',
            fill: true,
            tension: 0.1,
            pointRadius: pointRadii,
            pointBackgroundColor: bgColors,
            pointBorderColor: borderColors,
            pointHoverRadius: 4
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: { 
              title: { display: true, text: 'Date' }, 
              ticks: { color: '#ccc' }, 
              grid: { color: '#555' }
            },
            y: { 
              suggestedMin, 
              suggestedMax, 
              title: { display: true, text: 'Volume (kg)' }, 
              ticks: { color: '#ccc' }, 
              grid: { color: '#555' } 
            }
          },
          plugins: { legend: { labels: { color: '#eee' } } }
        }
      });
    }

    /*
      =======================================
      = 15) Per-Exercise Volume Chart       =
      =======================================
    */
    function openExerciseVolumeModal(exerciseName, dateKey) {
      document.getElementById("exerciseVolumeOverlay").classList.add("active");
      buildExerciseVolumeProgressionChart(exerciseName, dateKey);
    }
    function closeExerciseVolumeModal() {
      document.getElementById("exerciseVolumeOverlay").classList.remove("active");
      destroyExerciseVolumeChart();
    }
    function destroyExerciseVolumeChart() {
      if(exerciseVolumeChart) {
        exerciseVolumeChart.destroy();
        exerciseVolumeChart = null;
      }
    }
    function buildExerciseVolumeProgressionChart(exerciseName, highlightDateKey) {
      const dateKeys = Object.keys(calendarData).sort();
      const dataMap = {};

      dateKeys.forEach(k => {
        const dayObj = calendarData[k];
        if(dayObj.hevyWorkouts && dayObj.hevyWorkouts.length > 0) {
          let exerciseVolume = 0;
          dayObj.hevyWorkouts.forEach(workout => {
            workout.exercises.forEach(ex => {
              if(ex.title === exerciseName) {
                ex.sets.forEach(s => {
                  exerciseVolume += (s.weight_kg * s.reps);
                });
              }
            });
          });
          if(exerciseVolume > 0) {
            dataMap[k] = exerciseVolume;
          }
        }
      });

      const chartKeys = Object.keys(dataMap).sort();
      if(chartKeys.length < 1) {
        destroyExerciseVolumeChart();
        document.getElementById("exerciseVolumeOverlay").classList.remove("active");
        showCustomAlert(`No volume data found for '${exerciseName}'.`);
        return;
      }

      const dataPoints = chartKeys.map(k => ({ x: k, y: dataMap[k] }));
      const labels = chartKeys.map(k => {
        const d = parseDateKey(k);
        return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
      });

      const volumes = dataPoints.map(dp => dp.y);
      const minV = Math.min(...volumes);
      const maxV = Math.max(...volumes);
      const range = maxV - minV;
      const pad = range * 0.1;
      const suggestedMin = (minV - pad < 0) ? 0 : (minV - pad);
      const suggestedMax = maxV + pad;

      destroyExerciseVolumeChart();
      const ctx = document.getElementById('exerciseVolumeChart').getContext('2d');

      const { bgColors, borderColors, pointRadii } = buildHighlightArrays(
        dataPoints, highlightDateKey, 'rgba(77,221,255,1)', '#4DAAFF', 2.5, 5
      );

      exerciseVolumeChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: `Volume: ${exerciseName}`,
            data: dataPoints.map(dp => dp.y),
            borderColor: '#4DDCFF',
            backgroundColor: 'rgba(77,221,255,0.2)',
            fill: true,
            tension: 0.1,
            pointRadius: pointRadii,
            pointBackgroundColor: bgColors,
            pointBorderColor: borderColors,
            pointHoverRadius: 6
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: { 
              title: { display: true, text: 'Date' }, 
              ticks: { color: '#ccc' }, 
              grid: { color: '#555' }
            },
            y: { 
              suggestedMin, 
              suggestedMax, 
              title: { display: true, text: 'Exercise Volume (kg)' }, 
              ticks: { color: '#ccc' }, 
              grid: { color: '#555' } 
            }
          },
          plugins: { legend: { labels: { color: '#eee' } } }
        }
      });
    }

    /*
      =======================================
      = 16) ORM Progress Over Time Chart    =
      =======================================
    */
    function openOrmProgressModal(exerciseName, dateKey) {
	// Reset date range to "Year"
	document.querySelectorAll('#exerciseOrmProgressModal .date-range-btn').forEach(btn => {
		btn.classList.toggle('active', btn.getAttribute('data-range') === 'year');
    });
      currentOrmExercise = exerciseName;
      currentOrmDateKey = dateKey;
      document.getElementById("ormProgressOverlay").classList.add("active");
      buildExerciseOrmProgressChart(exerciseName, dateKey);
    }
    function closeOrmProgressModal() {
      document.getElementById("ormProgressOverlay").classList.remove("active");
      destroyOrmProgressChart();
    }
    function destroyOrmProgressChart() {
      if(exerciseOrmProgressChart) {
        exerciseOrmProgressChart.destroy();
        exerciseOrmProgressChart = null;
      }
    }
    // Variables to store current ORM exercise info
	let currentOrmExercise = null;
	let currentOrmDateKey = null;

	function buildExerciseOrmProgressChart(exerciseName, highlightDateKey) {
	  // Figure out which date range to display
	  const selectedRange = document.querySelector('#exerciseOrmProgressModal .date-range-btn.active').getAttribute('data-range');
	  const refDate = parseDateKey(highlightDateKey);
	  const { start, end } = getDateRangeBounds(selectedRange, refDate);

	  // Collect only the date keys that fall within (start..end)
	  const dateKeys = Object.keys(calendarData)
		.filter(key => {
		  const date = parseDateKey(key);
		  return date >= start && date <= end;
		})
		.sort();

	  // dataMap is now an object that stores { orm, bestWeight, bestReps }
	  const dataMap = {};

	  // We'll store the best (weight, reps) that produced the highest ORM each day
	  dateKeys.forEach(k => {
		let dayMaxOrm = 0;
		let bestSet = null; // to store { weight, reps } for that day's best set

		const dayObj = calendarData[k];
		if (dayObj.hevyWorkouts) {
		  dayObj.hevyWorkouts.forEach(workout => {
			workout.exercises.forEach(ex => {
			  if (ex.title === exerciseName) {
				ex.sets.forEach(s => {
				  const setOrm = computeOrm(s.weight_kg, s.reps);
				  if (setOrm > dayMaxOrm) {
					dayMaxOrm = setOrm;
					bestSet = { weight: s.weight_kg, reps: s.reps };
				  }
				});
			  }
			});
		  });
		}

		// Only record if the day's best ORM > 0
		if (dayMaxOrm > 0 && bestSet) {
		  dataMap[k] = {
			orm: dayMaxOrm,
			bestWeight: bestSet.weight,
			bestReps: bestSet.reps
		  };
		}
	  });

	  // If no data points, exit
	  const chartKeys = Object.keys(dataMap).sort();
	  if (chartKeys.length < 1) {
		destroyOrmProgressChart();
		document.getElementById("ormProgressOverlay").classList.remove("active");
		showCustomAlert(`No ORM data found for '${exerciseName}'.`);
		return;
	  }

	  // Build arrays for Chart.js
	  // We'll keep the numeric ORMs in dataPoints,
	  // and remember that 'chartKeys[index]' can retrieve the metadata from dataMap.
	  const dataPoints = chartKeys.map(k => dataMap[k].orm);

	  // Build the user-facing labels (display dates)
	  const labels = chartKeys.map(k => {
		const d = parseDateKey(k);
		return d.toLocaleDateString('en-US', {
		  month: 'short',
		  day: 'numeric',
		  year: 'numeric'
		});
	  });

	  // Figure out suggestedMin / suggestedMax for Y-axis
	  const orms = dataPoints;
	  const minOrm = Math.min(...orms);
	  const maxOrm = Math.max(...orms);
	  const range = maxOrm - minOrm;
	  const pad = range * 0.1;
	  const suggestedMin = (minOrm - pad < 0) ? 0 : (minOrm - pad);
	  const suggestedMax = maxOrm + pad;

	  // destroy old chart if it exists
	  destroyOrmProgressChart();

	  // get canvas context
	  const ctx = document.getElementById('exerciseOrmProgressChart').getContext('2d');

	  // build highlight arrays for the chart
	  const { bgColors, borderColors, pointRadii } = buildHighlightArrays(
		chartKeys.map(k => ({ x: k, y: dataMap[k].orm })), // pass array of { x, y }
		highlightDateKey,
		'rgba(255,255,0,1)',
		'#4DAAFF',
		2.5,
		5
	  );

	  // Provide a custom tooltip callback to show weight x reps
	  exerciseOrmProgressChart = new Chart(ctx, {
		type: 'line',
		data: {
		  labels: labels,
		  datasets: [{
			label: `ORM: ${exerciseName}`,
			data: dataPoints, // numeric ORM values
			borderColor: '#FFFF00',
			backgroundColor: 'rgba(255,255,0,0.2)',
			fill: true,
			tension: 0.1,
			pointRadius: pointRadii,
			pointBackgroundColor: bgColors,
			pointBorderColor: borderColors,
			pointHoverRadius: 6
		  }]
		},
		options: {
		  responsive: true,
		  maintainAspectRatio: false,
		  scales: {
			x: {
			  title: { display: true, text: 'Date' },
			  ticks: { color: '#ccc' },
			  grid: { color: '#555' }
			},
			y: {
			  suggestedMin,
			  suggestedMax,
			  title: { display: true, text: 'Estimated 1RM (kg)' },
			  ticks: { color: '#ccc' },
			  grid: { color: '#555' }
			}
		  },
		  plugins: {
			legend: {
			  labels: { color: '#eee' }
			},
			tooltip: {
			  callbacks: {
				// Top line in tooltip
				title: function(tooltipItems) {
				  // Typically tooltipItems is array of points; we use the first
				  return tooltipItems[0].label; // e.g. "Jan 10, 2025"
				},
				// Second line(s) in tooltip
				label: function(context) {
				  // The dataIndex points to whichever day we hovered
				  const i = context.dataIndex;
				  const dateKey = chartKeys[i]; // e.g. "2025-01-10"
				  const info = dataMap[dateKey]; // { orm, bestWeight, bestReps }

				  // Build lines
				  const ormText = `ORM: ${info.orm.toFixed(1)}kg`;
				  const setText = `(${info.bestWeight}kg x ${info.bestReps})`;
				  // Return an array => multiple lines in the tooltip
				  return [ormText, setText];
				}
			  }
			}
		  }
		}
	  });
	}

    /*
      =======================================
      = 17) Populate Calendar Button        =
      =======================================
      Only applies to the *currentYear*.
    */
    function populateEntireCalendar() {
      // Turn the currently selectedDates into a cycle pattern
      // We'll then fill out *only the current year* from Jan 1 to Dec 31
      const cycleDataArray = Array.from(selectedDates).sort();
      if(cycleDataArray.length === 0){
        showCustomAlert("No cycle days selected.");
        return;
      }

      const sortedCycle = cycleDataArray.map(k => parseDateKey(k)).sort((a,b) => a - b);
      const sortedCycleKeys = sortedCycle.map(d => getDateKey(d));
      const cyclePattern = sortedCycleKeys.map(k => ({ ...getDayData(k) }));
      const patternLength = cyclePattern.length;
      const startDate = new Date(sortedCycle[0].getTime());

      // We'll only overwrite the currentYear
      const firstOfYear = new Date(currentYear, 0, 1);
      const lastOfYear = new Date(currentYear, 11, 31);

      // Step 1: Fill backwards within currentYear
      let currentDate = new Date(startDate.getTime());
      let cycleIndex = cyclePattern.length;
      while(currentDate >= firstOfYear) {
        currentDate.setDate(currentDate.getDate() -1);
        cycleIndex = (cycleIndex -1 + patternLength) % patternLength;
        if(currentDate < firstOfYear) break;
        const dateKey = getDateKey(currentDate);
        const cycleData = cyclePattern[cycleIndex];
        calendarData[dateKey] = {
          shiftClass: cycleData.shiftClass,
          gym: cycleData.gym,
          gymTime: cycleData.gymTime,
          workTime: cycleData.workTime,
          completed: cycleData.completed,
          weight: cycleData.weight,
          alert: cycleData.alert,
          hevyWorkouts: cycleData.hevyWorkouts ? [...cycleData.hevyWorkouts] : []
        };
      }

      // Step 2: Fill forwards within currentYear
      currentDate = new Date(startDate.getTime());
      cycleIndex = 0;
      while(currentDate <= lastOfYear) {
        const dateKey = getDateKey(currentDate);
        const cycleData = cyclePattern[cycleIndex % cyclePattern.length];
        calendarData[dateKey] = {
          shiftClass: cycleData.shiftClass,
          gym: cycleData.gym,
          gymTime: cycleData.gymTime,
          workTime: cycleData.workTime,
          completed: cycleData.completed,
          weight: cycleData.weight,
          alert: cycleData.alert,
          hevyWorkouts: cycleData.hevyWorkouts ? [...cycleData.hevyWorkouts] : []
        };
        cycleIndex++;
        currentDate.setDate(currentDate.getDate() + 1);
        if(currentDate > lastOfYear) break;
      }

      // We'll store that cycle as the default pattern
      defaultCycleData = {
        pattern: [...cyclePattern],
        startDate: getDateKey(sortedCycle[0])
      };
      localStorage.setItem(LS_DEFAULT_CYCLE_KEY, JSON.stringify(defaultCycleData));
      localStorage.setItem(LS_CALENDAR_DATA_KEY, JSON.stringify(calendarData));

      selectedDates.clear();
      renderCalendar(currentYear, currentMonth);
      showCustomAlert("Current year's calendar has been populated with your custom cycle.");
    }
    function updatePopulateCalendarButtonState() {
      const btn = document.getElementById("populateCalendarBtn");
      if(selectedDates.size >=2){
        btn.disabled = false;
        btn.style.opacity = "1";
        btn.style.border = "2px solid gold";
      }
      else{
        btn.disabled = true;
        btn.style.opacity = "0.5";
        btn.style.border = "2px solid #555";
      }
    }

    /*
      =======================================
      =    Clear Calendar Function          =
      =======================================
    */
    function clearCalendar() {
      showCustomConfirm("Are you sure you want to clear the entire calendar? This will remove all your data and set all days to 'None'. This action cannot be undone.", () => {
        // We'll wipe *all years* from START_YEAR..END_YEAR,
        // effectively resetting everything to default blank
        for(let year = START_YEAR; year <= END_YEAR; year++){
          const startDate = new Date(year, 0, 1);
          const endDate = new Date(year, 11, 31);
          const totalDays = Math.floor((endDate - startDate) / MS_IN_DAY) + 1;

          for(let i = 0; i < totalDays; i++){
            const currentDate = new Date(startDate.getTime() + i * MS_IN_DAY);
            const dateKey = getDateKey(currentDate);
            calendarData[dateKey] = {
              shiftClass: "off-bg",
              gym: "None",
              gymTime: "",
              workTime: "",
              completed: false,
              weight: null,
              alert: null,
              hevyWorkouts: []
            };
          }
        }

        localStorage.setItem(LS_CALENDAR_DATA_KEY, JSON.stringify(calendarData));
        defaultCycleData = { pattern: [], startDate: null };
        localStorage.setItem(LS_DEFAULT_CYCLE_KEY, JSON.stringify(defaultCycleData));

        selectedDates.clear();
        renderCalendar(currentYear, currentMonth);
        showCustomAlert("Calendar has been cleared. All days are now set to 'None'.");
      });
    }

    /*
      =======================================
      =  Custom Alert/Prompt/Confirm        =
      =======================================
    */
    function showCustomAlert(message) {
      const overlay = document.getElementById("customAlertOverlay");
      const messageElem = document.getElementById("customAlertMessage");
      const inputElem = document.getElementById("customAlertInput");
      const confirmButtons = document.getElementById("customConfirmButtons");
      const defaultButton = document.getElementById("customDefaultButton");

      messageElem.textContent = message;
      inputElem.style.display = "none";
      confirmButtons.style.display = "none";
      defaultButton.style.display = "block";

      overlay.classList.add("active");
    }
    function showCustomConfirm(message, onConfirm) {
      const overlay = document.getElementById("customAlertOverlay");
      const messageElem = document.getElementById("customAlertMessage");
      const inputElem = document.getElementById("customAlertInput");
      const confirmButtons = document.getElementById("customConfirmButtons");
      const defaultButton = document.getElementById("customDefaultButton");

      messageElem.textContent = message;
      inputElem.style.display = "none";
      confirmButtons.style.display = "flex";
      defaultButton.style.display = "none";

      // Remove old buttons if any
      const existingYes = document.getElementById("customYesBtn");
      const existingNo = document.getElementById("customNoBtn");
      if(existingYes) existingYes.remove();
      if(existingNo) existingNo.remove();

      const yesButton = document.createElement("button");
      yesButton.id = "customYesBtn";
      yesButton.textContent = "Yes";
      yesButton.onclick = () => {
        overlay.classList.remove("active");
        onConfirm();
      };

      const noButton = document.createElement("button");
      noButton.id = "customNoBtn";
      noButton.textContent = "No";
      noButton.onclick = () => {
        overlay.classList.remove("active");
      };

      confirmButtons.appendChild(yesButton);
      confirmButtons.appendChild(noButton);
      overlay.classList.add("active");
    }
    function showCustomPrompt(message, placeholder, callback) {
      const overlay = document.getElementById("customAlertOverlay");
      const messageElem = document.getElementById("customAlertMessage");
      const inputElem = document.getElementById("customAlertInput");
      const confirmButtons = document.getElementById("customConfirmButtons");
      const defaultButton = document.getElementById("customDefaultButton");

      messageElem.textContent = message;
      inputElem.style.display = "block";
      inputElem.placeholder = placeholder || "";
      confirmButtons.style.display = "flex";
      defaultButton.style.display = "none";

      // Remove old buttons if any
      const existingYes = document.getElementById("customYesBtn");
      const existingNo = document.getElementById("customNoBtn");
      if(existingYes) existingYes.remove();
      if(existingNo) existingNo.remove();

      const yesButton = document.createElement("button");
      yesButton.id = "customYesBtn";
      yesButton.textContent = "OK";
      yesButton.onclick = () => {
        const inputVal = inputElem.value.trim();
        overlay.classList.remove("active");
        callback(inputVal);
      };

      const noButton = document.createElement("button");
      noButton.id = "customNoBtn";
      noButton.textContent = "Cancel";
      noButton.onclick = () => {
        overlay.classList.remove("active");
      };

      confirmButtons.appendChild(yesButton);
      confirmButtons.appendChild(noButton);

      inputElem.value = "";
      overlay.classList.add("active");
    }
    function closeCustomAlert() {
      const overlay = document.getElementById("customAlertOverlay");
      const messageElem = document.getElementById("customAlertMessage");
      const inputElem = document.getElementById("customAlertInput");
      const confirmButtons = document.getElementById("customConfirmButtons");
      const defaultButton = document.getElementById("customDefaultButton");

      const yesBtn = document.getElementById("customYesBtn");
      const noBtn = document.getElementById("customNoBtn");
      if(yesBtn) yesBtn.remove();
      if(noBtn) noBtn.remove();

      messageElem.textContent = "";
      inputElem.style.display = "none";
      confirmButtons.style.display = "none";
      defaultButton.style.display = "block";

      overlay.classList.remove("active");
    }

    /*
      =======================================
      = 19) DOM Loaded: Event Setup         =
      =======================================
    */
    window.addEventListener("DOMContentLoaded", () => {
      buildColorSwatches();

      // Single modal
      document.getElementById("singleSaveBtn").addEventListener("click", saveSingleModal);
      document.getElementById("singleRevertBtn").addEventListener("click", revertSingleModal);
      document.getElementById("singleCancelBtn").addEventListener("click", closeSingleModal);
      document.querySelectorAll("#singleModal .reset-emoji").forEach(btn => {
        btn.addEventListener("click", () => { resetSingleField(btn.getAttribute("data-field")); });
      });

      // Multi modal
      document.getElementById("multiKeySelect").addEventListener("change", handleMultiKeyChange);
      document.getElementById("multiSaveBtn").addEventListener("click", saveMultiModal);
      document.getElementById("multiRevertBtn").addEventListener("click", revertMultiModal);
      document.getElementById("multiCancelBtn").addEventListener("click", closeMultiModal);

      // Stats
      document.getElementById("statsBtn").addEventListener("click", openStatsModal);
      document.getElementById("statsCloseBtn").addEventListener("click", closeStatsModal);

      // Backup
      document.getElementById("saveDataBtn").addEventListener("click", saveData);
      document.getElementById("loadDataBtn").addEventListener("click", () => {
        document.getElementById("importFileInput").click();
      });
      document.getElementById("importFileInput").addEventListener("change", (event) => {
        const file = event.target.files[0];
        if(file) {
          showCustomConfirm("Loading data will overwrite your current calendar data. Proceed?", () => {
            loadData(file);
          });
        }
        event.target.value = "";
      });

      // Hevy import
      document.getElementById("hevyImportBtn").addEventListener("click", () => {
        showCustomPrompt("Enter your Hevy API key:", "API Key", (apiKey) => {
          if(apiKey){
            importHevyData(apiKey);
          } else {
            showCustomAlert("Hevy API key is required to import data.");
          }
        });
      });

      // Populate calendar
      document.getElementById("populateCalendarBtn").addEventListener("click", () => {
        showCustomConfirm("Populate the current year with the selected cycle? This will overwrite existing data in that year for those days.", () => {
          populateEntireCalendar();
        });
      });

      // Hevy summary modal
      document.getElementById("hevyCloseBtn").addEventListener("click", closeHevyModal);

      // Volume chart modal
      document.getElementById("volumeCloseBtn").addEventListener("click", closeVolumeModal);

      // Exercise volume chart modal
      document.getElementById("exerciseVolumeCloseBtn").addEventListener("click", closeExerciseVolumeModal);

      // Combined progression modal
      document.getElementById("exerciseProgressCloseBtn").addEventListener("click", closeExerciseProgressModal);
	  
	  document.addEventListener('click', (e) => {
        const rangeBtn = e.target.closest('.date-range-btn');
        if (rangeBtn && !rangeBtn.classList.contains('active')) {
          // Update active state
          document.querySelectorAll('.date-range-btn').forEach(btn => btn.classList.remove('active'));
          rangeBtn.classList.add('active');
          
          // Rebuild charts with new range if we have current progression data
          if (currentProgressionExercise && currentProgressionDateKey) {
            buildExerciseWeightProgressChart(
              currentProgressionExercise,
              currentProgressionReps,
              currentProgressionDateKey
            );
            buildExerciseRepProgressChart(
              currentProgressionExercise,
              currentProgressionWeight,
              currentProgressionDateKey
            );
          }
        }
      });

	// ORM progress modal
	document.getElementById("ormProgressCloseBtn").addEventListener("click", closeOrmProgressModal);
		  
	// ORM date range button handlers
	document.getElementById("exerciseOrmProgressModal").addEventListener('click', (e) => {
	  const ormRangeBtn = e.target.closest('.date-range-btn');
	  if (ormRangeBtn && !ormRangeBtn.classList.contains('active')) {
		// Update active state
		document.querySelectorAll('#exerciseOrmProgressModal .date-range-btn')
		  .forEach(btn => btn.classList.remove('active'));
		ormRangeBtn.classList.add('active');
		
		// Rebuild ORM chart with new range if we have current data
		if (currentOrmExercise && currentOrmDateKey) {
		  buildExerciseOrmProgressChart(currentOrmExercise, currentOrmDateKey);
		}
	  }
	});

      // Clear Calendar
      document.getElementById("clearCalendarBtn").addEventListener("click", clearCalendar);

      // Help
      document.getElementById("helpBtn").addEventListener("click", () => {
        showCustomAlert("Help feature is coming soon!");
      });

      // Calendar cell selection (click & drag)
      document.addEventListener("mousedown", (e) => {
        // If overlay or a button is clicked, skip
        if(document.querySelector(".overlay.active")) return;
        if(e.target.closest("button")) return;

        // Middle mouse => open Hevy
        if (e.button === 1) {
          e.preventDefault();
          const dayCell = e.target.closest(".day-cell");
          if (dayCell) {
            const dateKey = dayCell.getAttribute("data-date-key");
            if (dateKey) {
              openHevyModal(dateKey);
            }
          }
          return;
        }

        if(e.target.closest(".refresh-emoji") || e.target.closest(".completed-badge")) return;
        e.preventDefault();

        const dayCell = e.target.closest(".day-cell");
        if(!dayCell){
          selectedDates.clear();
          renderCalendar(currentYear, currentMonth);
          return;
        }
        isDragging = true;

        if(!e.ctrlKey && !e.metaKey){
          selectedDates.clear();
        }

        const startRow = parseInt(dayCell.getAttribute("data-row"), 10);
        const startCol = parseInt(dayCell.getAttribute("data-col"), 10);
        const dateKey = dayCell.getAttribute("data-date-key");
        if(dateKey) selectedDates.add(dateKey);
        renderCalendar(currentYear, currentMonth);

        const mouseMoveHandler = (moveEvent) => {
          if(!isDragging) return;
          const cell = moveEvent.target.closest(".day-cell");
          if(cell){
            const row = parseInt(cell.getAttribute("data-row"), 10);
            const col = parseInt(cell.getAttribute("data-col"), 10);
            const minRow = Math.min(startRow, row);
            const maxRow = Math.max(startRow, row);
            const minCol = Math.min(startCol, col);
            const maxCol = Math.max(startCol, col);

            if(!moveEvent.ctrlKey && !moveEvent.metaKey){
              selectedDates.clear();
            }
            const allCells = document.querySelectorAll(".calendar-grid .day-cell");
            allCells.forEach(c => {
              const r = parseInt(c.getAttribute("data-row"), 10);
              const cc = parseInt(c.getAttribute("data-col"), 10);
              if(r >= minRow && r <= maxRow && cc >= minCol && cc <= maxCol){
                const dk = c.getAttribute("data-date-key");
                if(dk) selectedDates.add(dk);
              }
            });
            renderCalendar(currentYear, currentMonth);
          }
        };
        const mouseUpHandler = () => {
          isDragging = false;
          document.removeEventListener("mousemove", mouseMoveHandler);
          document.removeEventListener("mouseup", mouseUpHandler);
        };
        document.addEventListener("mousemove", mouseMoveHandler);
        document.addEventListener("mouseup", mouseUpHandler);
      });
	  
	document.addEventListener("keydown", (e) => {
	  // Check if user pressed 'h' or 'H'
	  if (e.key === "h" || e.key === "H") {
		// Check if any overlay (modal) is active
		const anyOverlayActive = document.querySelector(".overlay.active");
		if (anyOverlayActive) {
		  // If a modal is already open, do nothing
		  return;
		}

		// Only proceed if exactly one date is selected
		if (selectedDates.size === 1) {
		  const [dateKey] = [...selectedDates];
		  openHevyModal(dateKey);
		} else {
		  showCustomAlert("You must have exactly one day cell selected to open the Hevy summary with the H key.");
		}
	  }
	});
      // Finally, initial render:
      renderCalendar(currentYear, currentMonth);
    });
  </script>
</body>
</html>
